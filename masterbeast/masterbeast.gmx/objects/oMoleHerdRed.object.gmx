<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sSigilMoleSmall1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>mMoleParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

OriginalX = x
OriginalY = y
Status = "whole"
ZoomedOutSprite = sMoleSmallRed
ZoomedOutDirection = random(360)
direction = 0

Size = "large"

image_xscale = 0.6
image_yscale = image_xscale
depth = OnObjectsLayer + 0.002
ZoomedInSprite = sRedMole


ZoomedOutXScale = 0
ZoomedOutXScaleTarget = image_xscale
ZoomedOutYScale = 0
ZoomedOutYScaleTarget = ZoomedOutXScaleTarget
ZoomedInScale = 0
ZoomedInScaleTarget = image_xscale / 4
OriginalDepth = depth
VibeReady = true

OriginalXScale = image_xscale
OriginalYScale = image_xscale
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale

ZoomedInDirection = 0
UnoccupiedRotation = random(360)
Redness = 0
Occupied = true
ID = 0
ChangeMultiplier = 0
XDir = 0

CutAmount = 0
Cutting = false

Ripped = false
DripTimer = irandom_range(30,120)

XDifference = 0
YDifference = 0
UpAmount = 60
BaseRedness = 0

GrownToSize = false

SpriteIndexOutXScale = 0
SpriteIndexOutYScale = 0
SpriteIndexOutAlpha = 0
SpriteIndexInAlpha = 0
SpriteIndexInXScale = 0
SpriteIndexInYScale = 0


Activated = false

ChangeSpriteWithZoom(ZoomedOutXScale,ZoomedOutYScale,ZoomedInScale,ZoomedInScale)

//-----------------------------------------
//Senses

SenseRadius = 600
ClusterRadius = 100
MaxChildren = round(100 * OriginalXScale)
CurrentChildren = 0
BabyCreateLower = 2000 * OriginalXScale
BabyCreateHigher = 4000 * OriginalXScale
BabyTimer = 0
SensedMole = false
LastRememberedMole = noone
NearestMole = noone
SensedFur = false
LastRememberedFur = noone
NearestFur = noone
SensedWound = false
LastRememberedWound = noone
WoundOfInterest = noone
NearestWound = noone
GapAhead1 = false
GapAhead2 = false
GapAhead3 = false
WoundAhead1 = false
WoundAhead2 = false
WoundAhead3 = false 
CollidingWound = false
CollidingWall = false

//Growing

GrowMax = OriginalXScale + 0.05
GrowRate = random_range(0.000002,0.000003)
OriginalGrowRate = GrowRate
EatingGrowRate = GrowRate * 1.5

//Drives &amp; States

State = "grazing"

Hunger = 0
HungerChangeMod = 1
HungerLatch = 40
Loneliness = 0
LonelinessLatch = 40
FleeTimer = 0
TempSpeedMod = 0
TabooArea = false
FavouredArea = false
Activating = false
WakingUp = true
WakingTimer = 0

//Behaviours

GrazingSpeed = 10 / room_speed
GrazeX = x
GrazeY = y
GrazeRadius = 100
Pausing = false
GrazeTimer = 60
GrazePauseTimer = 300
GrazePTLower = 150 
GrazePTUpper = 400
GrazeTLower = 200
GrazeTUpper = 500 

WanderSpeed = 30 / room_speed
WanderRange = 200
WanderRadius = 700
BaseWanderRadius = 700
WanderStartX = x
WanderStartY = y
DitherMod = 2
AlignVar = 0
SepVar = 0
Neighbours = 0
CurrentlyHunting = "food"
MoleProx = 60
WoundProx = sprite_width * 2
WanderTimer = 300
WanderPauseTimer = 100
WanderPTLower = 60 
WanderPTUpper = 180
WanderTLower = 2000
WanderTUpper = 3000
CallOrNot = 0
Called = false

FleeSpeed = 60 / room_speed
SourceOfFear = noone
ContagTimer = 0
Contaged = false
FleeModRange = 50
GoneOffScreen = false

ShiverTimer = 0
ShiverDirection = "left"
ShiverOrNot = 0
XOffset = 0

ViewSpeedMod = 0
SpeedMod = 1
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.5
DesiredHeading = random(360)
DirectionChangeRate = 1
Slowdown = 0.5

//Collision

CollisionLength = 50
GapLength = 25
CollisionWidth = 35
CollisionAhead1 = noone
CollisionAhead2 = noone
CollisionAhead3 = noone
Turning = false
ColPointXM = 0
ColPointYM = 0
ColPointXL = 0
ColPointYL = 0
ColPointXR = 0
ColPointYR = 0


TabooLayer3Ahead1 = noone
TabooLayer3Ahead2 = noone
TabooLayer3Ahead3 = noone
TabooLayer3Blocking = true

TabooLayer1Ahead1 = noone
TabooLayer2Ahead2 = noone
TabooLayer1Ahead3 = noone
TabooLayer1Blocking = true

TabooLayer2Ahead1 = noone
TabooLayer2Ahead2 = noone
TabooLayer2Ahead3 = noone
TabooLayer2Blocking = true

//Initialise!
CurrentSpeed = DesiredSpeed
CurrentHeading = DesiredHeading
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Grow To Size

if GrownToSize = false {

if ZoomedOutXScale &lt; ZoomedOutXScaleTarget {
ZoomedOutXScale += 0.001
ZoomedOutYScale = ZoomedOutXScale
}
if ZoomedInScale &lt; ZoomedInScaleTarget {
ZoomedInScale += 0.02
}
}

if ZoomedOutXScale &gt;= ZoomedOutXScaleTarget
and ZoomedInScale &gt;= ZoomedInScaleTarget {
GrownToSize = true
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Limits &amp; Activations

ChangeSpriteWithZoom(ZoomedOutXScale,ZoomedOutYScale,ZoomedInScale,ZoomedInScale)

Redness = BaseRedness + ((0.5 / 100) * mDriveCollectionMaster.RitualTolerance)
BaseRedness = clamp(BaseRedness,0,0.5)

if Occupied = true {
sprite_index = ZoomedInSprite
image_xscale = ZoomedInScale
image_yscale = ZoomedInScale
} else if Occupied = false {
if mInterfaceController.CurrentView = MicroView {
sprite_index = sSigilMoleBottom
image_xscale = ZoomedInScale - 0.2 
image_yscale = ZoomedInScale - 0.2 
}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make A Trail If Moving

if (speed &gt; 0 or State = "clustering" or State = "eating") and (mInterfaceController.CurrentView = "Micro" and Activated = true) {
CreateParticleSplash(x,y,5,ps_shape_ellipse,ps_distr_gaussian,c_black,0.003,0.005,0.02,0.05,20,160,60,100,0,10)
CreateStain(4,direction - 210,direction - 150,0.000001,0.000002,0.003,1,30,0.0001,0.0007,c_black,x,y)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cutting Out

CutAmount = clamp(CutAmount,0,100)

//Cutting Begin

if instance_exists(mFinger) {
if (place_meeting(x,y,mFinger)
and instance_exists(mDebug) = false
and mInterfaceController.CurrentHandUse = "knife"
and mInterfaceController.CurrentView = MicroView
and Occupied = true)
or (place_meeting(x,y,mWoundParent))
{
CreateParticleSplash(x,y,3,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,5,15,0.04,0.07,0,360,70,125,0.5,30)
CreateStain(10,0,360,5,10,0.2,0.3,0.5,0.05,0.06,BloodLiquidColour,x,y)
WriteToLog("Cut out normal mole.")
Occupied = false
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
Cutting = false
instance_destroy()
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Touching

if place_meeting(x,y,mFinger) and  mInterfaceController.CurrentView = MicroView and instance_exists(mDebug) = false{
TouchMoleReactions()
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Senses &amp; Memory


//Collision Sensing

ColPointXM = x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = y + lengthdir_y(CollisionLength,CurrentHeading)
ColPointXL = x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)
ColPointXR = x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

GapPointXM = x + lengthdir_x(GapLength,CurrentHeading)
GapPointYM = y + lengthdir_y(GapLength,CurrentHeading)
GapPointXL = x + lengthdir_x(GapLength,CurrentHeading - CollisionWidth)
GapPointYL = y + lengthdir_y(GapLength,CurrentHeading - CollisionWidth)
GapPointXR = x + lengthdir_x(GapLength,CurrentHeading + CollisionWidth)
GapPointYR = y + lengthdir_y(GapLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mCollisionParent,true,true)
CollisionAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mCollisionParent,true,true)
CollisionAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mCollisionParent,true,true)

if oTabooLayer1.Health &gt; 0 {
TabooLayer1Blocking= true
TabooLayer1Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer1,true,true)
TabooLayer1Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer1,true,true)
TabooLayer1Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer1,true,true)
} else {
TabooLayer1Blocking = false
}

if oTabooLayer2.Health &gt; 0 {
TabooLayer2Blocking= true
TabooLayer2Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer2,true,true)
TabooLayer2Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer2,true,true)
TabooLayer2Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer2,true,true)
} else {
TabooLayer2Blocking = false
}

if oTabooLayer3.Health &gt; 0 {
TabooLayer3Blocking = true
TabooLayer3Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer3,true,true)
TabooLayer3Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer3,true,true)
TabooLayer3Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer3,true,true)
} else {
TabooLayer3Blocking = false
}

WoundAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mWoundParent,true,true)
WoundAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mWoundParent,true,true)
WoundAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mWoundParent,true,true)

if collision_point(GapPointXL,GapPointYL,mHeadParent,true,true) = noone
{
GapAhead1 = true
} else {
GapAhead1 = false
}

if collision_point(GapPointXM,GapPointYM,mHeadParent,true,true) = noone {
GapAhead2 = true
} else {
GapAhead2 = false
}

if collision_point(GapPointXR,GapPointYR,mHeadParent,true,true) = noone {
GapAhead3 = true
} else {
GapAhead3 = false
}

CollidingTaboo = instance_place(x + hspeed,y + vspeed,mTabooLayerParent)
CollidingWall = instance_place(x + hspeed,y + vspeed,mCollisionParent)
CollidingWound = instance_place(x + hspeed,y + vspeed,mWoundParent)
CollidingMole = instance_place(x + hspeed,y + vspeed, oMoleHerd)

//Temperature Sensing

if mWorldController.CurrentTemp &lt; 10 {
TempSpeedMod = -0.35
LonelyMod = 2
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
TempSpeedMod = 0
LonelyMod = 1
} else {
TempSpeedMod = 0.35
LonelyMod = 1
}

//Viewport Speed Mod

if mInterfaceController.CurrentView = "Macro" {
ViewSpeedMod = 0.07
} else if mInterfaceController.CurrentView = "Micro" {
ViewSpeedMod = 1
}

//Always note where the nearest POI is.

NearestMole = instance_nth_nearest(oMoleHerd,x,y,2)
NearestFur = instance_nearest(x,y,mFurParent)
NearestWound = instance_nearest(x,y,mWoundParent)


//As long as has energy, detect whether a certain POI is within 
//the sense radius, and update memory of where the last-seen POI is.

if distance_to_object(NearestMole) &lt;= SenseRadius {
SensedMole = true
LastRememberedMole = NearestMole
} else {
SensedMole = false
}

if distance_to_object(NearestFur) &lt;= SenseRadius {
SensedFur = true
LastRememberedFur = NearestFur
} else {
SensedFur = false
}

if instance_exists(mWoundParent) {
if distance_to_object(NearestWound) &lt;= SenseRadius {
SensedWound = true 
LastRememberedWound = NearestWound
} else {
SensedWound = false
}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Growing Over Time

switch mWorldController.CurrentTOD {
case "Morning":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Afternoon":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Night":
LonelyDayMod = 3
SenseRadius = 30
break;
}

if mWorldController.CurrentTemp &lt; 10 {
GrowMod = 0.5
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
GrowMod = 1
} else {
GrowMod = 1.5
}

if GrownToSize = true {
if image_xscale &lt; GrowMax {
if State != "eating" {
BaseXScale += GrowRate * GrowMod
BaseYScale += GrowRate * GrowMod
} else {
BaseXScale += EatingGrowRate * GrowMod
BaseYScale += EatingGrowRate * GrowMod
}
}
}

ZOutScale = BaseXScale * 5













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drives
/*
if GrownToSize = true {

if Activated = true {

if State = "grazing" {
HungerChangeMod = 1
EnergySpeedMod = 1
} else if State = "wandering" {
HungerChangeMod = 1.1
EnergySpeedMod = 1.1
} else if State =  "fleeing" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
} else if State = "clustering" {
HungerChangeMod = 0.5
EnergySpeedMod = 0
} else if State = "following" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
}

//Normal Actions (Night or Zoomed-Out Day)

//Hunger

//Hunger goes up at all times, apart from when eating, when it goes down.

if State != "eating" and State != "clustering" {
Hunger += mPlotController.HungerChangeRate * HungerChangeMod
} else if State = "eating" {
Hunger -= mPlotController.HungerChangeRate * 4
}

//Loneliness 

//Loneliness goes up when away from others, down when near to others.

if State != "clustering" {
if SensedMole = false {
Loneliness += (mPlotController.LonelyChangeRate * LonelyDayMod) * LonelyMod
} else {
Loneliness -= (mPlotController.LonelyChangeRate * 10) * LonelyDayMod
}
}

//Fear

//When fleeing, count down the flee timer - if it reaches zero, reset and go back to grazing.

if State = "fleeing" {
if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &gt;= SenseRadius / 4 {
if FleeTimer &gt; 0 {
FleeTimer -= 1
} else if FleeTimer &lt;= 0 {
if Contaged = true {
ContagTimer = 500
}
FleeTimer = 0
DesiredSpeed = 0
SpeedChangeRate = 0.01
ShiverOrNot = choose(-1,1)
if ShiverOrNot = 1 {
State = "shivering"
ShiverTimer = random_range(100,400) * (GrowMax * 5)
} else {
SourceOfFear = noone
GrazeX = x
GrazeY = y
State = "grazing"
}
}
}
}
}

//The timeout to stop emotional contagion triggering constantly, leading to panic stasis in a crowd.
if ContagTimer &gt; 0 {
ContagTimer -= 1
}

//Clustering
//If in range of a clusterer, and not clustering, begin clustering, and set that clusterer as your parent.

if State != "clustering" {
if SensedMole = true {
with oMoleHerd {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius {
if SeedClusterer = true {
if other.OriginalXScale &lt;= OriginalXScale {
if CurrentChildren &lt; MaxChildren {
other.State = "clustering"
CurrentChildren += 1
other.ClusterStopped = false
other.ClusterParent = id
other.CVal = irandom_range(ClusterRadius - 2, ClusterRadius + 2)
other.ClusterPointX = x + lengthdir_x(other.CVal,random(360))
other.ClusterPointY = y + lengthdir_y(other.CVal,random(360))
}
}
}
}
}
}
}

//--------------------------------------

//Action Plan

//Running if a nearby mole is scared (Emotional Contagion)
if NearestMole != noone {
if SensedMole = true {
if ContagTimer &lt;= 0 {
if NearestMole.State = "fleeing" and NearestMole.FleeTimer &gt; 20 and State != "fleeing" {
SourceOfFear = NearestMole
State = "fleeing"
Pausing = false
Contaged = true
FleeTimer = irandom_range(40,80)
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
DesiredHeading = point_direction(NearestMole.x,NearestMole.y,x,y) + (random_range(-30,30))
CurrentHeading = DesiredHeading
}
}
}
}

//If the nearest wound is new (i.e. not of the latest interest), move
//towards it to investigate, then disregard it.

if instance_exists(oWound) or instance_exists(oStabWound) {
if SensedWound = true {
if WoundOfInterest != NearestWound {
if State = "grazing" or (State = "wandering" and CurrentlyHunting != "food") {
if point_distance(x,y,NearestWound.x,NearestWound.y) &gt; (sprite_width / 2) + 30 {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)
if State = "grazing" {
CurrentHeading = DesiredHeading
}
} else {
WoundOfInterest = NearestWound
}
}
}
}
}

//Attracted Areas - if grazing or wandering, and the parent object is in range,
//set this as a new graze point or wander point.
if State = "grazing" or State = "wandering" {
if instance_exists(mFavouredParent) {
ClosestFavour = instance_nearest(x,y,mFavouredParent)
if point_distance(x,y,ClosestFavour.x,ClosestFavour.y) &lt;= (SenseRadius + (ClosestFavour.sprite_width / 2)) {
if State = "grazing" {
GrazeX = ClosestFavour.x
GrazeY = ClosestFavour.y
} else if State = "wandering" {
WanderStartX = ClosestFavour.x
WanderStartY = ClosestFavour.y
}
}
}
}

//Taboo Areas - if clustering and seed, if fleeing/grazing or wandering, and parent object is in range,
//move directly away from it until out of sight.

if State = "grazing" or State = "wandering" or (State = "clustering" and SeedClusterer = true) or State = "fleeing" {
if instance_exists(mTabooParent) {
ClosestTaboo = instance_nearest(x,y,mTabooParent)
if point_distance(x,y,ClosestTaboo.x,ClosestTaboo.y) &lt;= (SenseRadius + (ClosestTaboo.sprite_width / 2)) {
Pausing = false
DesiredHeading = point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
GrazeY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
WanderY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
}

//Run if come into contact with player scent.

ScentInContact = instance_place(x,y,mScentMarker)
if ScentInContact and State != "clustering" {
SourceOfFear = ScentInContact
State = "fleeing"
Pausing = false
Contaged = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = irandom_range(120,180)
}


//Begin wandering if hungry or lonely (hunger wins).
if State != "fleeing" and State != "clustering" and State != "eating" and State != "shivering" and State != "following" {

if Hunger &gt;= HungerLatch {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering"
CurrentlyHunting = "food" 
if LastRememberedWound != noone and instance_exists(LastRememberedWound) {
DesiredHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}

if Loneliness &gt;= LonelinessLatch and SensedMole = false {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering" 
CurrentlyHunting = "moles"
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
DesiredHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}
}

//In Day And Zoomed In
} else {

if State = "fleeing" {
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(100,400)
}

ScentInContact = instance_place(x,y,mScentMarker)
if ScentInContact and State != "clustering" {
State = "shivering"
ShiverTimer = random_range(100,400)
}

//Shiver when come into shot, but otherwise stay still.

if (instance_exists(self) and PlayerViewOverObject(self) and VibeReady = true) or (mInterfaceController.CurrentView = "MicroView"
and VibeReady = true) {
State = "shivering"
ShiverTimer = random_range(100,400)
VibeReady = false
}

if (instance_exists(self) and PlayerViewOverObject(self) = false)
or ((mInterfaceController.ChangingView = true or mInterfaceController.CurrentView = "MacroView"))
and VibeReady = false
{ 
VibeReady = true
}



hspeed = 0
vspeed = 0

}
}




Hunger = clamp(Hunger,0,100)
Loneliness = clamp(Loneliness,0,100)
FleeTimer = clamp(FleeTimer,0,700)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Behaviours
/*
///Top Speed Affected By Current Energy Level
SpeedMod = 1 * ViewSpeedMod

if GrownToSize = true {

//Make sure that seed clustering is reset if, for any reason, the state changes.
if State != "clustering" {
if SeedClusterer = true {
SeedClusterer = false 
ClusterTimer = 8000
}
}

//As long as we are alive, do these behaviours.
if Activated = true {

// FLEEING ---------------------------------------------------------------------
if State = "fleeing" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius / 2.5 {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.01

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}

// GRAZING ---------------------------------------------------------------------
} else if State = "grazing" {

DesiredSpeed = GrazingSpeed * SpeedMod
DirectionChangeRate = 1
SpeedChangeRate = 0.003


//Wander in a direction, pause, then change direction.
if Pausing = false {
if GrazeTimer &gt; 0 {
GrazeTimer -= 1 
} else if GrazeTimer &lt;= 0 {
CallOrNot = choose(-1,1)
Called = false
CallWaitTimer = random_range(40,80)
Pausing = true
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
GrazeTimer = 0
}
} else if Pausing = true {
if GrazePauseTimer &gt; 0 {
GrazePauseTimer -= 1
} else if GrazePauseTimer &lt;= 0 {
Pausing = false
GrazeTimer = random_range(GrazeTLower,GrazeTUpper)
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}

//If reach the current graze boundary, turn back.
if SensedMole = false {
if point_distance(x,y,GrazeX,GrazeY) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
} else {
if point_distance(NearestMole.x,NearestMole.y,x,y) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
}

// WANDERING --------------------------------------------------------------------
} else if State = "wandering" {

DirectionChangeRate = 1
SpeedChangeRate = 0.008

if SensedMole = false {
if Pausing = false {
if WanderTimer &gt; 0 {
WanderTimer -= 1
} else if WanderTimer &lt;= 0 {
if CurrentlyHunting = "moles" {
CallOrNot = choose(-1,1)
} else {
CallOrNot = -1
}
Called = false
CallWaitTimer = random_range(40,80)
WanderPauseTimer = random_range(WanderPTLower,WanderPTUpper)
Pausing = true 
}
} else if Pausing = true {
if WanderPauseTimer &gt; 0 {
WanderPauseTimer -= 1
} else if WanderPauseTimer &lt;= 0 {
WanderTimer = random_range(WanderTLower,WanderTUpper)
Pausing = false
}
}
} else {
Pausing = false
}

if CurrentlyHunting = "food" {
DesiredSpeed = WanderSpeed * SpeedMod
} else if CurrentlyHunting = "moles" {
DesiredSpeed = WanderSpeed * SpeedMod
} else {
DesiredSpeed = WanderSpeed * SpeedMod
}


if Loneliness &lt; 70 {
WanderRadius = BaseWanderRadius
} else {
WanderRadius = BaseWanderRadius / 2
}



//Reset Flocking Variables
AlignVar = 0
CohVar = 0
SepVar = 0
Neighbours = 0

if CollidingWall = noone and CollisionAhead1 = noone and CollisionAhead2 = noone and CollisionAhead3 = noone and TabooArea = false
and GapAhead1 = false and GapAhead2 = false and GapAhead3 = false
{
with oMoleHerd {
//Alignment Calculation
NDistance = point_distance(other.x,other.y,x,y)
if (id != other.id) and (NDistance &lt;= other.SenseRadius) { 
other.AlignVar += CurrentHeading
other.CohVar += point_direction(other.x,other.y,x,y)
other.SepVar += point_direction(x,y,other.x,other.y)
other.Neighbours += 1
}
}

if CurrentlyHunting = "food" {
if LastRememberedWound != noone and instance_exists(LastRememberedWound){
HuntingHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
HuntingHeading = CurrentHeading
}
} else if CurrentlyHunting = "moles" {
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
HuntingHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
HuntingHeading = CurrentHeading
}
} else {
HuntingHeading = CurrentHeading
}

//Desired Heading With Flocking (Ignore Search)
if Neighbours &gt; 0 {
AverageHeading = ((AlignVar / Neighbours) + (CohVar / Neighbours) + (SepVar / Neighbours))  / 3
DesiredHeading = AverageHeading //+ irandom_range(((WanderRange / 2) * -1),(WanderRange / 2))
DirectionChangeRate = 5
//Desired Heading Without Flocking (Active Search)
} else if Neighbours &lt;= 0 {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
WanderModLower = HuntingHeading - (WanderRange / 2)
WanderModHigher = HuntingHeading + (WanderRange / 2)
DesiredHeading = irandom_range(WanderModLower,WanderModHigher)
}
}
}

//Seek Thing And Arrive If In Sense Radius
if CurrentlyHunting = "food" {
if SensedWound = true {
DirectionChangeRate = 5
if instance_exists(NearestWound) {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)

DesiredSpeed = WanderSpeed //* 3) * ((distance_to_object(NearestWound) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if distance_to_object(NearestWound) &lt;= 1 {
DesiredSpeed = 0
CurrentSpeed = 0
State = "eating"
}
}
}


} else if CurrentlyHunting = "moles" {
if SensedMole = true {
DirectionChangeRate = 5
if instance_exists(NearestMole) {
DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)

DesiredSpeed = ((WanderSpeed * 3) * ((distance_to_object(NearestMole) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if instance_exists(NearestMole) 
and point_distance(x,y,NearestMole.x,NearestMole.y) &lt;= MoleProx {
GrazeX = x
GrazeY = y
DesiredSpeed = 0
CurrentSpeed = 0
Loneliness = 0
State = "grazing"
}
}
}
}

//Turn Back If Outside Wander Radius
if point_distance(x,y,WanderStartX,WanderStartY) &gt; WanderRadius {
CurrentHeading = point_direction(x,y,WanderStartX,WanderStartY)
}



// EATING -----------------------------------------------------------------------

} else if State = "eating" {

DesiredSpeed = 0
SpeedChangeRate = 0.01

//If sated, stop eating and 'detach'.
if Hunger &lt;= 0 or instance_exists(NearestWound) = false {
if place_meeting(x,y,NearestWound) {
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.001
DesiredHeading = point_direction(NearestWound.x,NearestWound.y,x,y)
CurrentHeading = DesiredHeading
} else {
State = "grazing"
GrazeX = x
GrazeY = y
if instance_exists(NearestWound) {
CurrentDirection = point_direction(NearestWound.x,NearestWound.y,x,y)
} else {
CurrentDirection = random(360)
}
}
} else {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}

// CLUSTERING ----------------------------------------------------------------------

} else if State = "clustering" {

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

//If Seed Clusterer, Count Down ClusterTimer. If it runs out, reset and begin grazing.

if SeedClusterer = true {
if DoNotClusterHere = false {
DesiredSpeed = 0
SpeedChangeRate = 0.001
if ClusterTimer &gt; 0 {
ClusterTimer -= 1
} else if ClusterTimer &lt;= 0 {
GrazeX = x
GrazeY = y
State = "grazing"
SeedClusterer = false
ClusterTimer = 8000
mPlotController.Clusters -= 1
CurrentChildren = 0
}


if BabyTimer &gt; 0 {
BabyTimer -= 1
} else if BabyTimer &lt;= 0 {
PointX = x + lengthdir_x(random_range(10,20),random(360))
PointY = y + lengthdir_y(random_range(10,20),random(360))
ThisBaby = instance_create(PointX,PointY,oMoleHerd)

with ThisBaby {
ZoomedInSprite = other.ZoomedInSprite
Bottom = other.Bottom
Red = other.Red
OriginalXScale = other.OriginalXScale / 1.8
OriginalYScale = other.OriginalXScale / 1.8
image_xscale = OriginalXScale
image_yscale = 0
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
ZOutScale = OriginalXScale * 5
GrowMax = OriginalXScale + 0.2
State = "clustering"
ClusterPointX = x
ClusterPointY = y
ClusterParent = other.id
}
BabyTimer = random_range(BabyCreateLower,BabyCreateHigher)
}
}

} else if SeedClusterer = false {
//Stop clustering as soon as Parent stops.
if ClusterParent.State != "clustering" {
State = ClusterParent.State
ClusterParent = noone
CurrentChildren = 0
GrazeX = x
GrazeY = y
WanderX = x
WanderY = y
}

//Change Cluster Point If Not Legal

if position_meeting(ClusterPointX,ClusterPointY,mCollisionParent) {
ClusterPointX = ClusterParent.x + lengthdir_x(random_range(5, ClusterParent.ClusterRadius),random(360))
ClusterPointY = ClusterParent.y + lengthdir_y(random_range(5, ClusterParent.ClusterRadius),random(360))
}

if x &gt; ClusterPointX - 1 and x &lt; ClusterPointX + 1
and y &gt; ClusterPointY - 1 and y &lt; ClusterPointY + 1 {
DesiredSpeed = 0
CurrentSpeed = 0
} else {
DesiredHeading = point_direction(x,y,ClusterPointX,ClusterPointY)
CurrentHeading = DesiredHeading
DesiredSpeed = GrazingSpeed * SpeedMod
}

}



}
}

// SHIVERING -----------------------------------------------------------------------------

if State = "shivering" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.02
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}



if ShiverTimer &gt; 0 {
ShiverTimer -= 1


} else if ShiverTimer &lt;= 0 {
ShiverTimer = 0
ShiverOrNot = 0
XOffset = 0
State = "grazing"
GrazeX = x
GrazeY = y
SourceOfFear = noone
}

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

}

}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Staying On Body &amp; Collision

///Then, Collision Avoidance &amp; Separation

//Set Current Depth Depending On Nearby Moles
HighestColliderY = 0
HighestCollider = noone

with (oMoleHerd) {
if place_meeting(x,y,other) {
if y &gt; other.HighestColliderY {
other.HighestCollider = id
other.HighestColliderY = y
}
}
}

if HighestCollider != noone {
if HighestColliderY &gt; y {
depth = HighestCollider.depth + 0.0001
} else {
depth = OriginalDepth
}
} else {
depth = OriginalDepth
}




if Activated = true {
if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

//-------------------------TABOOS

if TabooLayer1Blocking = true {
if TabooLayer1Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead1.x,TabooLayer1Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer1Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead2.x,TabooLayer1Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer1Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead3.x,TabooLayer1Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}
}

//--------------------------------------------


if TabooLayer2Blocking = true {
if TabooLayer2Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead1.x,TabooLayer2Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer2Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead2.x,TabooLayer2Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer2Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead3.x,TabooLayer2Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}
}

//--------------------------------------------


if TabooLayer3Blocking = true {
if TabooLayer3Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead1.x,TabooLayer3Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer3Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead2.x,TabooLayer3Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if TabooLayer3Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead3.x,TabooLayer3Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}
}

//--------------------------------------------




if State = "fleeing" or State = "clustering" or State = "following" or
(State = "wandering" and CurrentlyHunting = "moles")
or (State = "grazing" and SensedWound = true and WoundOfInterest = NearestWound)
{

if WoundAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead1.x,WoundAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead2.x,WoundAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead3.x,WoundAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollidingWound {
DistX = sign (x - CollidingWound.x)
DistY = sign(y - CollidingWound.y)
x += DistX
y += DistY
}

}

//Colliding 

if CollidingWall {
DistX = sign(x - CollidingWall.x)
DistY = sign(y - CollidingWall.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}

if CollidingTaboo {
DistX = sign(x - CollidingTaboo.x)
DistY = sign(y - CollidingTaboo.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingTaboo.x,CollidingTaboo.y,x,y)
DirectionChangeRate = 5
}


//Avoiding Edge Of Room
if GapAhead1 = true or GapAhead3 = true or GapAhead2 = true {
if GapAhead3 = true {
DesiredHeading = (CurrentHeading - 30)
} else if GapAhead1 = true {
DesiredHeading = (CurrentHeading + 30)
} else if GapAhead2 = true {
DesiredHeading = (CurrentHeading - 30)
}
}

//Clamping To Body
if place_meeting(x,y,oHead1) {
x = clamp(x,oHead1.x - (oHead1.sprite_width / 2),oHead1.x + (oHead1.sprite_width / 2))
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oHead1.y + (oHead1.sprite_height / 2))
} else if place_meeting(x,y,oHead2) {
x = clamp(x,oHead2.x - (oHead2.sprite_width / 2),oHead2.x + (oHead2.sprite_width / 2))
y = clamp(y,oHead2.y - (oHead2.sprite_height / 2),oHead2.y + (oHead2.sprite_height / 2))
} else if place_meeting(x,y,oHead3) {
x = clamp(x,oHead3.x - (oHead3.sprite_width / 2),oHead3.x + (oHead3.sprite_width / 2))
y = clamp(y,oHead3.y - (oHead3.sprite_height / 2),oHead3.y + (oHead3.sprite_height / 2))
}






}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Coming To Desired Speed And Direction

if GrownToSize = true {

//Speed

if Pausing = false and Activated = true {
if CurrentSpeed != DesiredSpeed {
if CurrentSpeed &lt; DesiredSpeed {
CurrentSpeed += SpeedChangeRate
} else if CurrentSpeed &gt; DesiredSpeed {
CurrentSpeed -= SpeedChangeRate
}
}
hspeed = CurrentSpeed
vspeed = CurrentSpeed
} else {
hspeed = 0
vspeed = 0
}



//Direction

if CurrentHeading != DesiredHeading {
if DesiredHeading &gt; CurrentHeading + DitherMod {
CurrentHeading += DirectionChangeRate
} else if DesiredHeading &lt; CurrentHeading - DitherMod {
CurrentHeading -= DirectionChangeRate
}
} 

direction = CurrentHeading

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing Sprite Depending On View
if Occupied = true {
ChangeDrawingWithZoom(ZoomedOutSprite,ZoomedInSprite,UnoccupiedRotation)
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
