<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sSigilMoleSmall1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>mMoleParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

OriginalX = x
OriginalY = y
Status = "whole"
ZoomedOutSprite = sMoleSmallRed
ZoomedOutDirection = random(360)
direction = 0
Chosen = false
Size = "large"

image_xscale = 0.6
image_yscale = image_xscale
depth = OnObjectsLayer + 0.002
OriginalDepth = depth
CheekDepth = oCheekLeft.depth - 0.002
ZoomedInSprite = sRedMole

GeneralGrazeTimer = 5000
GeneralWanderTimer = 0
DetergeantTimer = 0
DetergeantMod = 0

LightRadLower = mInterfaceController.LightRadBase - 0.2
LightRadUpper = mInterfaceController.LightRadBase + 0.2
LightRad = LightRadUpper
Difference = 0

ZoomedOutXScale = 0
ZoomedOutXScaleTarget = image_xscale
ZoomedOutYScale = 0
ZoomedOutYScaleTarget = ZoomedOutXScaleTarget
ZoomedInScale = 0
ZoomedInScaleTarget = image_xscale / 4
OriginalDepth = depth
VibeReady = true
DebugText = false

OriginalXScale = image_xscale
OriginalYScale = image_xscale
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale

ZoomedInDirection = 0
UnoccupiedRotation = random(360)
Redness = 0
Occupied = true
ID = 0
ChangeMultiplier = 0
XDir = 0

CutAmount = 0
Cutting = false

Ripped = false
DripTimer = irandom_range(30,120)

XDifference = 0
YDifference = 0
UpAmount = 60
BaseRedness = 0

GrownToSize = false

SpriteIndexOutXScale = 0
SpriteIndexOutYScale = 0
SpriteIndexOutAlpha = 0
SpriteIndexInAlpha = 0
SpriteIndexInXScale = 0
SpriteIndexInYScale = 0

PathCalculate = false

Activated = true

ChangeSpriteWithZoom(ZoomedOutXScale,ZoomedOutYScale,ZoomedInScale,ZoomedInScale)

//-----------------------------------------
//Senses

SenseRadius = 600
ClusterRadius = 100
MaxChildren = round(100 * OriginalXScale)
CurrentChildren = 0
BabyCreateLower = 2000 * OriginalXScale
BabyCreateHigher = 4000 * OriginalXScale
BabyTimer = 0
SensedMole = false
LastRememberedMole = noone
NearestMole = noone
SensedFur = false
LastRememberedFur = noone
NearestFur = noone
SensedWound = false
LastRememberedWound = noone
WoundOfInterest = noone
NearestWound = noone
GapAhead1 = false
GapAhead2 = false
GapAhead3 = false
WoundAhead1 = false
WoundAhead2 = false
WoundAhead3 = false 
CollidingWound = false
CollidingWall = false
ClosestSigil = noone

//Growing

GrowMax = OriginalXScale + 0.05
GrowRate = random_range(0.000002,0.000003)
OriginalGrowRate = GrowRate
EatingGrowRate = GrowRate * 1.5

//Drives &amp; States

State = "grazing"

Hunger = 0
HungerChangeMod = 1
HungerLatch = 40
Loneliness = 0
LonelinessLatch = 40
FleeTimer = 0
TempSpeedMod = 0
TabooArea = false
FavouredArea = false
Activating = false
WakingUp = true
WakingTimer = 0

//Behaviours

GrazingSpeed = 10 / room_speed
GrazeX = x
GrazeY = y
GrazeRadius = 100
Pausing = false
GrazeTimer = 60
GrazePauseTimer = 300
GrazePTLower = 150 
GrazePTUpper = 400
GrazeTLower = 200
GrazeTUpper = 500 

WanderSpeed = 30 / room_speed
WanderRange = 200
WanderRadius = 700
BaseWanderRadius = 700
WanderStartX = x
WanderStartY = y
DitherMod = 2
AlignVar = 0
SepVar = 0
Neighbours = 0
CurrentlyHunting = "food"
MoleProx = 60
WoundProx = sprite_width * 2
WanderTimer = 300
WanderPauseTimer = 100
WanderPTLower = 60 
WanderPTUpper = 180
WanderTLower = 2000
WanderTUpper = 3000
CallOrNot = 0
Called = false

FleeSpeed = 60 / room_speed
SourceOfFear = noone
ContagTimer = 0
Contaged = false
FleeModRange = 50
GoneOffScreen = false

ShiverTimer = 0
ShiverDirection = "left"
ShiverOrNot = 0
XOffset = 0

ViewSpeedMod = 0
SpeedMod = 1
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.5
DesiredHeading = random(360)
DirectionChangeRate = 1
Slowdown = 0.5

//Collision

CollisionLength = 50
GapLength = 25
CollisionWidth = 35
CollisionAhead1 = noone
CollisionAhead2 = noone
CollisionAhead3 = noone
Turning = false
ColPointXM = 0
ColPointYM = 0
ColPointXL = 0
ColPointYL = 0
ColPointXR = 0
ColPointYR = 0


TabooLayer3Ahead1 = noone
TabooLayer3Ahead2 = noone
TabooLayer3Ahead3 = noone
TabooLayer3Blocking = true

TabooLayer1Ahead1 = noone
TabooLayer2Ahead2 = noone
TabooLayer1Ahead3 = noone
TabooLayer1Blocking = true

TabooLayer2Ahead1 = noone
TabooLayer2Ahead2 = noone
TabooLayer2Ahead3 = noone
TabooLayer2Blocking = true

Goal = "none"

//Initialise!
CurrentSpeed = DesiredSpeed
CurrentHeading = DesiredHeading
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Grow To Size

if GrownToSize = false {

if ZoomedOutXScale &lt; ZoomedOutXScaleTarget {
ZoomedOutXScale += 0.001
ZoomedOutYScale = ZoomedOutXScale
}
if ZoomedInScale &lt; ZoomedInScaleTarget {
ZoomedInScale += 0.02
}
}

if ZoomedOutXScale &gt;= ZoomedOutXScaleTarget
and ZoomedInScale &gt;= ZoomedInScaleTarget {
GrownToSize = true
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Limits &amp; Activations

ChangeSpriteWithZoom(ZoomedOutXScale,ZoomedOutYScale,ZoomedInScale,ZoomedInScale)

Redness = BaseRedness + ((0.5 / 100) * mDriveCollectionMaster.RitualTolerance)
BaseRedness = clamp(BaseRedness,0,0.5)

if Occupied = true {
sprite_index = ZoomedInSprite
image_xscale = ZoomedInScale
image_yscale = ZoomedInScale
} else if Occupied = false {
if mInterfaceController.CurrentView = MicroView {
sprite_index = sSigilMoleBottom
image_xscale = ZoomedInScale - 0.2 
image_yscale = ZoomedInScale - 0.2 
}
}

///Creating 'Flicker'

Difference = choose(0.1,-0.1,0)
LightRad += Difference
LightRad = clamp(LightRad,LightRadLower,LightRadUpper)


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make A Trail If Moving

if (speed &gt; 0 or State = "clustering" or State = "eating") and (mInterfaceController.CurrentView = "Micro" and Activated = true) {
CreateParticleSplash(x,y,10,ps_shape_ellipse,ps_distr_gaussian,c_black,0.003,0.005,0.02,0.05,0,180,60,100,0,30)
CreateStain(10,direction - 210,direction - 150,0.000001,0.000002,0.003,1,30,0.0001,0.0007,c_black,x,y)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cutting Out

CutAmount = clamp(CutAmount,0,100)

//Cutting Begin

if instance_exists(mFinger) {
if (place_meeting(x,y,mFinger)
and instance_exists(mDebug) = false
and mInterfaceController.CurrentHandUse = "knife"
and mInterfaceController.CurrentView = MicroView
and Occupied = true)
or (place_meeting(x,y,mWoundParent))
{
CreateParticleSplash(x,y,3,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,5,15,0.04,0.07,0,360,70,125,0.5,30)
CreateStain(10,0,360,5,10,0.2,0.3,0.5,0.05,0.06,BloodLiquidColour,x,y)
WriteToLog("Cut out normal mole.")
Occupied = false
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
Cutting = false
instance_destroy()
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Touching

if place_meeting(x,y,mFinger) and  mInterfaceController.CurrentView = MicroView and instance_exists(mDebug) = false{
TouchMoleReactions()
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Senses &amp; Memory


//Collision Sensing

ColPointXM = x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = y + lengthdir_y(CollisionLength,CurrentHeading)
ColPointXL = x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)
ColPointXR = x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

GapPointXM = x + lengthdir_x(GapLength,CurrentHeading)
GapPointYM = y + lengthdir_y(GapLength,CurrentHeading)
GapPointXL = x + lengthdir_x(GapLength,CurrentHeading - CollisionWidth)
GapPointYL = y + lengthdir_y(GapLength,CurrentHeading - CollisionWidth)
GapPointXR = x + lengthdir_x(GapLength,CurrentHeading + CollisionWidth)
GapPointYR = y + lengthdir_y(GapLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mCollisionParent,true,true)
CollisionAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mCollisionParent,true,true)
CollisionAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mCollisionParent,true,true)

if oTabooLayer1.Health &gt; 0 {
TabooLayer1Blocking= true
TabooLayer1Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer1,true,true)
TabooLayer1Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer1,true,true)
TabooLayer1Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer1,true,true)
} else {
TabooLayer1Blocking = false
}

if oTabooLayer2.Health &gt; 0 {
TabooLayer2Blocking= true
TabooLayer2Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer2,true,true)
TabooLayer2Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer2,true,true)
TabooLayer2Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer2,true,true)
} else {
TabooLayer2Blocking = false
}

if oTabooLayer3.Health &gt; 0 {
TabooLayer3Blocking = true
TabooLayer3Ahead1 = collision_line(x,y,ColPointXM,ColPointYM,oTabooLayer3,true,true)
TabooLayer3Ahead2 = collision_line(x,y,ColPointXL,ColPointYL,oTabooLayer3,true,true)
TabooLayer3Ahead3 = collision_line(x,y,ColPointXR,ColPointYR,oTabooLayer3,true,true)
} else {
TabooLayer3Blocking = false
}

WoundAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mWoundParent,true,true)
WoundAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mWoundParent,true,true)
WoundAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mWoundParent,true,true)

if collision_point(GapPointXL,GapPointYL,mHeadParent,true,true) = noone
{
GapAhead1 = true
} else {
GapAhead1 = false
}

if collision_point(GapPointXM,GapPointYM,mHeadParent,true,true) = noone {
GapAhead2 = true
} else {
GapAhead2 = false
}

if collision_point(GapPointXR,GapPointYR,mHeadParent,true,true) = noone {
GapAhead3 = true
} else {
GapAhead3 = false
}

CollidingTaboo = instance_place(x + hspeed,y + vspeed,mTabooLayerParent)
CollidingWall = instance_place(x + hspeed,y + vspeed,mCollisionParent)
CollidingWound = instance_place(x + hspeed,y + vspeed,mWoundParent)
CollidingMole = instance_place(x + hspeed,y + vspeed, oMoleHerd)

//Temperature Sensing

if mWorldController.CurrentTemp &lt; 10 {
TempSpeedMod = -0.35
LonelyMod = 2
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
TempSpeedMod = 0
LonelyMod = 1
} else {
TempSpeedMod = 0.35
LonelyMod = 1
}

//Viewport Speed Mod

if mInterfaceController.CurrentView = "Macro" {
ViewSpeedMod = 0.05
} else if mInterfaceController.CurrentView = "Micro" {
ViewSpeedMod = 1
}

//Always note where the nearest POI is.

NearestMole = instance_nth_nearest(oMoleHerd,x,y,2)
NearestFur = instance_nearest(x,y,mFurParent)
NearestWound = instance_nearest(x,y,mWoundParent)
ClosestSigil = instance_nearest(x,y,sSigilMoleParent)


//As long as has energy, detect whether a certain POI is within 
//the sense radius, and update memory of where the last-seen POI is.

if distance_to_object(NearestMole) &lt;= SenseRadius {
SensedMole = true
LastRememberedMole = NearestMole
} else {
SensedMole = false
}

if distance_to_object(NearestFur) &lt;= SenseRadius {
SensedFur = true
LastRememberedFur = NearestFur
} else {
SensedFur = false
}

if instance_exists(mWoundParent) {
if distance_to_object(NearestWound) &lt;= SenseRadius {
SensedWound = true 
LastRememberedWound = NearestWound
} else {
SensedWound = false
}
}

MoleDetergeant()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Growing Over Time

switch mWorldController.CurrentTOD {
case "Morning":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Afternoon":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Night":
LonelyDayMod = 3
SenseRadius = 30
break;
}

if mWorldController.CurrentTemp &lt; 10 {
GrowMod = 0.5
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
GrowMod = 1
} else {
GrowMod = 1.5
}

if GrownToSize = true {
if image_xscale &lt; GrowMax {
if State != "eating" {
BaseXScale += GrowRate * GrowMod
BaseYScale += GrowRate * GrowMod
} else {
BaseXScale += EatingGrowRate * GrowMod
BaseYScale += EatingGrowRate * GrowMod
}
}
}

ZOutScale = BaseXScale * 5













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setting Depth For Going Over Things

if place_meeting(x,y,oCheekLeft) or place_meeting(x,y,oCheekRight) {
depth = CheekDepth
} else {
depth = OriginalDepth
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Behaviours

///Top Speed Affected By Current Energy Level
SpeedMod = 1 * ViewSpeedMod

if GrownToSize = true {
if mDriveCollectionMaster.MSTimer &lt;= 0 and Chosen = false{


//As long as we are alive, do these behaviours.
if Activated = true {

// FLEEING ---------------------------------------------------------------------
if State = "fleeing" {
PathCalculate = false
if instance_exists(SourceOfFear) {
if distance_to_object(SourceOfFear) &lt;= SenseRadius / 2.5 {
DesiredSpeed = (FleeSpeed * SpeedMod)- (((40 / room_speed) / 100) * DetergeantMod)
DirectionChangeRate = 5
SpeedChangeRate = 0.04
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = (FleeSpeed * SpeedMod)- (((40 / room_speed) / 100) * DetergeantMod)
DirectionChangeRate = 5
SpeedChangeRate = 0.01

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = (FleeSpeed * SpeedMod)- (((40 / room_speed) / 100) * DetergeantMod)
DirectionChangeRate = 5
SpeedChangeRate = 0.04

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}

// GRAZING ---------------------------------------------------------------------
} else if State = "grazing" {
PathCalculate = false
DesiredSpeed = (GrazingSpeed * SpeedMod)- (((5 / room_speed) / 100) * DetergeantMod)
DirectionChangeRate = 1
SpeedChangeRate = 0.003


//Wander in a direction, pause, then change direction.
if Pausing = false {
if GrazeTimer &gt; 0 {
GrazeTimer -= 1 
} else if GrazeTimer &lt;= 0 {
CallOrNot = choose(-1,1)
Called = false
CallWaitTimer = random_range(40,80)
Pausing = true
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
GrazeTimer = 0
}
} else if Pausing = true {
if GrazePauseTimer &gt; 0 {
GrazePauseTimer -= 1
} else if GrazePauseTimer &lt;= 0 {
Pausing = false
GrazeTimer = random_range(GrazeTLower,GrazeTUpper)
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}

//If reach the current graze boundary, turn back.
if SensedMole = false {
if point_distance(x,y,GrazeX,GrazeY) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
} else {
if point_distance(NearestMole.x,NearestMole.y,x,y) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
}

// WANDERING --------------------------------------------------------------------
} else if State = "wandering" {

DirectionChangeRate = 1
SpeedChangeRate = 0.008
WanderRadius = BaseWanderRadius
mp_potential_settings(90,90,5,true)

//Seek Thing And Arrive If In Sense Radius

//Byre
if CurrentlyHunting = "byre" {
if point_distance(x,y,oByre.x,oByre.y) &gt; 1 {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(oByre.x,oByre.y,CurrentSpeed,mCollisionParent)
} else {
DesiredSpeed = 0
CurrentSpeed = 0
PathCalculate = false
}
}

//Left Eye
else if CurrentlyHunting = "lefteye" {

if distance_to_object(mEyeLeftParent) &gt; 10 {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(oEyeballLeft.x,oEyeballLeft.y,CurrentSpeed,mCollisionParent)

} else {
DesiredSpeed = 0
CurrentSpeed = 0
PathCalculate = false
}
}

//Right Eye
else if CurrentlyHunting = "righteye" {
if distance_to_object(mEyeRightParent) &gt; 10 {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(oEyeballRight.x,oEyeballRight.y,CurrentSpeed,mCollisionParent)

} else {
DesiredSpeed = 0
CurrentSpeed = 0
PathCalculate = false
}
}

//Top
else if CurrentlyHunting = "top" {
if distance_to_object(oHornSocketRightFront) &gt; 50 and distance_to_object(oHornSocketLeftFront) &gt; 50 {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(oHornSocketRightFront.x,oHornSocketRightFront.y,CurrentSpeed,mCollisionParent)
} else {
State = "shivering"
ShiverTimer = random_range(3000,6000)
}
}

//West Woods
else if CurrentlyHunting = "westwoods" {

if (y &lt; 3525 or y &gt; 3888) or x &gt;= oHead2.x - 200 {

PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object((oHead2.x - oHead2.sprite_width / 2),3680,CurrentSpeed,mCollisionParent)
} else {
State = "grazing"
GrazeX = x
GrazeY = y
PathCalculate = false
}
}

//South Woods
else if CurrentlyHunting = "southwoods" {
if (x &lt; 600 or x &gt; 700) or (y &lt; 2600 or y &gt; 2800) {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(650,2700,CurrentSpeed,mCollisionParent)


} else {
State = "grazing"
GrazeX = x
GrazeY = y
PathCalculate = false
}
}


//Top Woods
else if CurrentlyHunting = "topwoods" {
if (y &lt; 690 or y &gt; 900) {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(677,754,CurrentSpeed,mCollisionParent)
} else {
State = "grazing"
GrazeX = x
GrazeY = y
PathCalculate = false
}
}

//Moles 
else if CurrentlyHunting = "moles" {
//Seek Moles, biased to Last Remembered Mole, until one is in sense radius.
if SensedMole = false {
if LastRememberedMole != noone and instance_exists(LastRememberedMole) {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(LastRememberedMole.x,LastRememberedMole.y,CurrentSpeed,mCollisionParent)
} else {
PathCalculate = false
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
DirectionChangeRate = 5
}
} else {
//When find a mole, get close to it.
if SensedMole = true {
PathCalculate = true 
DesiredSpeed = WanderSpeed - (((30 / room_speed) / 100) * DetergeantMod)
CurrentSpeed = DesiredSpeed * ViewSpeedMod
mp_potential_step_object(NearestMole.x,NearestMole.y,CurrentSpeed,mCollisionParent)
}
LastRememberedMole = noone
}
} else {
PathCalculate = false
}



// EATING -----------------------------------------------------------------------

} else if State = "eating" {
PathCalculate = false
DesiredSpeed = 0
SpeedChangeRate = 0.01

//If sated, stop eating and 'detach'.
if Hunger &lt;= 0 or instance_exists(NearestWound) = false {
if place_meeting(x,y,NearestWound) {
DesiredSpeed = Grazing - (((5 / room_speed) / 100) * DetergeantMod)
SpeedChangeRate = 0.001
DesiredHeading = point_direction(NearestWound.x,NearestWound.y,x,y)
CurrentHeading = DesiredHeading
} else {
State = "grazing"
GrazeX = x
GrazeY = y
if instance_exists(NearestWound) {
CurrentDirection = point_direction(NearestWound.x,NearestWound.y,x,y)
} else {
CurrentDirection = random(360)
}
}
} else {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}

// CLUSTERING ----------------------------------------------------------------------

} else if State = "clustering" {
PathCalculate = false
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

//If Seed Clusterer, Count Down ClusterTimer. If it runs out, reset and begin grazing.

if SeedClusterer = true {
if DoNotClusterHere = false {
DesiredSpeed = 0
SpeedChangeRate = 0.001
if ClusterTimer &gt; 0 {
ClusterTimer -= 1
} else if ClusterTimer &lt;= 0 {
GrazeX = x
GrazeY = y
State = "grazing"
SeedClusterer = false
ClusterTimer = 8000
mPlotController.Clusters -= 1
CurrentChildren = 0
}


if BabyTimer &gt; 0 {
BabyTimer -= 1
} else if BabyTimer &lt;= 0 {
PointX = x + lengthdir_x(random_range(10,20),random(360))
PointY = y + lengthdir_y(random_range(10,20),random(360))
ThisBaby = instance_create(PointX,PointY,oMoleHerd)

with ThisBaby {
ZoomedInSprite = other.ZoomedInSprite
Bottom = other.Bottom
Red = other.Red
OriginalXScale = other.OriginalXScale / 1.8
OriginalYScale = other.OriginalXScale / 1.8
image_xscale = OriginalXScale
image_yscale = 0
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
ZOutScale = OriginalXScale * 5
GrowMax = OriginalXScale + 0.2
State = "clustering"
ClusterPointX = x
ClusterPointY = y
ClusterParent = other.id
}
BabyTimer = random_range(BabyCreateLower,BabyCreateHigher)
}
}

} else if SeedClusterer = false {
//Stop clustering as soon as Parent stops.
if ClusterParent.State != "clustering" {
State = ClusterParent.State
ClusterParent = noone
CurrentChildren = 0
GrazeX = x
GrazeY = y
WanderX = x
WanderY = y
}

//Change Cluster Point If Not Legal

if position_meeting(ClusterPointX,ClusterPointY,mCollisionParent) {
ClusterPointX = ClusterParent.x + lengthdir_x(random_range(5, ClusterParent.ClusterRadius),random(360))
ClusterPointY = ClusterParent.y + lengthdir_y(random_range(5, ClusterParent.ClusterRadius),random(360))
}

if x &gt; ClusterPointX - 1 and x &lt; ClusterPointX + 1
and y &gt; ClusterPointY - 1 and y &lt; ClusterPointY + 1 {
DesiredSpeed = 0
CurrentSpeed = 0
} else {
DesiredHeading = point_direction(x,y,ClusterPointX,ClusterPointY)
CurrentHeading = DesiredHeading
DesiredSpeed = GrazingSpeed * SpeedMod
}

}



}
}

// SHIVERING -----------------------------------------------------------------------------

if State = "shivering" {
PathCalculate = false
if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed - (((40 / room_speed) / 100) * DetergeantMod)
DirectionChangeRate = 5
SpeedChangeRate = 0.02
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}



if ShiverTimer &gt; 0 {
ShiverTimer -= 1


} else if ShiverTimer &lt;= 0 {
ShiverTimer = 0
ShiverOrNot = 0
XOffset = 0
State = "grazing"
GrazeX = x
GrazeY = y
SourceOfFear = noone
}

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

}

}

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drives (Following A Schedule)

///Checking what we should be doing on each day, at each hour

if GrownToSize = true {
if mDriveCollectionMaster.MSTimer &lt;= 0 or Chosen = false {
if Activated = true {

//Fear

//When fleeing, count down the flee timer - if it reaches zero, reset and go back to grazing.

if State = "fleeing" {
if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &gt;= SenseRadius / 4 {
if FleeTimer &gt; 0 {
FleeTimer -= 1
} else if FleeTimer &lt;= 0 {
if Contaged = true {
ContagTimer = 500
}
FleeTimer = 0
DesiredSpeed = 0
SpeedChangeRate = 0.01
ShiverOrNot = choose(-1,1)
if ShiverOrNot = 1 {
State = "shivering"
ShiverTimer = random_range(100,400) * (GrowMax * 5)
} else {
SourceOfFear = noone
GrazeX = x
GrazeY = y
State = "grazing"
}
}
}
}
}

//The timeout to stop emotional contagion triggering constantly, leading to panic stasis in a crowd.
if ContagTimer &gt; 0 {
ContagTimer -= 1
}


//Taboo Areas - if clustering and seed, if fleeing/grazing or wandering, and parent object is in range,
//move directly away from it until out of sight.

if State = "grazing" or State = "wandering" or (State = "clustering" and SeedClusterer = true) or State = "fleeing" {

if instance_exists(sSigilMoleParent) {
if ClosestSigil != noone {
if point_distance(x,y,ClosestSigil.x,ClosestSigil.y) &lt;= (SenseRadius + (ClosestSigil.sprite_width / 2)) {
Pausing = false
DesiredHeading = point_direction(ClosestSigil.x,ClosestSigil.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestSigil.x + lengthdir_x(ClosestSigil.sprite_width / 2,point_direction(ClosestSigil.x,ClosestSigil.y,x,y))
GrazeY = ClosestSigil.y + lengthdir_y(ClosestSigil.sprite_width / 2,point_direction(ClosestSigil.x,ClosestSigil.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestSigil.x + lengthdir_x(ClosestSigil.sprite_width / 2,point_direction(ClosestSigil.x,ClosestSigil.y,x,y))
WanderY = ClosestSigil.y + lengthdir_y(ClosestSigil.sprite_width / 2,point_direction(ClosestSigil.x,ClosestSigil.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
}

if instance_exists(mCollisionParent) {
ClosestCollision = instance_nearest(x,y,mCollisionParent) 
if distance_to_object(ClosestCollision) &lt;= (SenseRadius) {
DesiredHeading = point_direction(ClosestCollision.x,ClosestCollision.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestCollision.x + lengthdir_x(ClosestCollision.sprite_width / 2,point_direction(ClosestCollision.x,ClosestCollision.y,x,y))
GrazeY = ClosestCollision.y + lengthdir_y(ClosestCollision.sprite_width / 2,point_direction(ClosestCollision.x,ClosestCollision.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestCollision.x + lengthdir_x(ClosestCollision.sprite_width / 2,point_direction(ClosestCollision.x,ClosestCollision.y,x,y))
WanderY = ClosestCollision.y + lengthdir_y(ClosestCollision.sprite_width / 2,point_direction(ClosestCollision.x,ClosestCollision.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}




if instance_exists(mTabooParent) {
ClosestTaboo = instance_nearest(x,y,mTabooParent)
if point_distance(x,y,ClosestTaboo.x,ClosestTaboo.y) &lt;= (SenseRadius + (ClosestTaboo.sprite_width / 2)) {
Pausing = false
DesiredHeading = point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
GrazeY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
WanderY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}

}

//Following A Schedule
if State != "fleeing" {
switch mWorldController.CurrentWeekday {
//------------------------------- SUNDAY
case "Sunday":
//Midnight - 8: Patrolling
if current_hour &gt;= 0 and current_hour &lt; 8 {
GeneralWanderAndGraze()
}

//8 - 6pm: After Moles
if current_hour &gt;= 8 and current_hour &lt; 18 {
MoleHerd()
}

//6pm - Midnight: Byre
if current_hour &gt;= 18 and current_hour &lt;= 24 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}
break;

//------------------------------- MONDAY
case "Monday":
//Any time - random choice.
if current_hour &lt; 18 {
GeneralWanderAndGraze()
} else {
if mWorldController.TonightMoonPhase = "New Moon" {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
} 
} else {
GoToTop()
}
}
break;

//------------------------------- TUESDAY
case "Tuesday":
//Less than 3: Byre
if current_hour &lt; 3 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
} 
}

//3 - 10: West Woods
if current_hour &gt;= 3 and current_hour &lt; 10 {
if (y &lt; 3525 or y &gt; 3888) or x &gt; oHead2.x {
State = "wandering"
CurrentlyHunting = "westwoods"
}
}

//10 - 2: Right Eye
if current_hour &gt;= 10 and current_hour &lt; 14 {
if distance_to_object(mEyeRightParent) &gt;= 10 {
State = "wandering"
CurrentlyHunting = "righteye"
}
}

//2 - 4pm: To Top
if current_hour &gt;= 14 and current_hour &lt; 16 {
GoToTop()
}

//4 - 5.30: To Byre
if current_hour &gt;= 16 and (current_hour &lt; 17 or (current_hour = 17 and current_minute &lt; 30)) {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
} 

//5.30 - Midnight: If moon, herd, if no moon, byre
if current_hour &gt;= 17 and current_hour &lt;= 24 {
if mWorldController.TonightMoonPhase = "New Moon" {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
} 
} else {
MoleHerd()
}
}

break;


//------------------------------- WEDNESDAY
case "Wednesday":
if current_hour &lt; 18 {
MoleHerd()
}

if current_hour &gt;= 18 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
} 
}
break;


//------------------------------- THURSDAY
case "Thursday":

//Before 6: Wait At Byre
if current_hour &lt; 6 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}

//6 - 12: Left Eye
if current_hour &gt;= 6 and current_hour &lt; 12 {
if distance_to_object(mEyeLeftParent) &gt; 10 {
State = "wandering"
CurrentlyHunting = "lefteye"
}
}

//12 - 2.30: Go to southern woods and graze.
if current_hour &gt;= 12 and (current_hour &lt; 14 or (current_hour = 14 and current_minute &lt; 30)) {
if (x &lt; 600 or x &gt; 700) or (y &lt; 2600 or y &gt; 2800) {
State = "wandering"
CurrentlyHunting = "southwoods"
}
}

//2.30 - 4: General wandering and grazing (intersperse)
if (current_hour &gt; 14 or (current_hour = 14 and current_minute &gt;= 30)) and current_hour &lt; 16 {
GeneralWanderAndGraze()
}

//After 4: Go back to byre.
if current_hour &gt;= 16 and current_hour &lt;= 24 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}
break;

//------------------------------- FRIDAY
case "Friday":
//Midnight - 11am: In Byre
if current_hour &gt;= 0 and current_hour &lt; 11 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}

//11am - 6pm: After Moles
if current_hour &gt;= 11 and current_hour &lt; 18 {
MoleHerd()
}


//After 6: Up To Top
if current_hour &gt;= 18 and current_hour &lt;= 24 {
GoToTop()
}
break;

//------------------------------- SATURDAY
case "Saturday":
//Midnight to 5 - At top
if current_hour &gt;= 0 and current_hour &lt; 5 {
GoToTop()
}

//5 - 1: In byre
if current_hour &gt;= 5 and current_hour &lt; 13 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}

//1 - 3: Top Wood
if current_hour &gt;= 13 and current_hour &lt; 15 {
if (y &lt; 690 or y &gt; 900) {
State = "wandering"
CurrentlyHunting = "topwoods"
}
}

//3 - 6: Byre 
if current_hour &gt;= 15 and current_hour &lt; 18 {
if point_distance(x,y,oByre.x,oByre.y) &gt; 0 {
State = "wandering"
CurrentlyHunting = "byre"
}
}

//6 - Midnight: Patrolling
if current_hour &gt;= 18 and current_hour &lt;= 24 {
GeneralWanderAndGraze()
}
break;
}
}

//Run if come into contact with player scent.

ScentInContact = instance_place(x,y,mScentMarker)
if ScentInContact and State != "clustering" {
SourceOfFear = ScentInContact
State = "fleeing"
Pausing = false
Contaged = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = irandom_range(200,350)
}

//Run if come into contact with cellar
if (instance_exists(oSarahHead) and point_distance(x,y,oSarahHead.x,oSarahHead.y) &lt; SenseRadius) {
SourceOfFear = oSarahHead
State = "fleeing"
Pausing = false
Contaged = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = irandom_range(200,350)
}

} else {

if State = "fleeing" {
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(40,200)
}

ScentInContact = instance_place(x,y,mScentMarker)
if ScentInContact and State != "clustering" {
State = "shivering"
ShiverTimer = random_range(40,200)
}

//Shiver when come into shot, but otherwise stay still.

if (instance_exists(self) and PlayerViewOverObject(self) and VibeReady = true) or (mInterfaceController.CurrentView = "MicroView"
and VibeReady = true) {
State = "shivering"
ShiverTimer = random_range(40,200)
VibeReady = false
}

if (instance_exists(self) and PlayerViewOverObject(self) = false)
or ((mInterfaceController.ChangingView = true or mInterfaceController.CurrentView = "MacroView"))
and VibeReady = false
{ 
VibeReady = true
}



hspeed = 0
vspeed = 0
} 

} else {



State = "following"
SpeedMod = (1 * ViewSpeedMod) * 2

//if Chosen, Shiver Constantly

//Stay Still Unless Player Finger is inside sense radius

if mouse_check_button(mb_any) and point_distance(mouse_x,mouse_y,x,y) &lt;= ( SenseRadius * 5 ) and point_distance(mouse_x,mouse_y,x,y) &gt; 40 {
DirectionChangeRate = 1
SpeedChangeRate = 0.008
DesiredSpeed = WanderSpeed * SpeedMod
CurrentSpeed = DesiredSpeed
DesiredHeading = point_direction(x,y,mouse_x,mouse_y)
CurrentHeading = DesiredHeading
direction = CurrentHeading
hspeed = CurrentSpeed
vspeed = CurrentSpeed
} else {
DesiredSpeed = 0
CurrentSpeed = 0
hspeed = CurrentSpeed
vspeed = CurrentSpeed
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}

}
}



FleeTimer = clamp(FleeTimer,0,700)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Staying On Body &amp; Collision

///Then, Collision Avoidance &amp; Separation

/*
//Set Current Depth Depending On Nearby Moles
HighestColliderY = 0
HighestCollider = noone

with (oMoleHerd) {
if place_meeting(x,y,other) {
if y &gt; other.HighestColliderY {
other.HighestCollider = id
other.HighestColliderY = y
}
}
}

if HighestCollider != noone {
if HighestColliderY &gt; y {
depth = HighestCollider.depth + 0.0001
} else {
depth = OriginalDepth
}
} else {
depth = OriginalDepth
}
*/



if Activated = true {

if mDriveCollectionMaster.MSTimer &lt;= 0 and Chosen = false {


if PathCalculate = false {
if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}


//-------------------------TABOOS

if TabooLayer1Blocking = true {
if TabooLayer1Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead1.x,TabooLayer1Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer1Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead2.x,TabooLayer1Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer1Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer1Ahead3.x,TabooLayer1Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}
}

//--------------------------------------------


if TabooLayer2Blocking = true {
if TabooLayer2Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead1.x,TabooLayer2Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer2Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead2.x,TabooLayer2Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer2Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer2Ahead3.x,TabooLayer2Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}
}

//--------------------------------------------


if TabooLayer3Blocking = true {
if TabooLayer3Ahead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead1.x,TabooLayer3Ahead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer3Ahead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead2.x,TabooLayer3Ahead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}

if TabooLayer3Ahead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,TabooLayer3Ahead3.x,TabooLayer3Ahead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 60)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 60)
}
}
}

//--------------------------------------------




if State = "fleeing" or State = "clustering" or State = "following" or
(State = "wandering" and CurrentlyHunting = "moles")
or (State = "grazing" and SensedWound = true and WoundOfInterest = NearestWound)
{

if WoundAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead1.x,WoundAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead2.x,WoundAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead3.x,WoundAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}
}

}
}

if CollidingWound {
DistX = sign (x - CollidingWound.x)
DistY = sign(y - CollidingWound.y)
x += DistX
y += DistY
}

}

//Colliding 

if CollidingWall {
DistX = sign(x - CollidingWall.x)
DistY = sign(y - CollidingWall.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}

if CollidingTaboo and CollidingTaboo.Health &gt; 0 {
DistX = sign(x - CollidingTaboo.x)
DistY = sign(y - CollidingTaboo.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingTaboo.x,CollidingTaboo.y,x,y)
DirectionChangeRate = 20
}


//Avoiding Edge Of Room
if GapAhead1 = true or GapAhead3 = true or GapAhead2 = true {
if GapAhead3 = true {
DesiredHeading = (CurrentHeading - 30)
} else if GapAhead1 = true {
DesiredHeading = (CurrentHeading + 30)
} else if GapAhead2 = true {
DesiredHeading = (CurrentHeading - 30)
}
}

//Back onto body if not on it anymore
if !place_meeting(x,y,mCreatureParent) {
DesiredHeading = point_direction(x,y,instance_nearest(x,y,mHeadParent).x,instance_nearest(x,y,mHeadParent).y)
x = x + lengthdir_x(20,DesiredHeading)
y = y + lengthdir_y(20,DesiredHeading)
CurrentHeading = DesiredHeading
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Coming To Desired Speed And Direction

if GrownToSize = true {
if mDriveCollectionMaster.MSTimer &lt;= 0 or Chosen = false {

//Speed
if PathCalculate = false {
if Pausing = false and Activated = true {
if CurrentSpeed != DesiredSpeed {
if CurrentSpeed &lt; DesiredSpeed {
CurrentSpeed += SpeedChangeRate
} else if CurrentSpeed &gt; DesiredSpeed {
CurrentSpeed -= SpeedChangeRate
}
}
hspeed = CurrentSpeed
vspeed = CurrentSpeed
} else {
hspeed = 0
vspeed = 0
}



//Direction

if CurrentHeading != DesiredHeading {
if DesiredHeading &gt; CurrentHeading + DitherMod {
CurrentHeading += DirectionChangeRate
} else if DesiredHeading &lt; CurrentHeading - DitherMod {
CurrentHeading -= DirectionChangeRate
}
} 

direction = CurrentHeading

}
} else {
direction = CurrentHeading
}
}

//Clamping To Body
if place_meeting(x,y,oHead1) {
x = clamp(x,oHead1.x - (oHead1.sprite_width / 2),oHead1.x + (oHead1.sprite_width / 2))
} else if place_meeting(x,y,oHead2) {
x = clamp(x,oHead2.x - (oHead2.sprite_width / 2),oHead2.x + (oHead2.sprite_width / 2))
} else if place_meeting(x,y,oHead3) {
x = clamp(x,oHead3.x - (oHead3.sprite_width / 2),oHead3.x + (oHead3.sprite_width / 2))
}

if TabooLayer1Blocking = true {
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oTabooLayer1.y)
} else {
if TabooLayer2Blocking = true {
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oTabooLayer2.y)
} else {
if TabooLayer3Blocking = true {
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oTabooLayer3.y)
} else {
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oHead3.y + (oHead3.sprite_height / 2))
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing Sprite Depending On View
if Occupied = true {
ChangeDrawingWithZoom(ZoomedOutSprite,ZoomedInSprite,UnoccupiedRotation)
}

if DebugText = true {
draw_set_font(fTest)

DrawX = x
DrawY = y - 30

draw_text(DrawX,DrawY,"Activated: " + string(Activated))
DrawY += 10
draw_text(DrawX,DrawY,"Grown To Size: " + string(GrownToSize))
DrawY += 10
draw_text(DrawX,DrawY,"State: " + State)
DrawY += 10
draw_text(DrawX,DrawY,"Chosen: " + string(Chosen))
DrawY += 10
draw_line(x,y,x + lengthdir_x(50,CurrentHeading),y+lengthdir_y(50,CurrentHeading))
DrawY += 10
draw_line_width(x,y,x + lengthdir_x(50,CurrentHeading),y+lengthdir_y(50,CurrentHeading),10)
DrawY += 10
draw_set_color(c_green)
draw_line_width(x,y,x + lengthdir_x(50,direction),y+lengthdir_y(50,direction),10)
DrawY += 10
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
