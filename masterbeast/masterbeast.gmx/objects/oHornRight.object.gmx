<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sHornTopRight</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

OriginalX = x
OriginalY = y
Parent = oHornSocketRightFront
depth = AnatomyLayer2 + 0.04
Pulling = false
PullingXOffset = 0
PullingYOffset = 0
PullLimit = 5
PullLimitReached = false
PullTimer = 0
ShakeModX = 0
ShakeDirection = "out"
ShakeModY = 0
ShakeTimer = 0
Ripped = false
DripTimer = irandom_range(30,120)
Growing = false
PullingTimer = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup Growing For Next Time

with oHornSocketRightBack {
Growing = true
GrowingSurface = surface_create(sprite_width,500)
GrowingHorn = instance_create(x,y,oHornRight)
GrowingHorn.Growing = true
GrowingHorn.OriginalX = x + 1
GrowingHorn.OriginalY = y - 169
GrowingHorn.x = x + 1
GrowingHorn.y = y + 800
GrowingHorn.image_xscale = 0.31
GrowingHorn.image_yscale = 0.30
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Keep In Line With Parent

if Growing = false {
if Pulling = false and Ripped = false {
x = OriginalX + Parent.XDifference
y = OriginalY + Parent.XDifference
}
} else {
if y &gt; OriginalY {
y -= 0.003 - (0.002 / ((1 / 100) * (100 - mCreatureController.Alive)))
} else {
Growing = false
oHornSocketRightBack.Growing = false
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pulling Out

if Growing = false {
//Pulling Begin
if position_meeting(mouse_x,mouse_y,self) 
and mouse_check_button_pressed(mb_any) 
and instance_exists(mDebug) = false
and AmountForward(70)
and Pulling = false {
ex_audio_set_position("hornpull",self.x,self.y,1)
ex_audio_set_volume("hornpull",0,0)
ex_audio_play("hornpull",1)
PullingXOffset =  mouse_x - x
PullingYOffset = mouse_y - y
PullLimitReached = false
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
CurrentX = x
CurrentY = y
PullHornInitial()
}


//When Pulling...
if Pulling = true {

PullHornOngoing()

CurrentVol = ex_audio_get_volume("hornpull")
ex_audio_set_volume("hornpull", CurrentVol + 0.01,0) 


//Stop Pulling if move off horn or let go of button.
if mouse_check_button_released(mb_any) {
Pulling = false
PullingXOffset = 0
PullingYOffset = 0
ShakeModX = 0
ShakeModY = 0
PullLimitReached = false
x = CurrentX
y = CurrentY
ex_audio_set_volume("hornpull",0,20)
}

//Move horn with mouse.
if PullLimitReached = false {

y = mouse_y - PullingYOffset

y = clamp(y,(OriginalY - PullLimit),OriginalY)

if y &lt;= (OriginalY - PullLimit) {
PullLimitReached = true
PullTimer = 120
}

//If reached pull limit...
} else if PullLimitReached = true {

y = mouse_y - PullingYOffset
x = OriginalX + Parent.XDifference + ShakeModX 

y = clamp(y,(OriginalY - PullLimit),OriginalY)

if PullTimer &gt; 0 {
//Countdown
PullTimer -= 1
ShakeModMod += 0.03


//Shaking
if ShakeTimer &gt; 0 {
ShakeTimer -= 1
} else if ShakeTimer &lt;= 0 {
if ShakeDirection = "out" {
ShakeDirection = "in" 
ShakeTimer = 2
} else if ShakeDirection = "in" {
ShakeDirection = "out"
ShakeTimer = 2
}
}

if ShakeDirection = "out" {
ShakeModX -= (0.8 + ShakeModMod)
} else if ShakeDirection = "in" {
ShakeModX += (0.8 + ShakeModMod)
}

//If move back from PullLimit, reset the pulling.
if y &gt; (OriginalY - PullLimit) {
PullLimitReached = false
PullTimer = 60
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
}

//Actual Rip
} else if PullTimer &lt;= 0 {
mInterfaceController.CurrentHandUse = "holding"
ex_audio_set_volume("hornpull",0,5)
ex_audio_set_position("hornbreak",self.x,self.y,1)
ex_audio_set_volume("hornbreak",BothVolMod(0.25),0)
ex_audio_play("hornbreak",0)
WriteToLog("Pulled out right horn.")
Ripped = true
ChooseDir = choose(-1,1)
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
CreateParticleSplash(x,y + (sprite_height / 2),15,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,80,120,0.2,0.4,30,150,15,40,0,300)
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x - 50,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x + 50,y + (sprite_height / 2))
CreateStain(10,200,340,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x - 50,y + (sprite_height / 2))
CreateStain(10,40,130,4,10,0.5,0.1,0.2,0.1,0.2,DebugRedTextColour,x + 50,y + (sprite_height / 2))
Pulling = false
mCreatureController.HornsPulled += 1
mCreatureController.HornsPulled = clamp(mCreatureController.HornsPulled,0,20)
RipOutHornReactions()
}
}
} else {
if ex_audio_is_playing("hornpull") {
if ex_audio_get_volume("hornpull") &lt;= 0 {
ex_audio_stop("hornpull")
}
}
}



//Held Properties

if Ripped = true {

depth = OffObjectsLayer

DestroyIfLeaveBottomOfRoom()

if position_meeting(mouse_x,mouse_y,self.id) and mouse_check_button(mb_any) {
x = mouse_x - PullingXOffset
y = mouse_y - PullingYOffset
} else {


image_angle += (1 * ChooseDir)


speed = 70
direction = 270
}
} 

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dripping When Ripped

if Ripped = true {
if DripTimer &gt; 0 {
DripTimer -= 1
} else if DripTimer &lt;= 0 {
PosX = random_range(x - (sprite_width / 2),x + (sprite_width / 2))
PosY = random_range(y + (sprite_height / 2),y + sprite_height / 2 + 15)
MakeDripSound(x,y)
ThisDrip = instance_create(PosX,PosY,mDripBlood)
ThisDrip.Parent = self.id
DripTimer = irandom_range(30,120)
}
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Sprite

if Growing = false {
if Ripped = false {
draw_self()
} else if Ripped = true {
draw_sprite_ext(sprite_index,0,x + 2,y+2,image_xscale,image_yscale,image_angle,c_black,0.6)
draw_self()
draw_sprite_ext(sHornBottomRight,0,
x + lengthdir_x(590 * 0.3,image_angle - 90),
y + lengthdir_y(590 * 0.3,image_angle - 90),
image_xscale,image_yscale,image_angle,c_white,1)
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
