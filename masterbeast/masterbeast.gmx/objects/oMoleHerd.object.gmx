<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sSigilMoleSmall1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>mMoleParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

OriginalX = x
OriginalY = y
Status = "whole"
ZoomedOutSprite = choose(sSigilMoleSmall1,sSigilMoleSmall2,sSigilMoleSmall3,sSigilMoleSmall4,sSigilMoleSmall5,sSigilMoleSmall6,sSigilMoleSmall7,sSigilMoleSmall8)
ZoomedOutDirection = random(360)
direction = 0


Size = choose("small","med","large")

if Size = "small" {
depth = OnObjectsLayer
image_xscale = random_range(0.2,0.3)
image_yscale = image_xscale
} else if Size = "med" {
depth = OnObjectsLayer + 0.1
image_xscale = random_range(0.3,0.4)
image_yscale = image_xscale
} else if Size = "large" {
image_xscale = random_range(0.4,0.5)
image_yscale = image_xscale
depth = OnObjectsLayer + 0.2
}

ZoomedOutXScale = 0
ZoomedOutXScaleTarget = image_xscale * 2
ZoomedOutYScale = 0
ZoomedOutYScaleTarget = ZoomedOutXScaleTarget
ZoomedInScale = 0
ZoomedInScaleTarget = image_xscale / 4
OriginalDepth = depth
VibrReset = false

OriginalXScale = image_xscale
OriginalYScale = image_xscale
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
SeedClusterer = false
ClusterTimer = 3500
ClusterParent = noone
ClusterStopped = false


ZoomedInSprite = choose(sSigilMoleLarge1,sSigilMoleLarge4,sSigilMoleLarge6,sSigilMoleLarge7,sSigilMoleLarge8,sSigilMoleLarge9,sSigilMoleLarge10)
switch ZoomedInSprite {
case sSigilMoleLarge1:
Bottom = sSigilMoleBottom1
Red = sSigilMoleRed1
break;
case sSigilMoleLarge2:
Bottom = sSigilMoleBottom2
Red = sSigilMoleRed2
break;
case sSigilMoleLarge3:
Bottom = sSigilMoleBottom3
Red = sSigilMoleRed3
break;
case sSigilMoleLarge4:
Bottom = sSigilMoleBottom4
Red = sSigilMoleRed4
break;
case sSigilMoleLarge5:
Bottom = sSigilMoleBottom5
Red = sSigilMoleRed5
break;
case sSigilMoleLarge6:
Bottom = sSigilMoleBottom6
Red = sSigilMoleRed6
break;
case sSigilMoleLarge7:
Bottom = sSigilMoleBottom7
Red = sSigilMoleRed7
break;
case sSigilMoleLarge8:
Bottom = sSigilMoleBottom8
Red = sSigilMoleRed8
break;
case sSigilMoleLarge9:
Bottom = sSigilMoleBottom9
Red = sSigilMoleRed9
break;
case sSigilMoleLarge10:
Bottom = sSigilMoleBottom10
Red = sSigilMoleRed10
break;
}

ZoomedInDirection = 0
UnoccupiedRotation = random(360)
Redness = 0
Occupied = true
ID = 0
ChangeMultiplier = 0
XDir = 0
depth = MoleLayer

CutAmount = 0
Cutting = false

Ripped = false
DripTimer = irandom_range(30,120)

XDifference = 0
YDifference = 0
UpAmount = 60
BaseRedness = 0

GrownToSize = false
Energy = 100

//Senses

SenseRadius = 130
ClusterRadius = 60 * ZoomedInScale
MaxChildren = round(100 * OriginalXScale)
CurrentChildren = 0
BabyCreateLower = 2000 * OriginalXScale
BabyCreateHigher = 4000 * OriginalXScale
BabyTimer = 0
SensedMole = false
LastRememberedMole = noone
NearestMole = noone
SensedFur = false
LastRememberedFur = noone
NearestFur = noone
SensedWound = false
LastRememberedWound = noone
WoundOfInterest = noone
NearestWound = noone
GapAhead1 = false
GapAhead2 = false
GapAhead3 = false
WoundAhead1 = false
WoundAhead2 = false
WoundAhead3 = false 
CollidingWound = false
CollidingWall = false

//Growing

GrowMax = OriginalXScale + 0.25
GrowRate = random_range(0.000002,0.000003)
OriginalGrowRate = GrowRate
EatingGrowRate = GrowRate * 1.5

//Drives &amp; States

State = "grazing"

Hunger = 0
HungerChangeMod = 1
HungerLatch = 40
Loneliness = 0
LonelinessLatch = 40
Energy = 0
EnergyLatch = 20
FleeTimer = 0
TempSpeedMod = 0
TabooArea = false
FavouredArea = false
Activating = false
WakingUp = true
WakingTimer = 0

//Behaviours

GrazingSpeed = 5 / room_speed
GrazeX = x
GrazeY = y
GrazeRadius = 100
Pausing = false
GrazeTimer = 60
GrazePauseTimer = 300
GrazePTLower = 150 
GrazePTUpper = 400
GrazeTLower = 200
GrazeTUpper = 500 

WanderSpeed = 15 / room_speed
WanderRange = 200
WanderRadius = 700
BaseWanderRadius = 700
WanderStartX = x
WanderStartY = y
DitherMod = 2
AlignVar = 0
SepVar = 0
Neighbours = 0
CurrentlyHunting = "food"
MoleProx = 60
WoundProx = sprite_width * 2
WanderTimer = 300
WanderPauseTimer = 100
WanderPTLower = 60 
WanderPTUpper = 180
WanderTLower = 2000
WanderTUpper = 3000
CallOrNot = 0
Called = false

FleeSpeed = 35 / room_speed
SourceOfFear = noone
ContagTimer = 0
Contaged = false
FleeModRange = 50
GoneOffScreen = false

ShiverTimer = 0
ShiverDirection = "left"
ShiverOrNot = 0
XOffset = 0

ViewSpeedMod = 0
SpeedMod = 1
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.5
DesiredHeading = random(360)
DirectionChangeRate = 1
Slowdown = 0.5

//Collision

CollisionLength = 50
GapLength = 25
CollisionWidth = 35
CollisionAhead1 = noone
CollisionAhead2 = noone
CollisionAhead3 = noone
Turning = false
ColPointXM = 0
ColPointYM = 0
ColPointXL = 0
ColPointYL = 0
ColPointXR = 0
ColPointYR = 0

//Initialise!
CurrentSpeed = DesiredSpeed
CurrentHeading = DesiredHeading
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cutting Out

CutAmount = clamp(CutAmount,0,100)
//Cutting Begin

if instance_exists(mFinger) {
if (place_meeting(x,y,mFinger)
and instance_exists(mDebug) = false
and mInterfaceController.CurrentHandUse = "knife"
and mInterfaceController.CurrentView = MicroView
and Occupied = true)
or (place_meeting(x,y,mWoundParent))
{
//CutMoleReactions()
CreateParticleSplash(x,y,3,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,5,15,0.04,0.07,0,360,70,125,0.5,30)
CreateStain(10,0,360,5,10,0.2,0.3,0.5,0.05,0.06,BloodLiquidColour,x,y)
WriteToLog("Cut out normal mole.")
Occupied = false
ShakeModX = 0
ShakeModY = 0
ShakeModMod = 0
Cutting = false
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Touching

if place_meeting(x,y,mFinger) and  mInterfaceController.CurrentView = MicroView and instance_exists(mDebug) = false{
TouchMoleReactions()
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///In Line With Head

Redness = BaseRedness + ((0.5 / 100) * mDriveCollectionMaster.RitualTolerance)
BaseRedness = clamp(BaseRedness,0,0.5)

if Occupied = true {
sprite_index = ZoomedInSprite
image_xscale = ZoomedInScale
image_yscale = ZoomedInScale
} else if Occupied = false {
if mInterfaceController.CurrentView = MicroView {
sprite_index = sSigilMoleBottom
image_xscale = ZoomedInScale - 0.01 
image_yscale = ZoomedInScale - 0.01 
}
}

ChangeSpriteWithZoom(ZoomedOutXScale,ZoomedOutYScale,ZoomedInScale,ZoomedInScale)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Grow To Size

if GrownToSize = false {

if ZoomedOutXScale &lt; ZoomedOutXScaleTarget {
ZoomedOutXScale += 0.001
ZoomedOutYScale = ZoomedOutXScale
}
if ZoomedInScale &lt; ZoomedInScaleTarget {
ZoomedInScale += 0.02
}
}

if ZoomedOutXScale &gt;= ZoomedOutXScaleTarget
and ZoomedInScale &gt;= ZoomedInScaleTarget {
GrownToSize = true
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Senses &amp; Memory

if Energy &gt; 0 {

//Collision Sensing

ColPointXM = x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = y + lengthdir_y(CollisionLength,CurrentHeading)
ColPointXL = x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)
ColPointXR = x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

GapPointXM = x + lengthdir_x(GapLength,CurrentHeading)
GapPointYM = y + lengthdir_y(GapLength,CurrentHeading)
GapPointXL = x + lengthdir_x(GapLength,CurrentHeading - CollisionWidth)
GapPointYL = y + lengthdir_y(GapLength,CurrentHeading - CollisionWidth)
GapPointXR = x + lengthdir_x(GapLength,CurrentHeading + CollisionWidth)
GapPointYR = y + lengthdir_y(GapLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mCollisionParent,true,true)
CollisionAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mCollisionParent,true,true)
CollisionAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mCollisionParent,true,true)
WoundAhead1 = collision_line(x,y,ColPointXM,ColPointYM,mWoundParent,true,true)
WoundAhead2 = collision_line(x,y,ColPointXL,ColPointYL,mWoundParent,true,true)
WoundAhead3 = collision_line(x,y,ColPointXR,ColPointYR,mWoundParent,true,true)


if collision_point(GapPointXL,GapPointYL,mHeadParent,true,true) = noone
{
GapAhead1 = true
} else {
GapAhead1 = false
}

if collision_point(GapPointXM,GapPointYM,mHeadParent,true,true) = noone {
GapAhead2 = true
} else {
GapAhead2 = false
}

if collision_point(GapPointXR,GapPointYR,mHeadParent,true,true) = noone {
GapAhead3 = true
} else {
GapAhead3 = false
}

CollidingWall = instance_place(x + hspeed,y + vspeed,mCollisionParent)
CollidingWound = instance_place(x + hspeed,y + vspeed,mWoundParent)
CollidingMole = instance_place(x + hspeed,y + vspeed, oMoleHerd)

//Temperature Sensing

if mWorldController.CurrentTemp &lt; 10 {
TempSpeedMod = -0.35
LonelyMod = 2
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
TempSpeedMod = 0
LonelyMod = 1
} else {
TempSpeedMod = 0.35
LonelyMod = 1
}

//Viewport Speed Mod

if mInterfaceController.CurrentView = "Macro" {
ViewSpeedMod = 0.07
} else if mInterfaceController.CurrentView = "Micro" {
ViewSpeedMod = 1
}

//Always note where the nearest POI is.

NearestMole = instance_nth_nearest(tMole,x,y,2)
NearestFur = instance_nearest(x,y,mFurParent)
NearesmWoundParent = instance_nearest(x,y,mWoundParent)


//As long as has energy, detect whether a certain POI is within 
//the sense radius, and update memory of where the last-seen POI is.

if distance_to_object(NearestMole) &lt;= SenseRadius {
SensedMole = true
LastRememberedMole = NearestMole
} else {
SensedMole = false
}

if distance_to_object(NearestFur) &lt;= SenseRadius {
SensedFur = true
LastRememberedFur = NearestFur
} else {
SensedFur = false
}

if instance_exists(mWoundParent) {
if distance_to_object(NearesmWoundParent) &lt;= SenseRadius {
SensedWound = true 
LastRememberedWound = NearesmWoundParent
} else {
SensedWound = false
}
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Growing Over Time

switch mWorldController.CurrentTOD {
case "Morning":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Afternoon":
LonelyDayMod = 1
SenseRadius = 60
break;
case "Night":
LonelyDayMod = 3
SenseRadius = 30
break;
}

if mWorldController.CurrentTemp &lt; 10 {
GrowMod = 0.5
} else if mWorldController.CurrentTemp &gt;= 10 and mWorldController.CurrentTemp &lt; 20 {
GrowMod = 1
} else {
GrowMod = 1.5
}

if GrownToSize = true {
if Energy &gt; 0 {
if image_xscale &lt; GrowMax {
if State != "eating" {
BaseXScale += GrowRate * GrowMod
BaseYScale += GrowRate * GrowMod
} else {
BaseXScale += EatingGrowRate * GrowMod
BaseYScale += EatingGrowRate * GrowMod
}
}
}
}

ZOutScale = BaseXScale * 5













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drives

if GrownToSize = true {

if State = "grazing" {
HungerChangeMod = 1
EnergySpeedMod = 1
} else if State = "wandering" {
HungerChangeMod = 1.1
EnergySpeedMod = 1.1
} else if State =  "fleeing" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
} else if State = "clustering" {
HungerChangeMod = 0.5
EnergySpeedMod = 0
} else if State = "following" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
}

if Energy &gt; 0 {

//Normal Actions (Night or Zoomed-Out Day)
if (mWorldController.CurrentTOD = "Night")
or (mWorldController != "Night" and CurrentView = "Macro") {


//Hunger

//Hunger goes up at all times, apart from when eating, when it goes down.

if State != "eating" and State != "clustering" {
Hunger += mPlotController.HungerChangeRate * HungerChangeMod
} else if State = "eating" {
Hunger -= mPlotController.HungerChangeRate * 1.5
}

//Loneliness 

//Loneliness goes up when away from others, down when near to others.

if State != "clustering" {
if SensedMole = false {
Loneliness += (mPlotController.LonelyChangeRate * LonelyDayMod) * LonelyMod
} else {
Loneliness -= (mPlotController.LonelyChangeRate * 10) * LonelyDayMod
}
}

//Fear


//When Started Fleeing, Allow The Timer To Go Down If They Have Already Disappeared OffScreen ONCE,

//Or the user has zoomed out.

if State = "fleeing" {
if GoneOffScreen = false {
if mInterfaceController.CurrentView = "Macro" or
(mInterfaceController.CurrentView = "Micro" and 
(x &lt; view_xview[1] 
or x &gt; (view_xview[1] + view_wview[1])
or y &lt; view_yview[1] 
or y &gt; (view_yview[1] + view_hview[1])
)
)
{
GoneOffScreen = true
}
}
}



//When fleeing, count down the flee timer - if it reaches zero, reset and go back to grazing.

if State = "fleeing" {
if FleeTimer &gt; 0 {
if mInterfaceController.CurrentView = "Macro"
or (mInterfaceController.CurrentView = "Micro" and GoneOffScreen = true) {
FleeTimer -= 1
}
} else if FleeTimer &lt;= 0 {
GoneOffScreen = false
if Contaged = true {
ContagTimer = 300
}
CallOrNot = choose(-1,1,-1,-1)
FleeTimer = 0
DesiredSpeed = 0
SpeedChangeRate = 0.01
ShiverOrNot = choose(-1,1)
if ShiverOrNot = 1 {
State = "shivering"
ShiverTimer = random_range(100,400) * (GrowMax * 5)
} else {
SourceOfFear = noone
GrazeX = x
GrazeY = y
State = "grazing"
}
}
}

//The timeout to stop emotional contagion triggering constantly, leading to panic stasis in a crowd.
if ContagTimer &gt; 0 {
ContagTimer -= 1
}



//Clustering
//If in range of a clusterer, and not clustering, begin clustering, and set that clusterer as your parent.

if State != "clustering" {
if SensedMole = true {
with oMoleHerd {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius {
if SeedClusterer = true {
if other.OriginalXScale &lt;= OriginalXScale {
if CurrentChildren &lt; MaxChildren {
other.State = "clustering"
CurrentChildren += 1
other.ClusterStopped = false
other.ClusterParent = id
other.CVal = irandom_range(ClusterRadius - 2, ClusterRadius + 2)
other.ClusterPointX = x + lengthdir_x(other.CVal,random(360))
other.ClusterPointY = y + lengthdir_y(other.CVal,random(360))
}
}
}
}
}
}
}


//--------------------------------------

//Action Plan


//Running if a nearby mole is scared (Emotional Contagion)
if NearestMole != noone {
if SensedMole = true {
if ContagTimer &lt;= 0 {
if NearestMole.State = "fleeing" and NearestMole.FleeTimer &gt; 100 and State != "fleeing" {
SourceOfFear = NearestMole
State = "fleeing"
Pausing = false
Contaged = true
GoneOffScreen = false
FleeTimer = 199 * (GrowMax * 5)
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
DesiredHeading = point_direction(NearestMole.x,NearestMole.y,x,y) + (random_range(-30,30))
CurrentHeading = DesiredHeading
}
}
}
}

//If the nearest wound is new (i.e. not of the latest interest), move
//towards it to investigate, then disregard it.

if instance_exists(oWound) or instance_exists(oStabWound) {
if SensedWound = true {
if WoundOfInterest != NearestWound {
if State = "grazing" or (State = "wandering" and CurrentlyHunting != "food") {
if point_distance(x,y,NearestWound.x,NearestWound.y) &gt; (sprite_width / 2) + 30 {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)
if State = "grazing" {
CurrentHeading = DesiredHeading
}
} else {
WoundOfInterest = NearestWound
}
}
}
}
}

//Attracted Areas - if grazing or wandering, and the parent object is in range,
//set this as a new graze point or wander point.
if State = "grazing" or State = "wandering" {
if instance_exists(mFavouredParent) {
ClosestFavour = instance_nearest(x,y,mFavouredParent)
if point_distance(x,y,ClosestFavour.x,ClosestFavour.y) &lt;= (SenseRadius + (ClosestFavour.sprite_width / 2)) {
if State = "grazing" {
GrazeX = ClosestFavour.x
GrazeY = ClosestFavour.y
} else if State = "wandering" {
WanderStartX = ClosestFavour.x
WanderStartY = ClosestFavour.y
}
}
}
}

//Taboo Areas - if clustering and seed, if fleeing/grazing or wandering, and parent object is in range,
//move directly away from it until out of sight.

if State = "grazing" or State = "wandering" or (State = "clustering" and SeedClusterer = true) or State = "fleeing" {
if instance_exists(mTabooParent) {
ClosestTaboo = instance_nearest(x,y,mTabooParent)
if point_distance(x,y,ClosestTaboo.x,ClosestTaboo.y) &lt;= (SenseRadius + (ClosestTaboo.sprite_width / 2)) {
Pausing = false
DesiredHeading = point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
GrazeY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
WanderY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
}


//Run if come into contact with player scent.
ScentInContact = instance_place(x,y,oScentMarker)
if ScentInContact and State != "fleeing" and State != "clustering" {
SourceOfFear = ScentInContact
State = "fleeing"
Pausing = false
Contaged = false
GoneOffScreen = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 100 * (GrowMax * 5)
}

//Run from player finger
if (instance_exists(mFinger) and point_distance(x,y,mFinger.x,mFinger.y) &lt; SenseRadius)
and  State != "fleeing" and State != "clustering" {
SourceOfFear = mFinger
State = "fleeing"
Pausing = false
Contaged = false
GoneOffScreen = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 100 * (GrowMax * 5)
}



//Run if a Picked Mole is held overhead.

if SensedMole = true {
if NearestMole.Ripped = true {
Pausing = false
SourceOfFear = NearestMole
State = "fleeing"
Contaged = false
GoneOffScreen = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 300 * (GrowMax * 5)
}
}

//Begin wandering if hungry or lonely (hunger wins).
if State != "fleeing" and State != "clustering" and State != "eating" and State != "shivering" and State != "following" {

if Hunger &gt;= HungerLatch {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering"
CurrentlyHunting = "food" 
if LastRememberedWound != noone and instance_exists(LastRememberedWound) {
DesiredHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}

if Loneliness &gt;= LonelinessLatch and SensedMole = false {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering" 
CurrentlyHunting = "moles"
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
DesiredHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}
}



}

} else {
//In Day And Zoomed In

//Shiver when come into shot, but otherwise stay still.


if VibrReset = 
State = "shivering"
ShiverTimer = random_range(100,400) * (GrowMax * 5)


if PlayerViewOverObject(self) = false
or mInterfaceController.ChangingView = true
{ 
VibrReset = true
}


hspeed = 0
vspeed = 0

}

}




Hunger = clamp(Hunger,0,100)
Loneliness = clamp(Loneliness,0,100)
Energy = clamp(Energy,0,100)
FleeTimer = clamp(FleeTimer,0,700)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Behaviours

///Top Speed Affected By Current Energy Level
SpeedMod = (1 - (0.7 - ((0.7 / 100) * Energy)) + TempSpeedMod) * ViewSpeedMod

if GrownToSize = true {

//Make sure that seed clustering is reset if, for any reason, the state changes.
if State != "clustering" {
if SeedClusterer = true {
SeedClusterer = false 
ClusterTimer = 8000
}
}

//As long as we are alive, do these behaviours.
if Energy &gt; 0 {

// FLEEING ---------------------------------------------------------------------
if State = "fleeing" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.01

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}
} else {
if place_meeting(x,y,mFurParent) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),mFurParent) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}

// GRAZING ---------------------------------------------------------------------
} else if State = "grazing" {

DesiredSpeed = GrazingSpeed * SpeedMod
DirectionChangeRate = 1
SpeedChangeRate = 0.003


//Wander in a direction, pause, then change direction.
if Pausing = false {
if GrazeTimer &gt; 0 {
GrazeTimer -= 1 
} else if GrazeTimer &lt;= 0 {
CallOrNot = choose(-1,1)
Called = false
CallWaitTimer = random_range(40,80)
Pausing = true
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
GrazeTimer = 0
}
} else if Pausing = true {
if GrazePauseTimer &gt; 0 {
GrazePauseTimer -= 1
} else if GrazePauseTimer &lt;= 0 {
Pausing = false
GrazeTimer = random_range(GrazeTLower,GrazeTUpper)
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}

//If reach the current graze boundary, turn back.
if SensedMole = false {
if point_distance(x,y,GrazeX,GrazeY) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
} else {
if point_distance(NearestMole.x,NearestMole.y,x,y) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
}

// WANDERING --------------------------------------------------------------------
} else if State = "wandering" {

DirectionChangeRate = 1
SpeedChangeRate = 0.008

if SensedMole = false {
if Pausing = false {
if WanderTimer &gt; 0 {
WanderTimer -= 1
} else if WanderTimer &lt;= 0 {
if CurrentlyHunting = "moles" {
CallOrNot = choose(-1,1)
} else {
CallOrNot = -1
}
Called = false
CallWaitTimer = random_range(40,80)
WanderPauseTimer = random_range(WanderPTLower,WanderPTUpper)
Pausing = true 
}
} else if Pausing = true {
if WanderPauseTimer &gt; 0 {
WanderPauseTimer -= 1
} else if WanderPauseTimer &lt;= 0 {
WanderTimer = random_range(WanderTLower,WanderTUpper)
Pausing = false
}
}
} else {
Pausing = false
}

if CurrentlyHunting = "food" {
DesiredSpeed = WanderSpeed * SpeedMod
} else if CurrentlyHunting = "moles" {
DesiredSpeed = WanderSpeed * SpeedMod
} else {
DesiredSpeed = WanderSpeed * SpeedMod
}


if Loneliness &lt; 70 {
WanderRadius = BaseWanderRadius
} else {
WanderRadius = BaseWanderRadius / 2
}



//Reset Flocking Variables
AlignVar = 0
CohVar = 0
SepVar = 0
Neighbours = 0

if CollidingWall = noone and CollisionAhead1 = noone and CollisionAhead2 = noone and CollisionAhead3 = noone and TabooArea = false
and GapAhead1 = false and GapAhead2 = false and GapAhead3 = false
{
with tMole {
//Alignment Calculation
NDistance = point_distance(other.x,other.y,x,y)
if (id != other.id) and (NDistance &lt;= other.SenseRadius) { 
other.AlignVar += CurrentHeading
other.CohVar += point_direction(other.x,other.y,x,y)
other.SepVar += point_direction(x,y,other.x,other.y)
other.Neighbours += 1
}
}

if CurrentlyHunting = "food" {
if LastRememberedWound != noone and instance_exists(LastRememberedWound){
HuntingHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
HuntingHeading = CurrentHeading
}
} else if CurrentlyHunting = "moles" {
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
HuntingHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
HuntingHeading = CurrentHeading
}
} else {
HuntingHeading = CurrentHeading
}

//Desired Heading With Flocking (Ignore Search)
if Neighbours &gt; 0 {
AverageHeading = ((AlignVar / Neighbours) + (CohVar / Neighbours) + (SepVar / Neighbours))  / 3
DesiredHeading = AverageHeading //+ irandom_range(((WanderRange / 2) * -1),(WanderRange / 2))
DirectionChangeRate = 5
//Desired Heading Without Flocking (Active Search)
} else if Neighbours &lt;= 0 {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
WanderModLower = HuntingHeading - (WanderRange / 2)
WanderModHigher = HuntingHeading + (WanderRange / 2)
DesiredHeading = irandom_range(WanderModLower,WanderModHigher)
}
}
}

//Seek Thing And Arrive If In Sense Radius
if CurrentlyHunting = "food" {
if SensedWound = true {
DirectionChangeRate = 5
if instance_exists(NearestWound) {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)

DesiredSpeed = ((WanderSpeed * 3) * ((distance_to_object(NearestWound) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if distance_to_object(NearestWound) &lt;= 0 {
DesiredSpeed = 0
CurrentSpeed = 0
State = "eating"
}
}
}


} else if CurrentlyHunting = "moles" {
if SensedMole = true {
DirectionChangeRate = 5
if instance_exists(NearestMole) {
DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)

DesiredSpeed = ((WanderSpeed * 3) * ((distance_to_object(NearestMole) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if instance_exists(NearestMole) 
and point_distance(x,y,NearestMole.x,NearestMole.y) &lt;= MoleProx {
GrazeX = x
GrazeY = y
DesiredSpeed = 0
CurrentSpeed = 0
Loneliness = 0
State = "grazing"
}
}
}
}

//Turn Back If Outside Wander Radius
if point_distance(x,y,WanderStartX,WanderStartY) &gt; WanderRadius {
CurrentHeading = point_direction(x,y,WanderStartX,WanderStartY)
}



// EATING -----------------------------------------------------------------------

} else if State = "eating" {

DesiredSpeed = 0
SpeedChangeRate = 0.01

//If sated, stop eating and 'detach'.
if Hunger &lt;= 0 or instance_exists(NearestWound) = false {
if place_meeting(x,y,NearestWound) {
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.001
DesiredHeading = point_direction(NearestWound.x,NearestWound.y,x,y)
CurrentHeading = DesiredHeading
} else {
State = "grazing"
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
if instance_exists(NearestWound) {
CurrentDirection = point_direction(NearestWound.x,NearestWound.y,x,y)
} else {
CurrentDirection = random(360)
}
}
} else {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}

// CLUSTERING ----------------------------------------------------------------------

} else if State = "clustering" {

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

//If Seed Clusterer, Count Down ClusterTimer. If it runs out, reset and begin grazing.

if SeedClusterer = true {
if DoNotClusterHere = false {
DesiredSpeed = 0
SpeedChangeRate = 0.001
if ClusterTimer &gt; 0 {
ClusterTimer -= 1
} else if ClusterTimer &lt;= 0 {
GrazeX = x
GrazeY = y
State = "grazing"
SeedClusterer = false
ClusterTimer = 8000
tController.Clusters -= 1
CurrentChildren = 0
}


if BabyTimer &gt; 0 {
BabyTimer -= 1
} else if BabyTimer &lt;= 0 {
PointX = x + lengthdir_x(random_range(2, ClusterRadius),random(360))
PointY = y + lengthdir_y(random_range(2, ClusterRadius),random(360))
ThisBaby = instance_create(PointX,PointY,oMoleHerd)

with ThisBaby {
Energy = 100
OriginalXScale = other.OriginalXScale / 2
OriginalYScale = other.OriginalXScale / 2
image_xscale = OriginalXScale
image_yscale = 0
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
ZOutScale = OriginalXScale * 5
GrowMax = OriginalXScale + 0.2
State = "clustering"
ClusterPointX = x
ClusterPointY = y
ClusterParent = other.id
}
BabyTimer = random_range(BabyCreateLower,BabyCreateHigher)
}
}

} else if SeedClusterer = false {
//Stop clustering as soon as Parent stops.
if ClusterParent.State != "clustering" {
State = ClusterParent.State
ClusterParent = noone
CurrentChildren = 0
GrazeX = x
GrazeY = y
WanderX = x
WanderY = y
}

//Change Cluster Point If Not Legal

if position_meeting(ClusterPointX,ClusterPointY,mCollisionParent) {
ClusterPointX = ClusterParent.x + lengthdir_x(random_range(5, ClusterParent.ClusterRadius),random(360))
ClusterPointY = ClusterParent.y + lengthdir_y(random_range(5, ClusterParent.ClusterRadius),random(360))
}

if x &gt; ClusterPointX - 1 and x &lt; ClusterPointX + 1
and y &gt; ClusterPointY - 1 and y &lt; ClusterPointY + 1 {
DesiredSpeed = 0
CurrentSpeed = 0
} else {
DesiredHeading = point_direction(x,y,ClusterPointX,ClusterPointY)
CurrentHeading = DesiredHeading
DesiredSpeed = GrazingSpeed * SpeedMod
}

}

// SHIVERING -----------------------------------------------------------------------------

} else if State = "shivering" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.02
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}



if ShiverTimer &gt; 0 {
ShiverTimer -= 1


} else if ShiverTimer &lt;= 0 {
ShiverTimer = 0
ShiverOrNot = 0
XOffset = 0
State = "grazing"
GrazeX = x
GrazeY = y
SourceOfFear = noone
}

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

}


//CALLING OUT ---------------------------------------------------------------------------


//Depending On State, Call Out
if Pausing = true and State != "grazing" {
if CallOrNot = 1 {
if CallWaitTimer &gt; 0 {
CallWaitTimer -= 1 
} else if CallWaitTimer &lt;= 0 {
//Shiver &amp; Make The Call, Depending On State (Just Once)
if Called = false {
if tController.CurrentView = "in" {
audio_play_sound_at(aTwitchShort,x,y,0,100,300,1,false,1)
}
//Play The Sound
Called = true
}

if audio_is_playing(aTwitchShort) {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}
}
}
}

}

}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Staying On Body &amp; Collision

///Then, Collision Avoidance &amp; Separation

//Set Current Depth Depending On Nearby Moles
HighestColliderY = 0
HighestCollider = noone

with (oMoleHerd) {
if place_meeting(x,y,other) {
if y &gt; other.HighestColliderY {
other.HighestCollider = id
other.HighestColliderY = y
}
}
}

if HighestCollider != noone {
if HighestColliderY &gt; y {
depth = HighestCollider.depth + 0.0001
} else {
depth = OriginalDepth
}
} else {
depth = OriginalDepth
}




if Energy &gt; 0 {
if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}



if State = "fleeing" or State = "clustering" or State = "following" or
(State = "wandering" and CurrentlyHunting = "moles")
or (State = "grazing" and SensedWound = true and WoundOfInterest = NearestWound)
{

if WoundAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead1.x,WoundAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead2.x,WoundAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead3.x,WoundAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollidingWound {
DistX = sign (x - CollidingWound.x)
DistY = sign(y - CollidingWound.y)
x += DistX
y += DistY
}

}

//Colliding 

if CollidingWall {
DistX = sign(x - CollidingWall.x)
DistY = sign(y - CollidingWall.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}


//Avoiding Edge Of Room
if GapAhead1 = true or GapAhead3 = true or GapAhead2 = true {
if GapAhead3 = true {
DesiredHeading = (CurrentHeading - 30)
} else if GapAhead1 = true {
DesiredHeading = (CurrentHeading + 30)
} else if GapAhead2 = true {
DesiredHeading = (CurrentHeading - 30)
}
}

//Clamping To Body
if place_meeting(x,y,oHead1) {
x = clamp(x,oHead1.x - (oHead1.sprite_width / 2),oHead1.x + (oHead1.sprite_width / 2))
y = clamp(y,oHead1.y - (oHead1.sprite_height / 2),oHead1.y + (oHead1.sprite_height / 2))
} else if place_meeting(x,y,oHead2) {
x = clamp(x,oHead2.x - (oHead2.sprite_width / 2),oHead2.x + (oHead2.sprite_width / 2))
y = clamp(y,oHead2.y - (oHead2.sprite_height / 2),oHead2.y + (oHead2.sprite_height / 2))
} else if place_meeting(x,y,oHead3) {
x = clamp(x,oHead3.x - (oHead3.sprite_width / 2),oHead3.x + (oHead3.sprite_width / 2))
y = clamp(y,oHead3.y - (oHead3.sprite_height / 2),oHead3.y + (oHead3.sprite_height / 2))
}






}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Coming To Desired Speed And Direction

if GrownToSize = true {

//Speed

if Pausing = false and Energy &gt; 0 {
if CurrentSpeed != DesiredSpeed {
if CurrentSpeed &lt; DesiredSpeed {
CurrentSpeed += SpeedChangeRate
} else if CurrentSpeed &gt; DesiredSpeed {
CurrentSpeed -= SpeedChangeRate
}
}
hspeed = CurrentSpeed
vspeed = CurrentSpeed
} else {
hspeed = 0
vspeed = 0
}



//Direction

if CurrentHeading != DesiredHeading {
if DesiredHeading &gt; CurrentHeading + DitherMod {
CurrentHeading += DirectionChangeRate
} else if DesiredHeading &lt; CurrentHeading - DitherMod {
CurrentHeading -= DirectionChangeRate
}
} 

direction = CurrentHeading

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing Sprite Depending On View
if Occupied = true {
ChangeDrawingWithZoom(ZoomedOutSprite,ZoomedInSprite,UnoccupiedRotation)
} else {
draw_self()
}

if mInterfaceController.CurrentView = MicroView and Occupied = true and mInterfaceController.ChangingView = false {
draw_sprite_ext(Red,0,x,y,ZoomedInScale,ZoomedInScale,0,DebugRedTextColour,Redness)
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
