<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

depth = HeadSkinLayer - 0.0001
x = ControllerObjectX
y = ControllerObjectY

//Views

CurrentView = MacroView
CurrentViewNumber = 0
ChangingView = false

OriginalMacroX = 0
OriginalMacroY = 1000
OriginalMacroW = 1400
OriginalMacroH = 1920
OriginalMicroX = 0
OriginalMicroY = 0
OriginalMicroW = 360
OriginalMicroH = 640

ChangingTo = "none"

ScreenShaking = false
ShakeMod = 0

BaseXView = OriginalMacroX
BaseYView = OriginalMacroY

CursorInGame = false
SigilCapture = false
ShapeToCheck = 0
CurrentHandUse = "none"

DragX = 0
DragY = 0

Direction = "none"

LastX = 0
LastY = 0

NoNewCut = false

HeadViewTriggerY = 810
TopHeadViewModMax = HeadViewTriggerY - 200 

//Touch Properties

PressBegun = false
PressFinished = false
LongPressFinished = false
LongPressThreshold = 80
PressTimer = 0
PressFinishTimer = 0

DragBegun = false
DragDistance = 0
DragDirection = 0
DragStartX = 0
DragStartY = 0
DragSpeed = 0
DragFurTimer = 0

DragStatus = "not dragging"
PressStatus = "not pressing"

VMove = "none"
HMove = "none"
MoveSpeed = 0
DisplayHMove = HMove
DisplayVMove = VMove
DisplaySpeed = MoveSpeed
alarm[0] = 10
SpeedMax = 100
CurrentSpeed = 0
CurrentDir = 0

Taps = 0
TapTimer = 0
TapThreshold = 15

HandWet = false
HandWetType = "none"

Smearing = false

ResetReadyStage = 0

ViewMax = mPlotController.TabooLayer1Y

FingerObjectVisible = false

LatestMouseAction = "none"
LatestSigil = "none"

ResetTimer = 0

//Sigils

TestSigil1 = "18,16,17,14,9,3,4,10,15,"
TestSigil2 = "1,2,8,9,3,12,13,14,15,10,4,"

SequenceBegun = false
SequenceArray[0] = 0
NextSequencePos = 0
CandidateSymbol = ""
PostDisplay = false
LatestMole = noone
SigilSurface = surface_create(345,290)
SigilSurfaceAlpha = 1

LoadAudioEngine()

SigilPartSys = part_system_create()

//Define Different Particles Based On Liquid Type
SigilPart = part_type_create()
part_type_sprite(SigilPart,sSigilPart,1,0,0)
part_type_size(SigilPart,0.05,0.08,-0.01,0.01)
part_type_colour1(SigilPart,c_black)
part_type_alpha1(SigilPart,0.9)
part_type_speed(SigilPart,1,3,0,0)
part_type_direction(SigilPart,0,359,0,0)
part_type_gravity(SigilPart,0.3,270)
part_type_blend(SigilPart,0)
part_type_life(SigilPart,15,30)

SigilEmit = part_emitter_create(SigilPartSys)
SigilAlpha = 0

//Wounding

Wounding = false
CuttingWhat = "none"
MaxCutLength = 150
CutStartX = 0
CutStartY = 0
CutDistance = 0
DrawingPath = false
CutTimer = 0
ThisWoundPath = path_add()
path_set_kind(ThisWoundPath,1)
path_set_precision(ThisWoundPath,8)
path_set_closed(ThisWoundPath, false)
MaxCuts = 20
GrabbingBodyPart = false
BruiseThreshold = 120
PotentialSlap = false
WillSlap = false


//Finger
FingerLightOn = false
LightTime = 500
CurrentLightTime = LightTime
LightRadBase = 4

LastPressX = 500
LastPressY = 800

Slapped = false

//Zooming &amp; Dragging
ZoomRate = 50
ViewTargetX = 0
ViewTargetY = 0
ZoomTimer = 0
ViewXDiff = 0
ViewYDiff = 0

DragReset = true
DragTimer = 0
DragTimerInitial = 100
DragDistance = 0
DragResist = 0
PhraseMoving = false

alarm[1] = 5

BreathYMod = 0

PotentialSlap = false
KnifeTimer = 0

ResistTimer = 0

SigilBruiseAlpha = 0

Jumping = false
JumpMod = 0
SlipMod = 0
CutReact = 0
CutReactOut = 0

SlapTimer = 0
FurTaps = 0
CankerTaps = 0

SmearAmount = 0

SequenceTimer = 0

DeadMod = 0

Faces = 0

LiquidPlaces = ds_list_create()

CaulSenLead = 10
CaulSenBowl = 35
CaulSenJug = 60
CaulSenLip = 80
CaulSenNub = 100

SSSideTime = 0

//Floating
Floating = true
FloatLength = 0
FloatDir = "left"
FinishedFloatOut = false
FloatComp = irandom_range(-45,45)
TotalFloatLength = irandom_range(50,100)

Cleaning = false

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivations

//Cankers
with oCaulCankerCentral {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

//Sigil Moles
with sSigilMoleParent {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

//Wens
with oWen {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oPlotWound2 {
if sprite_index != sMoleHoleHealed {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
} else {
if ( (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
) or (mInterfaceController.CurrentViewNumber = 0) {
instance_deactivate_object(self) 
}
}
}

with oPlotWound3 {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oFloaterRight {
if 
(x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oFloaterLeft {
if 
(x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

instance_activate_region(view_xview[mInterfaceController.CurrentViewNumber],view_yview[mInterfaceController.CurrentViewNumber],view_wview[mInterfaceController.CurrentViewNumber],view_hview[mInterfaceController.CurrentViewNumber],true)

with oFloaterRight {
if mInterfaceController.CurrentView = MacroView
{
instance_deactivate_object(self)
}
}

with oFloaterLeft {
if mInterfaceController.CurrentView = MacroView
{
instance_deactivate_object(self)
}
}

alarm[1] = 5
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Mouse Speed At Sane Intervals

DisplayHMove = HMove
DisplayVMove = VMove
DisplaySpeed = MoveSpeed

alarm[0] = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Find Last X And Y

if instance_exists(mFinger) {
LastX = mFinger.x
LastY = mFinger.y
} else {
LastX = mouse_x
LastY = mouse_y
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>mInterfaceController</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing From MicroView To MacroView

if ChangingView = true {
//Swap the view numbers and write to log.
//Change To Micro

if ChangingTo = "Micro" {
if ZoomTimer &lt; ZoomRate {
ZoomTimer += 1

CurrentZoomPitch = BaseZoomPitch + ((0.05 / ZoomRate) * ZoomTimer)
CurrentZoomVol = 0 + ((0.1 / ZoomRate) * ZoomTimer)
ex_audio_set_pitch("lowrumblezoom",CurrentZoomPitch,0)
ex_audio_set_volume("lowrumblezoom",CurrentZoomVol,0)

//Changing the x_view

BaseXView = ease_inout_sine(ZoomTimer,StartX,ChangeX,ZoomRate)
BaseYView = ease_inout_sine(ZoomTimer,StartY,ChangeY,ZoomRate)
view_wview[0] = ease_inout_sine(ZoomTimer,StartW,ChangeW,ZoomRate)
view_hview[0] = ease_inout_sine(ZoomTimer,StartH,ChangeH,ZoomRate)
if (instance_exists(mMoonVisible)) {
mMoonVisible.ZoomMod -= 2
}



} else {
SetVocalFalloff(600,2000)
CurrentViewNumber = 1
CurrentView = MicroView
BaseXView = ViewTargetX
BaseYView = ViewTargetY
view_xview[1] = ViewTargetX
view_yview[1] = ViewTargetY
view_visible[0] = false
view_visible[1] = true
WriteToLog("Changed to MicroView.")
UpdateZoomedListenerPosition()
view_xview[0] = OriginalMacroX
view_yview[0] = OriginalMacroY
view_wview[0] = OriginalMacroW
view_hview[0] = OriginalMacroH
CurrentHandUse = "none"
ex_audio_set_volume("lowrumblezoom",0,30)
ChangingView = false
}

} else if ChangingTo = "Macro" {
if ZoomTimer &lt; ZoomRate {
ZoomTimer += 1
if (instance_exists(mMoon)) {
mMoonVisible.ZoomMod += 2 
}
CurrentZoomPitch = BaseZoomPitch - ((0.2 / ZoomRate) * ZoomTimer)
CurrentZoomVol = 0 + ((0.2 / ZoomRate) * ZoomTimer)
ex_audio_set_pitch("lowrumblezoom",CurrentZoomPitch,0)
ex_audio_set_volume("lowrumblezoom",CurrentZoomVol,0)

//Changing the x_view

BaseXView = ease_inout_sine(ZoomTimer,StartX,ChangeX,ZoomRate)
BaseYView = ease_inout_sine(ZoomTimer,StartY,ChangeY,ZoomRate)
view_wview[1] = ease_inout_sine(ZoomTimer,StartW,ChangeW,ZoomRate)
view_hview[1] = ease_inout_sine(ZoomTimer,StartH,ChangeH,ZoomRate)
} else {
SetVocalFalloff(600,8000)
CurrentViewNumber = 0
CurrentView = MacroView
BaseXView = 0
BaseYView = ViewTargetY
view_xview[0] = 0
view_yview[0] = ViewTargetY
view_visible[1] = false
view_visible[0] = true
WriteToLog("Changed to MacroView.")
UpdateZoomedListenerPosition()
view_xview[1] = OriginalMicroX
view_yview[1] = OriginalMicroY
view_wview[1] = OriginalMicroW
view_hview[1] = OriginalMicroH
CurrentHandUse = "none"
ex_audio_set_volume("lowrumblezoom",0,30)
ChangingView = false
}
}
}

if ChangingView = false {
if ex_audio_is_playing("lowrumblezoom") {
if ex_audio_get_volume("lowrumblezoom") &lt;= 0 {
ex_audio_stop("lowrumblezoom")
}
}
}

//Moon Mod Zoom Mod



//Maintaining audio listener position depending on view.

switch CurrentViewNumber {
case 0:
UpdateZoomedOutListenerPosition();
break;
case 1:
UpdateZoomedListenerPosition();
break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Elemental Touch Controls 

//Create Mouse Object On Press

GrabBPReactions()
TabooInShotReactions()
RubCaulReaction()


if mouse_check_button_pressed(mb_any) and instance_exists(mFinger) = false {
instance_create(mouse_x,mouse_y,mFinger)

if instance_number(mScentMarker) &lt; 5 {
instance_create(mouse_x,mouse_y,mScentMarker)
} else {
CandidateMarker = instance_find(mScentMarker, irandom(instance_number(mScentMarker) - 1))
with CandidateMarker{instance_destroy()}
instance_create(mouse_x,mouse_y,mScentMarker)
}


mCreatureController.Dirt += 0.00005
}

if mouse_check_button_released(mb_any) {
if instance_number(mScentMarker) &lt; 5 {
instance_create(mouse_x,mouse_y,mScentMarker)
} else {
CandidateMarker = instance_find(mScentMarker, irandom(instance_number(mScentMarker) - 1))
with CandidateMarker{instance_destroy()}
instance_create(mouse_x,mouse_y,mScentMarker)
}
}

//Pressing
if mouse_check_button_pressed(mb_any) and PressBegun = false 
and PressFinished = false and LongPressFinished = false 
and mBehavioursDeliberative.PercentForward &gt; 70 {
if place_meeting(mFinger.x,mFinger.y,mFurSuperParent) {
TouchFurReactions()
}

mDriveCollectionMaster.TimeSinceLastTouch = 0
PressBegun = true
mDriveCollectionMaster.NoInteractionTimer = 0

if mCreatureController.NewTouch = false {
mCreatureController.NewTouchTimer = random_range(1000,2000)
}

mCreatureController.Dirt += 0.1

TouchNotNewReactions()

if position_meeting(mouse_x,mouse_y,oCaulCankerCentral) {
CankerTaps += 1
}
if position_meeting(mouse_x,mouse_y,mFurParent) or position_meeting(mouse_x,mouse_y,mFurBrowParent) or position_meeting(mouse_x,mouse_y,mFurCurledParent) {
FurTaps += 1
}
Taps += 1
TapReactions()
PressStatus = "pressing"
}

if PressBegun = false and PressFinished = false {
if TapTimer &gt; 0 {
TapTimer -= 1
} else if TapTimer &lt;= 0 {
Taps = 0
FurTaps = 0
CankerTaps = 0
}
}

if PressBegun = true and PressFinished = false  {
PressTimer += 1
PressReaction()
}

if mouse_check_button_released(mb_any) and PressBegun = true {
PressFinished = true
mInterfaceController.NoNewCut = false
PressFinishTimer = 2
PressBegun = false
DragBegun = false
if ex_audio_is_playing("liptouch") {
ex_audio_set_volume("liptouch",0,200)
}
if PressTimer &gt;= BruiseThreshold {
CauseBruise(LastX,LastY,0.6)
LastPressX = LastX
LastPressY = LastY
}
}

if PressFinished = true {
if PressTimer &gt; TapThreshold {
Taps = 0
}

if PressTimer &gt;= LongPressThreshold {
LongPressFinished = true
}

if PressFinishTimer &gt; 0 {
PressFinishTimer -=1
} else if PressFinishTimer &lt;= 0 {
PressStatus = "not pressing"
PressFinished = false
LongPressFinished = false
DragBegun = false
DragStatus = "not dragging"
DragDistance = 0
DragDirection = 0
DragStartX = 0
DragStartY = 0
DragSpeed = 0
PressTimer = 0
PressFinishTimer = 0
if Taps &gt; 0 {
TapTimer = 80
}
}
}


if PressBegun = true and point_distance(mouse_x,mouse_y,LastX,LastY) != 0 and DragBegun = false {
DragBegun = true
DragStatus = "dragging"
DragStartX = mouse_x
DragStartY = mouse_y
}


if DragBegun = true {

//Wet Drag Sound
if CurrentHandUse != "knife" and CurrentHandUse != "shave"
and CurrentHandUse != "plucking" and CurrentHandUse != "holding" 
and WillSlap = false
{

if position_meeting(mouse_x,mouse_y,mCreatureParent) and position_meeting(mouse_x,mouse_y,oCaulLip) = false and oSarahHead.PickedUp = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false and HandWet = true and oCaulNub.Gripped = false
and mFurController.Held = false {
if DragSpeed &gt; 0 {
if ex_audio_is_playing("wettouch") = false {
if (position_meeting(mouse_x,mouse_y,mFurParent) = false and
position_meeting(mouse_x,mouse_y,mFurBrowParent) = false and
position_meeting(mouse_x,mouse_y,mFurCurledParent) = false) {
ex_audio_set_volume("wettouch",BothVolMod(0.1),0)
} else {
ex_audio_set_volume("wettouch",BothVolMod(0.1),0)
ex_audio_set_pitch("wettouch",random_range(2,3),0)
ex_audio_play("wettouch",1)
}
} else if ex_audio_is_playing("wettouch") {
if ex_audio_is_paused("wettouch") {
ex_audio_resume("wettouch")
}
}
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("wettouch") = false {
ex_audio_pause("wettouch")
}
}
} else {
if ex_audio_is_playing("wettouch") {
ex_audio_stop("wettouch")
}
}


//Play Touching Skin Sound 
if position_meeting(mouse_x,mouse_y,mCreatureParent) and position_meeting(mouse_x,mouse_y,oCaulLip) = false and oSarahHead.PickedUp = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false and HandWet = false
and (
position_meeting(mouse_x,mouse_y,mFurParent) = false and
position_meeting(mouse_x,mouse_y,mFurBrowParent) = false and
position_meeting(mouse_x,mouse_y,mFurCurledParent) = false)
and mFurController.Held = false
and oCaulNub.Gripped = false {
if DragSpeed &gt; 0 {
if ex_audio_is_playing("skintouch") = false {
ex_audio_set_volume("skintouch",BothVolMod(0.1),0)
ex_audio_set_pitch("skintouch",random_range(2,3),0)
ex_audio_play("skintouch",1)
} else if ex_audio_is_playing("skintouch") {
if ex_audio_is_paused("skintouch") {
ex_audio_resume("skintouch")
}
}
ex_audio_set_volume("skintouch",BothVolMod(0.1),0)
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("skintouch") = false {
ex_audio_pause("skintouch")
}
}
} else {
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}


//---------------------------

if position_meeting(mouse_x,mouse_y,mFurSuperParent) 
and position_meeting(mouse_x,mouse_y,mCaulParent) = false
and HandWet = false
{
if DragSpeed &gt; 0 {
if ex_audio_is_playing("hairtouch") = false {
ex_audio_set_volume("hairtouch",BothVolMod(0.2),0)
ex_audio_set_pitch("hairtouch",random_range(0.8,0.9),0)
ex_audio_play("hairtouch",1)
} else if ex_audio_is_playing("hairtouch") {
if ex_audio_is_paused("hairtouch") {
ex_audio_resume("hairtouch")
}
}
ex_audio_set_volume("hairtouch",BothVolMod(0.1),0)
if mCreatureController.Alive &gt; 0 {
}
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("hairtouch") = false {
ex_audio_pause("hairtouch")
}
}
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
}
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}

if DragSpeed &gt; 10 {
CankerTaps = 0
FurTaps = 0
}

DragDirection = point_direction(LastX,LastY,mouse_x,mouse_y)
CurrentDir = point_direction(LastX,LastY,mouse_x,mouse_y)
DragSpeed = point_distance(LastX,LastY,mouse_x,mouse_y)
CurrentSpeed = point_distance(LastX,LastY,mouse_x,mouse_y)
CurrentSpeed = clamp(CurrentSpeed,0,SpeedMax)
DragSpeed = clamp(DragSpeed,0,SpeedMax)
DragDistance += DragSpeed
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}


LatestMouseAction = PressStatus + " for " + string(PressTimer) + " {tep{, " + string(Taps) + " tap{, " + DragStatus + " toward{ " + string(DragDirection) + " at " + string(DragSpeed) + " for " + string(DragDistance) + " pixel{."


if CurrentSpeed &gt; 0 {
if CurrentDir &gt;= 20 and CurrentDir &lt;= 160 {
VMove = "up"
} else if CurrentDir &gt; 200 and CurrentDir &lt;= 340 {
VMove = "down"
}
if CurrentDir &lt;= 70 and CurrentDir &gt;= -270 {
HMove = "right"
} else if CurrentDir &gt; 110 and CurrentDir &lt; 250 {
HMove = "left"
}
MoveSpeed = CurrentSpeed
} else {
MoveSpeed = CurrentSpeed
VMove = "none"
HMove = "none"
}

if DragBegun = false or place_meeting(mouse_x,mouse_y,mFurSuperParent) = false {
if DragFurTimer &gt; 0 {
DragFurTimer -= 0.4
}
}

DragFurTimer = clamp(DragFurTimer,0,200)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing Between Touch Contexts

if CurrentHandUse = "none" and instance_exists(mDebug) = false {

//Changing Zoom Level (Keyboard Or Ritual)
if keyboard_check_pressed(ord('Z'))
and mCreatureController.Alive &gt; 0
and position_meeting(mouse_x,mouse_y,mCreatureParent) 
and mBehavioursDeliberative.PercentForward &gt; 70
and instance_exists(mDebug) = false
{
StartZoom(50,mouse_x,mouse_y)
mInterfaceController.SSIntensity = 0
}

//Setting To Knife (Keyboard Or Ritual)
if keyboard_check_pressed(ord('K')) 
and CurrentHandUse != "knife" 
and mCreatureController.Alive &gt; 0
and mBehavioursDeliberative.PercentForward &gt;= 70 
and instance_exists(mDebug) = false {
WriteToLog("Hand is now knife.")
CurrentHandUse = "knife"
KnifeTimer = 360
}

//Setting To Shaving (Keyboard Or Rituals)
if (keyboard_check_pressed(ord('S')))
and CurrentHandUse != "shave" 
and instance_exists(mDebug) = false
and mCreatureController.Alive &gt; 0
and mBehavioursDeliberative.PercentForward &gt;= 70 {
CurrentHandUse = "shave"
WriteToLog("Hand is now shaving knife.")
ShaveTimer = 15
}          

//Dragging The Display (Keyboard Or Touchscreen)
if 
device_mouse_check_button_pressed(0,mb_any)
and keyboard_check(ord('D'))
and (position_meeting(mouse_x,mouse_y,mCreatureParent))
and HandWet = false
and instance_exists(mDebug) = false
and 
(
position_meeting(mouse_x,mouse_y,mFurParent) = false
and
position_meeting(mouse_x,mouse_y,mFurCurledParent) = false
and
position_meeting(mouse_x,mouse_y,mFurBrowParent) = false
and
position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false
and
position_meeting(mouse_x,mouse_y,sSigilMoleParent) = false
and 
SequenceBegun = false
and CurrentHandUse != "knife"
and CurrentHandUse != "shave"
and
(CurrentView = MacroView or (CurrentView = MicroView and
place_meeting(mFinger.x,mFinger.y,oWen) = false))
and
position_meeting(mouse_x,mouse_y,oHornLeft) = false
and
position_meeting(mouse_x,mouse_y,oHornRight) = false
and
position_meeting(mouse_x,mouse_y,oEyeballLeft) = false
and
position_meeting(mouse_x,mouse_y,oEyeballRight) = false
and
position_meeting(mouse_x,mouse_y,mCaulParent) = false
and
position_meeting(mouse_x,mouse_y,mCellarParent) = false
)
and CurrentHandUse = "none"
and instance_exists(mDebug) = false
and
(
mBehavioursDeliberative.PercentForward &gt; 60
and mBehavioursDeliberative.DisappearingActive = false
)
{
WriteToLog("Hand is now dragging view.")
CurrentHandUse = "drag"
DragX = mouse_x
DragY = mouse_y
OriginalDragX = DragX
OriginalDragY = DragY
}
}


if CurrentHandUse = "plucking" and mouse_check_button_released(mb_any) {
CurrentHandUse = "none"
}

if CurrentHandUse = "drag" and mouse_check_button_released(mb_any) {
CurrentHandUse = "none"
}


if CurrentHandUse = "knife" {

if mouse_check_button(mb_any) = false {
KnifeTimer -= 1
} 

if mouse_check_button(mb_any) = false and KnifeTimer &lt;= 0 {
CurrentHandUse = "none"
}

}

//Stop Holding Things If Let Go
if mouse_check_button_released(mb_any) and CurrentHandUse = "holding" {
CurrentHandUse = "none"
}

if CurrentHandUse = "shave" {
//Sometimes randomly change to knife when shaving if dragging too fast
if DragBegun = true and DragSpeed &gt; 40 {
KnifeOrNot = irandom_range(1,100)
if KnifeOrNot &gt; 90 {
CurrentHandUse = "knife"
}
}

//Stop Shaving If Enough Time Has Passed 
if ShaveTimer &lt;= 0 {
CurrentHandUse = "none"
}

if mouse_check_button(mb_any) = false {
ShaveTimer -= 1
}
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dragging View With One Finger

//If far enough forward and not disappearing...
if mBehavioursDeliberative.PercentForward &gt; 90 and mBehavioursDeliberative.DisappearingActive = false and mDriveCollectionMaster.InRitual = false
{
//If having started drag...
if CurrentHandUse = "drag" and mCreatureController.Alive &gt; 4 {
//-------------------------------------------------

/*
//CASE 1: Resistance is high enough, and still have some gumption left, and still alive...
if mCreatureController.Resistance &gt; 30 and ResistTimer &gt; 15  {

//Lower the gumption at a rate tied to Resistance.
ResistTimer -= (1 - ((0.5 / 100) * mCreatureController.Resistance))
//Shake the screen.
StartScreenShake(10,((10 / 100) * (100 - ResistTimer)),2)

//Make the creature hate you more, resist you less, have more pain, be less happy.
with mCreatureController {
BasePain += 0.08
BaseTrust -= 0.04
CloseToAnne += 0.01
SubIntent -= 0.0005
BaseTiredness += 0.008
BaseAlive -= 0.00003
BaseStress += 0.08
BaseLust += 0.05
}

ChangeEmotionStep("happy","down",0.3)
ChangeEmotionStep("sad","up",0.3)
ChangeEmotionStep("anger","down",0.3)
ChangeEmotionStep("shame","up",0.3)
ChangeEmotionStep("fear","up",0.3)
//A chance to vocalise.
VocaliseChance(1 + ((2/100) * (100 - ResistTimer)))
} else {

*/
//-------------------------------------------------
if mCreatureController.Alive &gt; 0 {
//CASE 2: Resistance has fallen enough, or gumption has fallen to its lowest ebb.
if mBehavioursDeliberative.PercentForward &lt; 100 {
//Firstly, come forward if not fully forward.
if mBehavioursDeliberative.MovingActive = false {
MoveBackForward("comeforward",30,100-mBehavioursDeliberative.PercentForward)
}
} else {
//If all of this is in place, then can come forward.
if device_mouse_check_button(0,mb_any) {

//The actual dragging tech.
BaseXView += (DragX - mouse_x) / 25
BaseYView += (DragY - mouse_y) / 25

//Put the resist time to its lowest level.
if ResistTimer &gt; 0 {
ResistTimer = 0
}

//Stop your x moving too far left or right, or up or down.
BaseXView = clamp(BaseXView,0,(room_width - view_wview[CurrentViewNumber]))
BaseYView = clamp(BaseYView,0,(room_height - view_hview[CurrentViewNumber]))
}
}
}
//}

//Stopping dragging criteria - opening Debug, letting go of the mouse, the creature moving back, touching wen in microview, touching canker, not touching creature,
//starting sequence, or touching horns, eyes, cauldron or cellar.
if mouse_check_button_released(mb_any)
or instance_exists(mDebug)
or mBehavioursDeliberative.PercentForward &lt; 100
or (position_meeting(mouse_x,mouse_y,oWen) and CurrentView = MicroView)
or position_meeting(mouse_x,mouse_y,oCaulCankerCentral)
or position_meeting(mouse_x,mouse_y,mCreatureParent) = false
or SequenceBegun = true
or position_meeting(mouse_x,mouse_y,oHornLeft) 
or position_meeting(mouse_x,mouse_y,oHornRight) 
or position_meeting(mouse_x,mouse_y,oEyeballLeft) 
or position_meeting(mouse_x,mouse_y,oEyeballRight) 
or position_meeting(mouse_x,mouse_y,mCaulParent) 
or position_meeting(mouse_x,mouse_y,mCellarParent) 
{
CurrentHandUse = "none"
}

}
}

//Slowly recharge ResistTimer if not dragging and resistance is high enough.
if ResistTimer &lt; 100 and CurrentHandUse != "drag"// and mCreatureController.Resistance &gt; 30
and mCreatureController.Alive &gt; 0 {
ResistTimer += 0.05 + (((0.05) / 100) * mCreatureController.Resistance)
}

ResistTimer = clamp(ResistTimer,0,100)



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Special Resistance 
/*
//-------------------------------------

if mBehavioursDeliberative.PercentForward &gt; 90 
and mBehavioursDeliberative.DisappearingActive = false 
and mCreatureController.Alive &gt; 0 
{
if CurrentHandUse = "drag" {
if view_yview[CurrentViewNumber] &gt; oTabooLayer3.y - view_hview[CurrentViewNumber] - 300 and mPlotController.TabooLayer3Broken = false
and mPlotController.TabooLayersActive = true
{

}
}
}



//ACTUAL PULLING AT 3 CODE - TO RE-DO.
/*
StartScreenShake(2,20)
BaseYView = clamp(BaseYView,0,oTabooLayer3.y - view_hview[CurrentViewNumber] - 300)
with mCreatureController {
BasePain += 0.05
BaseResistance -= 0.1
BaseTrust -= 0.1
CloseToAnne += 0.01
SubIntent -= 0.0005
BaseTiredness += 0.08
BaseAlive -= 0.00006
BaseStress += 0.08
BaseLust += 0.05
}
ChangeEmotionStep("happy","down",0.03)
ChangeEmotionStep("sad","up",0.03)
ChangeEmotionStep("anger","down",0.03)
ChangeEmotionStep("shame","up",0.03)
ChangeEmotionStep("fear","up",0.03)
VocaliseChance(1)
//if Chance(2) {
//MoveBackForward("retreat",irandom_range(20,30),irandom_range(30,50))
//}
StartCaulVibrateBehaviour(200)
if Chance(2) {
RandomTwitch()
}
*/


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stop View Going Past Taboo Layer (Hard Limit)
/*
if mCreatureController.Alive &gt; 0 {
if mPlotController.TabooLayersActive = true and mPlotController.AllTabooLayersBroken = false {
if mPlotController.TabooLayer1Broken = false {
ViewMax = mPlotController.TabooLayer1Y
} else if mPlotController.TabooLayer1Broken = true and mPlotController.TabooLayer2Broken = false {
ViewMax = mPlotController.TabooLayer2Y
} else if mPlotController.TabooLayer1Broken = true and mPlotController.TabooLayer2Broken = true and mPlotController.TabooLayer3Broken = false {
ViewMax = mPlotController.TabooLayer3Y + 100
} else if mPlotController.TabooLayer1Broken = true and mPlotController.TabooLayer2Broken = true and mPlotController.TabooLayer3Broken = true {
ViewMax = room_height
}
}
} else {
ViewMax = room_height
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Touching Wetness &amp; Smearing

//Get rid of item on player's hand if time has passed.
if HandWet = true {
if ResetTimer &gt; 0 {
ResetTimer -= 1
} else if ResetTimer &lt;= 0 {
HandWet = false
HandWetType = "none"
SmearAmount = 0
SmearAmountMax = 0
}
}

//Smearing with wet hand, keep it going for a while.
if position_meeting(mouse_x,mouse_y,mCreatureParent) 
and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false
and mBehavioursDeliberative.PercentForward &gt; 60 
and instance_exists(mDebug) = false
and place_meeting(mouse_x,mouse_y,mMouthParent) = false {
if instance_exists(mFinger) {
if HandWet = true {
if SmearAmount &gt; 0 {
if mouse_check_button_pressed(mb_any) {
SmearSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(SmearSound,mouse_x,mouse_y,1)
ex_audio_set_volume(SmearSound,BothVolMod(0.1),0)
ex_audio_set_pitch(SmearSound,random_range(2.3,2.7),0)
ex_audio_play(SmearSound,0)
CreateParticleSplash(mouse_x,mouse_y,sprite_get_width(mFinger) / 2,ps_shape_ellipse,ps_distr_gaussian,mInterfaceController.HandWetColour,15,30,0.03,0.08,0,360,30,80,5,20)
SmearLiquidReaction()
if HandWetType != "cleanpotion" {
mCreatureController.Dirt += 0.06
ThisSmear = instance_create(mouse_x,mouse_y,mSmear)
ThisSmear.image_blend = HandWetColour
}
} else if mouse_check_button(mb_any) {
if HandWetType != "cleanpotion" {
mCreatureController.Dirt += 0.06
ThisSmear = instance_create(mouse_x,mouse_y,mSmear)
ThisSmear.image_blend = HandWetColour
}
}
SmearAmount -= 1 
} else if SmearAmount &lt;= 0 {
WriteToLog("Smeared " + HandWetType + " on creature.")
HandWet = false
HandWetType = "none"
SmearAmount = 0
SmearAmountMax = 0
}
}
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mole Sequences

if SequenceBegun = false {
if PostDisplay = false and SigilSurfaceAlpha &lt;= 0 {
if mInterfaceController.CurrentView = MicroView and CurrentHandUse != "knife" and mCreatureController.Alive &gt; 0 {
if position_meeting(mouse_x,mouse_y,sSigilMoleParent) and mouse_check_button(mb_any) and instance_exists(mDebug) = false {
SequenceBegun = true

with sSigilMoleParent {
if position_meeting(mouse_x,mouse_y,self.id) and Occupied = true {
TouchSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(TouchSound,mouse_x,mouse_y,1)
ex_audio_set_pitch(TouchSound,random_range(0.8,1.2),0)
ex_audio_set_volume(TouchSound,BothVolMod(0.1),0)
ex_audio_play(TouchSound,0)
Touched = true
ShakeModX = 0
ShakeModMod = 0
CreateParticleSplash(x,y,7,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,0.03,0.05,0.03,0.06,30,150,40,80,0,20)
mInterfaceController.SequenceArray[mInterfaceController.NextSequencePos] = self.id
mInterfaceController.NextSequencePos = 1
mInterfaceController.CandidateSymbol = string(ID) + ","
mInterfaceController.LatestMole = self.id
mInterfaceController.LatestSigil = "drawing..."

WriteToLog("Begun mole sequence.")
}
}

if DrivesAreOn() {

if SequenceTimer &lt;= 0 {
ChangeEmotion("surprise","up",0.9,40)
LittleJump()
}

RandomTwitch()
RandomTwitch()

if IsInRitual() {
ChangeEmotion("anger","down",0.8,7)
ChangeEmotion("happy","up",0.9,7)
ChangeEmotion("sad","down",0.9,7)
MoveToXY(mouse_x,mouse_y,10,CurrentView,50)
if mBehavioursReactive.CaulVibrateActive = false {
StartCaulVibrateBehaviour(400)
}
} else {
ChangeEmotion("anger","up",0.8,7)
ChangeEmotion("happy","down",0.9,7)
ChangeEmotion("sad","up",0.9,7)
}
mCreatureController.BaseLust += 5
mCreatureController.BasePain += 5
ShiverChance(15)
VocaliseChance(10 + ((20 / 100) * mCreatureController.Resistance))
if Chance(0 + ((60 / 100) * (100 * mCreatureController.Triad))) {
EyeSquint(3,true,200)
}
}

SequenceTimer = irandom_range(500,1200)

SigilSurfaceAlpha = 1

ex_audio_set_pitch("lowrumblesigil",0.6,0)
ex_audio_set_volume("lowrumblesigil",0,0)
ex_audio_play("lowrumblesigil",true)
ex_audio_set_volume("lowrumblesigil",BothVolMod(0.3),20)
ex_audio_set_volume("sigilloop",0,0)
ex_audio_set_pitch("sigilloop",random_range(0.8,1.2),0)
}
}
}
} else if SequenceBegun = true {

SigilProgressReactions()

if DragBegun = true {
if ex_audio_is_playing("sigilloop") = false {
ex_audio_play("sigilloop",true)
ex_audio_set_volume("sigilloop",0.008,30)
} 
for (i = 0; i &lt; 30; i++) {
instance_create(mouse_x,mouse_y,mSigilStain)
}
} else {
if ex_audio_is_playing("sigilloop") {
ex_audio_stop("sigilloop")
}
}

CreateSigilStain(100,0,360,0.8,1.3,0.001,0.3,0.4,0.001,0.002,DebugRedTextColour,mouse_x,mouse_y)

part_emitter_region(SigilPartSys,SigilEmit,mouse_x - 10,mouse_x + 10,mouse_y - 10, mouse_y + 10, ps_shape_ellipse,ps_distr_gaussian)
part_emitter_burst(SigilPartSys,SigilEmit,SigilPart,10)

SigilBruiseAlpha += 0.0005

//Touching Other Moles
with sSigilMoleParent {
if position_meeting(mouse_x,mouse_y,self) and Touched = false and Occupied = true {
TouchSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(TouchSound,mouse_x,mouse_y,1)
ex_audio_set_pitch(TouchSound,random_range(0.8,1.2),0)
ex_audio_set_volume(TouchSound,BothVolMod(0.1),0)
ex_audio_play(TouchSound,0)
CreateParticleSplash(x,y,7,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,0.003,0.005,0.03,0.06,direction - 210,direction - 150,40,80,0,20)
TwitchRun(irandom_range(15,20))

mInterfaceController.SequenceArray[mInterfaceController.NextSequencePos] = self.id
mInterfaceController.NextSequencePos += 1
mInterfaceController.CandidateSymbol += string(ID) + ","
mInterfaceController.LatestMole = self.id
Touched = true
} 
}

//Stop The Sequence If Let Go.
if mouse_check_button_released(mb_any) {
ex_audio_stop("sigilloop")
ex_audio_set_volume("lowrumblesigil",0,100)
//Recognition Of Symbols
switch CandidateSymbol {
case TestSigil1:
mInterfaceController.LatestSigil = "test sigil 1"
WriteToLog("Sigil drawn: " + LatestSigil)
mCreatureController.BaseAlive += 0.5
break;
case TestSigil2:
mInterfaceController.LatestSigil = "test sigil 2"
WriteToLog("Sigil drawn: " + LatestSigil)
mCreatureController.BaseAlive += 0.5
break;
}
PostDisplay = true
Timer = 300
SequenceBegun = false
}
}

//Resetting the system.
if SequenceBegun = false and PostDisplay = false {
CandidateSymbol = ""
NextSequencePos = 0 
SequenceArray = 0
SequenceArray[0] = 0
mInterfaceController.LatestSigil = "none"
with sSigilMoleParent {
Touched = false
}
if SigilSurfaceAlpha &gt; 0 {
SigilSurfaceAlpha -= 0.001
}
if SigilBruiseAlpha &gt; 0 {
SigilBruiseAlpha -= 0.001
}
}

//Displaying the sigil after recognition.
if PostDisplay = true {
if Timer &gt; 0 {
Timer -= 1
SigilAlpha -= (0.3 / 300)
} else {
PostDisplay = false
NextSequencePos = 0
SequenceArray = 0
SequenceArray[0] = 0
Status = "none"
CandidateSymbol = ""
SigilAlpha = 0
with sSigilMoleParent {
Touched = false
}
}
}

if SequenceBegun = false {
if ex_audio_is_playing("lowrumblesigil") = true {
if ex_audio_get_volume("lowrumblesigil") &lt;= 0 {
ex_audio_stop("lowrumblesigil")
}
}
}


SigilBruiseAlpha = clamp(SigilBruiseAlpha,0,1)

if SequenceTimer &gt; 0 {
SequenceTimer -= 1
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wounding

if CurrentHandUse = "knife" 
and Wounding = false
and DrawingPath = false
and mouse_check_button_pressed(mb_any)
and instance_exists(mDebug) = false
and position_meeting(mouse_x,mouse_y,mCreatureParent)
and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false
and position_meeting(mouse_x,mouse_y,oStabWound) = false
and position_meeting(mouse_x,mouse_y,oWound) = false
and position_meeting(mouse_x,mouse_y,oEyeballLeft) = false
and position_meeting(mouse_x,mouse_y,oEyeballRight) = false
and position_meeting(mouse_x,mouse_y,mMouthParent) = false
and position_meeting(mouse_x,mouse_y,oWen) = false
and position_meeting(mouse_x,mouse_y,sSigilMoleParent) = false
and position_meeting(mouse_x,mouse_y,oCellarTop) = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false
and instance_exists(mFinger)
and mBehavioursDeliberative.PercentForward &gt;= 60
and NoNewCut = false
and ((mouse_x &gt; 221 and mouse_x &lt; 1141) and (mouse_y &gt; 600 and mouse_y &lt; 5199))
{
StartWounding()
mDriveCollectionMaster.CutReact = true
}

if Wounding = true {
StartScreenShake(1,8,1)

if DragBegun = true and DragSpeed &gt; 0 {
if ex_audio_is_paused(CutSound) {
ex_audio_resume(CutSound)
}
} else {
if ex_audio_is_playing(CutSound) {
ex_audio_pause(CutSound)
}
}

//Particles And Stains
CreateStain(10,0,360,15,25,0.3,0.05,0.1,0.1,0.2,DebugRedTextColour,mouse_x,mouse_y)
CreateParticleSplash(mFinger.x,mFinger.y,2,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,10,30,0.05,0.1,0,360,30,50,0.01,10)

//Increase Cut Distance &amp; Timer
CutDistance += point_distance(LastX,LastY,mFinger.x,mFinger.y)
ex_audio_set_pitch(CutSound,InitialPitch + ((0.1 / MaxCutLength) * CutDistance))
ex_audio_set_volume(CutSound,BothVolMod(0.8),1)
CutTimer += 1

//Add Points To Path
if CutTimer mod 3 = 0 {
path_add_point(ThisWoundPath,mFinger.x,mFinger.y,0)
}

if mouse_check_button_released(mb_any)
or position_meeting(mouse_x,mouse_y,mCreatureParent) = false
or position_meeting(mouse_x,mouse_y,oStabWound)
or position_meeting(mouse_x,mouse_y,oWound)
or position_meeting(mouse_x,mouse_y,oEyeballLeft)
or position_meeting(mouse_x,mouse_y,oEyeballRight)
or position_meeting(mouse_x,mouse_y,mMouthParent)
or position_meeting(mouse_x,mouse_y,mCellarParent)
or position_meeting(mouse_x,mouse_y,oCaulCankerCentral)
or (CuttingWhat = "skin" and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate))
or CutDistance &gt; MaxCutLength
or ((mouse_x &lt; 221 or mouse_x &gt; 1141) or (mouse_y &lt; 600 or mouse_y &gt; 5199))
{
EndCut()
}

if CuttingWhat = "cheekleft" {
if position_meeting(mouse_x,mouse_y,oCheekLeft) = false {
EndCut()
}
} else if CuttingWhat = "cheekright" {
if position_meeting(mouse_x,mouse_y,oCheekRight) = false {
EndCut()
}
} else if CuttingWhat = "browleft" {
if position_meeting(mouse_x,mouse_y,oBrowLeft) = false {
EndCut()
}
} else if CuttingWhat = "browright" {
if position_meeting(mouse_x,mouse_y,oBrowRight) = false {
EndCut()
}
} else if CuttingWhat = "tophead" {
if position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false {
EndCut()
}
} else if CuttingWhat = "nose" {
if position_meeting(mouse_x,mouse_y,oNose1) = false {
EndCut()
}
} else if CuttingWhat = "caulbowl" {
if position_meeting(mouse_x,mouse_y,oCaulBowl) = false {
EndCut()
}
} else if CuttingWhat = "cauljug" {
if position_meeting(mouse_x,mouse_y,oCaulJug) = false {
EndCut()
}
}
}

//Poking For Too Long Causes A Bruise
if PressBegun = true and mouse_check_button_released(mb_any) and PressTimer &gt; 300 and CurrentHandUse = "none" {
CauseBruise(LastX,LastY,5)
WriteToLog("Bruise caused.")
LastPressX = LastX
LastPressY = LastY
}




//Registering Slaps, Causing A Bruise And Possibly A Black Eye

if PotentialSlap = false {
if (instance_exists(mFinger) and place_meeting(mFinger.x,mFinger.y,mCreatureParent) = false)
and mouse_check_button_pressed(mb_any)
and CurrentView = MacroView
and CurrentHandUse = "none"
{
PotentialSlap = true
WillSlap = false
SlapWindow = 300
}
}

if PotentialSlap = true {
SlapWindow -= 1

if SlapWindow &lt;= 0 {
PotentialSlap = false
WillSlap = false
}

if DragSpeed &gt; 80 {
WillSlap = true
}

if WillSlap = true and DragSpeed &lt;= 0 {
WillSlap = false
}


if mouse_check_button_released(mb_any) {
if WillSlap = true and position_meeting(mouse_x,mouse_y,mCreatureParent) {
SlapSound = choose("slap1","slap2","slap3")
ex_audio_set_pitch(SlapSound,random_range(1.9,3.1),0)
ex_audio_set_volume(SlapSound,BothVolMod(0.2))
ex_audio_play(SlapSound,0)
StartScreenShake(irandom_range(50,70),irandom_range(15,20),irandom_range(5,10))
WriteToLog("Slapped.")

//REACTIONS

//Make eyes black
if point_distance(mouse_x,mouse_y,oEyeballLeft.x,oEyeballLeft.y) &lt; 70 {
oEyeballLeft.TargetBlackness = 0.9
} else if point_distance(mouse_x,mouse_y,oEyeballRight.x,oEyeballRight.y) &lt; 70 {
oEyeballRight.TargetBlackness = 0.9
}
if point_distance(mouse_x,mouse_y,oCheekLeft.x,oCheekLeft.y) &lt; 300 {
oCheekLeft.RednessTemp = 0.7
} else if point_distance(mouse_x,mouse_y,oCheekRight.x,oCheekRight.y) &lt; 300 {
oCheekRight.RednessTemp = 0.7
}

//Bruise &amp; Shake &amp; Twitches
if DrivesAreOn() {
CauseBruise(mouse_x,mouse_y,random_range(0.7,1.2))
TwitchIfNearBP(mouse_x,mouse_y,500)
TwitchIfNearBP(mouse_x,mouse_y,500)
TwitchIfNearBP(mouse_x,mouse_y,500)
StopVocalisation()
StopVocalPhrase()
StopYawnBehaviour()
StopSneezeBehaviour()
ChanceToWake(50)
StartBlinkBehaviour()
choose(StartEyebrowTwitchLeftBehaviour(),StartEyebrowTwitchRightBehaviour)
StartTwitchBehaviour(3,3,1)
choose(StartCheekTwitchLeftBehaviour(),StartCheekTwitchRightBehaviour())
choose(StartMouthSideLeftTwitchBehaviour(choose("down","up")),StartMouthSideRightTwitchBehaviour(choose("down","up")))


if SlapTimer &lt;= 0 {
LittleJump()
ChangeEmotion("surprise","up",0.6,10 + (40 * mCreatureController.Triad))
SlapTimer = irandom_range(10000,20000)
}

if mDriveCollectionMaster.InRitual = true {
if Chance(ChanceToRitualReact()){StartSniffBehaviour(20,20,1,1.2)}
if Chance(ChanceToRitualReact()){LittleJump()}
mDriveCollectionMaster.BaseBreathRate += 0.2
TwitchRun(irandom_range(20,40))
mCreatureController.BaseResistance -= 20
mCreatureController.BaseAlive -= 0.3
mCreatureController.BaseStress += 10
mCreatureController.BasePain += 10
mCreatureController.CloseToAnne += 10
ChangeEmotion("happy","up",0.3,10)
ChangeEmotion("fear","up",0.3,40)
if Chance(70) and mBehavioursDeliberative.PercentForward &lt; 100 {MoveBackForward("comeforward",30 - (15 * mCreatureController.Triad),100 - mBehavioursDeliberative.PercentForward)}

} else {

EmotionRequest()
if Chance(ChanceToRitualReact()){StartSniffBehaviour(20,20,1,1.2)}
if Chance(ChanceToRitualReact()){LittleJump()}
mDriveCollectionMaster.BaseBreathRate += 0.5
if Chance(70) {MoveBackForward("retreat",30 - ((15 / 100) * mCreatureController.Pain),10)}
TwitchRun(irandom_range(20,40))
ChangeEmotion("happy","down",0.4,30)
ChangeEmotion("shame","up",0.5,20 + (20 / mCreatureController.Triad))
ChangeEmotion("fear","up",0.5,30 - (20 / mCreatureController.Triad))
ChangeEmotion("anger","up",0.3,((35 / 100) * mCreatureController.Resistance))
mCreatureController.CloseToAnne -= 10
mCreatureController.SubIntent -= 0.1
mCreatureController.BaseResistance -= 20
mCreatureController.BaseTrust -= 20
mCreatureController.BaseLust -= 20
mCreatureController.BaseAlive -= 0.2
mCreatureController.BaseStress += 20
mCreatureController.BasePain += 10
mCreatureController.BaseTiredness -= 10
}
}
}
PotentialSlap = false
}
}

if SlapTimer &gt; 0 {
SlapTimer -= 1
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Counting Down Finger Light Time

if FingerLightOn = true {
if CurrentLightTime &gt; 0 {
CurrentLightTime -= 1
} else if CurrentLightTime &lt;= 0 {
CurrentLightTime = 0
FingerLightOn = false
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controlling Voice Master Pitch

BaseSoundPitch = 1 + mDriveCollectionMaster.RitualPitchMod
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ScreenShake &amp; Final Calculation Of X &amp; Y View &amp; Jumping

ScreenShake()

if Jumping = true {
if JumpDir = "up" {
if JumpMod &lt; JumpAmount {
JumpMod += 6
} else if JumpMod &gt;= JumpAmount {
JumpDir = "down" 
}
} else if JumpDir = "down" {
if JumpMod &gt; 0 {
JumpMod -= 6
} else if JumpMod &lt;= 0 {
JumpMod = 0
Jumping = false
}
}
}


//No floating if moving back and forward or moving to XY
if
mBehavioursDeliberative.XYMove = true or
mBehavioursDeliberative.MovingActive = true
or mCreatureController.Alive &lt;= 0
or CurrentView = MicroView
or IsInRitual()
or (instance_exists(oEarLeft) and oEarLeft.Pulling = true)
or (instance_exists(oEarRight) and oEarRight.Pulling = true)
{
Floating = false
} else {
Floating = true
}




if Floating = true {

//Start floating out in a direction
if FinishedFloatOut = false {

if FloatLength &lt; TotalFloatLength {
FloatLength += 0.5

//When you reach the end of the float out, turn around and come back.
} else {
FinishedFloatOut = true
}

} else {
FloatLength -= 0.5

//When back at centre, choose a new random direction and length (opposite)
if FloatLength &lt;= 0 {
if FloatDir = "left" {
FloatDir = "right"
} else {
FloatDir = "left"
}

if FloatDir = "left" {
FloatComp = irandom_range(-45,45)
} else {
FloatComp = irandom_range(135,215)
}

FloatTotalLength = irandom_range(50,100)
FloatLength = 0
FinishedFloatOut = false
}

}

} else {
FinishedFloatOut = false
FloatDir = "left"

if FloatLength &gt; 0 {
FloatLength -= 1
}
}


//Add to the two FloatMods, in the right direction, at the right speed.

FloatModX = lengthdir_x(FloatLength,FloatComp)
FloatModY = lengthdir_y(FloatLength,FloatComp)

FloatLength = clamp(FloatLength,0,200)


BreathYMod = clamp(BreathYMod,0,100)

if CurrentView = MicroView {
view_xview[1] = BaseXView + ShakeMod + FloatModX + mDriveCollectionMaster.RitualModX
view_yview[1] = BaseYView + (BreathYMod / 3) + JumpMod - SlipMod - DeadMod - mBehavioursReactive.SleepDroopYCurrent + FloatModY
} else if CurrentView = MacroView {
view_xview[0] = BaseXView + ShakeMod + FloatModX + mDriveCollectionMaster.RitualModX
view_yview[0] = BaseYView + (BreathYMod / 2) + JumpMod - SlipMod - DeadMod - mBehavioursReactive.SleepDroopYCurrent + FloatModY 
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Close Eavesdrop And Pareidolia

CloseEavesdropAndPareidolia()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw The Sigil Surface



SigilSurfaceX = oHead1.x - 120
SigilSurfaceY = oHead1.y - 388

draw_sprite_ext(sSigilBruise,0,SigilSurfaceX,SigilSurfaceY,1,1,0,c_white,SigilBruiseAlpha)

if !surface_exists(SigilSurface) {
SigilSurface = surface_create(301,298)
}

if SigilSurfaceAlpha &lt;= 0 {
surface_set_target(SigilSurface)
draw_clear_alpha(c_black,0)
surface_reset_target()
} 

draw_surface_ext(SigilSurface,SigilSurfaceX,SigilSurfaceY,1,1,0,c_white,SigilSurfaceAlpha)




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
