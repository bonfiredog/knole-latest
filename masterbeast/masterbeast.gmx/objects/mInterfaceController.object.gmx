<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sMicVolumePlaceholderSprite</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

depth = HeadSkinLayer - 0.0001
x = ControllerObjectX
y = ControllerObjectY

//Views

CurrentView = MacroView
CurrentViewNumber = 0
ChangingView = false
MovingOut = false

OriginalDragY = 0
OriginalDragX = 0

WinksToRun = 0

OriginalMacroX = 0
OriginalMacroY = 1000
OriginalMacroW = 1400
OriginalMacroH = 1920
OriginalMicroX = 0
OriginalMicroY = 0
OriginalMicroW = 360
OriginalMicroH = 640

SlapDir = -1
SlapToMove = 0
SlapMove = false
CurrentSlapAmount = 0

DragSlowdown = 0

MovingBackAfter = false
MovingBackSteps = 0
MovingBackAmount = 0
MovingBackAfterCapped = false

ChangingTo = "none"

ScreenShaking = false
ShakeMod = 0

BaseXView = OriginalMacroX
BaseYView = OriginalMacroY

ResistMasterTimer = 100

CursorInGame = false
window_set_cursor(cr_none)
SigilCapture = false
ShapeToCheck = 0
CurrentHandUse = "none"

CleaningTimer = 0
Healing = false
HealingTimer = 0

DragX = 0
DragY = 0

Direction = "none"

LastX = 0
LastY = 0

NoNewCut = false
BruisePressTimer = 0
ResetKnifeOnLift = true

ShaveTimer = 0

HeadViewTriggerY = 810
TopHeadViewModMax = HeadViewTriggerY - 200 

//Touch Properties

PressBegun = false
PressFinished = false
LongPressFinished = false
LongPressThreshold = 80
PressTimer = 0
PressFinishTimer = 0

TryingToGoDown1 = false
TryingToGoDown2 = false

DragBegun = false
DragDistance = 0
DragDirection = 0
DragStartX = 0
DragStartY = 0
DragSpeed = 0
DragFurTimer = 0

DragStatus = "not dragging"
PressStatus = "not pressing"

VMove = "none"
HMove = "none"
MoveSpeed = 0
DisplayHMove = HMove
DisplayVMove = VMove
DisplaySpeed = MoveSpeed
alarm[0] = 10
SpeedMax = 100
CurrentSpeed = 0
CurrentDir = 0

Taps = 0
TapTimer = 0
TapThreshold = 15

HandWet = false
HandWetType = "none"

Smearing = false

ResetReadyStage = 0

ViewMax = mPlotController.TabooLayer1Y

ZoomedInTimer = 0

FingerObjectVisible = false

LatestMouseAction = "none"
LatestSigil = "none"

ResetTimer = 0

//Sigils

TestSigil1 = "18,16,17,14,9,3,4,10,15,"
TestSigil2 = "1,2,8,9,3,12,13,14,15,10,4,"

SequenceBegun = false
SequenceArray[0] = 0
NextSequencePos = 0
CandidateSymbol = ""
PostDisplay = false
LatestMole = noone
SigilSurface = surface_create(345,290)
SigilSurfaceAlpha = 0

LoadAudioEngine()

SigilPartSys = part_system_create()

//Define Different Particles Based On Liquid Type
SigilPart = part_type_create()
part_type_sprite(SigilPart,sSigilPart,1,0,0)
part_type_size(SigilPart,0.05,0.08,-0.01,0.01)
part_type_colour1(SigilPart,c_black)
part_type_alpha1(SigilPart,0.9)
part_type_speed(SigilPart,1,3,0,0)
part_type_direction(SigilPart,0,359,0,0)
part_type_gravity(SigilPart,0.3,270)
part_type_blend(SigilPart,0)
part_type_life(SigilPart,15,30)

SigilEmit = part_emitter_create(SigilPartSys)
SigilAlpha = 0

//Wounding

Wounding = false
CuttingWhat = "none"
MaxCutLength = 150
CutStartX = 0
CutStartY = 0
CutDistance = 0
DrawingPath = false
CutTimer = 0
ThisWoundPath = path_add()
path_set_kind(ThisWoundPath,1)
path_set_precision(ThisWoundPath,8)
path_set_closed(ThisWoundPath, false)
MaxCuts = 20
GrabbingBodyPart = false
BruiseThreshold = 120
PotentialSlap = false
WillSlap = false
HeardVeloc = false
VelocTimer = 0


//Finger
FingerLightOn = false
LightTime = 500
CurrentLightTime = LightTime
LightRadBase = 4

LastPressX = 500
LastPressY = 800

Slapped = false

//Zooming &amp; Dragging
ZoomRate = 50
ViewTargetX = 0
ViewTargetY = 0
ZoomTimer = 0
ViewXDiff = 0
ViewYDiff = 0

DragReset = true
DragTimer = 0
DragTimerInitial = 100
DragDistance = 0
DragResist = 0
PhraseMoving = false

alarm[1] = 5

BreathYMod = 0

PotentialSlap = false
KnifeTimer = 0

ResistTimer = 0

SigilBruiseAlpha = 0

Jumping = false
JumpMod = 0
SlipMod = 0
CutReact = 0
CutReactOut = 0

SlapTimer = 0
FurTaps = 0
CankerTaps = 0

SmearAmount = 0

SequenceTimer = 0

DeadMod = 0

Faces = 0

LiquidPlaces = ds_list_create()

CaulSenLead = 10
CaulSenBowl = 35
CaulSenJug = 60
CaulSenLip = 80
CaulSenNub = 100

SSSideTime = 0
SSIntensity = 0

//Floating
Floating = true
FloatLength = 0
FloatDir = "left"
FinishedFloatOut = false
FloatComp = irandom_range(-45,45)
TotalFloatLength = irandom_range(50,100)

Cleaning = false

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivations

//Cankers
with oCaulCankerCentral {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

//Sigil Moles
with sSigilMoleParent {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

//Wens
with oWen {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oPlotWound2 {
if sprite_index != sMoleHoleHealed {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
} else {
if ( (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
) or (mInterfaceController.CurrentViewNumber = 0) {
instance_deactivate_object(self) 
}
}
}

with oPlotWound3 {
if (x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oFloaterRight {
if 
(x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

with oFloaterLeft {
if 
(x &lt; view_xview[mInterfaceController.CurrentViewNumber])
or (y &lt; view_yview[mInterfaceController.CurrentViewNumber])
or (y &gt; (view_yview[mInterfaceController.CurrentViewNumber] + view_hview[mInterfaceController.CurrentViewNumber]))
or (x &gt; (view_xview[mInterfaceController.CurrentViewNumber] + view_wview[mInterfaceController.CurrentViewNumber]))
{
instance_deactivate_object(self)
}
}

instance_activate_region(view_xview[mInterfaceController.CurrentViewNumber],view_yview[mInterfaceController.CurrentViewNumber],view_wview[mInterfaceController.CurrentViewNumber],view_hview[mInterfaceController.CurrentViewNumber],true)

with oFloaterRight {
if mInterfaceController.CurrentView = MacroView
{
instance_deactivate_object(self)
}
}

with oFloaterLeft {
if mInterfaceController.CurrentView = MacroView
{
instance_deactivate_object(self)
}
}

alarm[1] = 5
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Mouse Speed At Sane Intervals

DisplayHMove = HMove
DisplayVMove = VMove
DisplaySpeed = MoveSpeed

alarm[0] = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Find Last X And Y

if instance_exists(mFinger) {
LastX = mFinger.x
LastY = mFinger.y
} else {
LastX = mouse_x
LastY = mouse_y
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>mInterfaceController</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing From MicroView To MacroView

if ChangingView = true {
//Swap the view numbers and write to log.
//Change To Micro

if ChangingTo = "Micro" {
if ZoomTimer &lt; ZoomRate {
ZoomTimer += 1

CurrentZoomPitch = BaseZoomPitch + ((0.05 / ZoomRate) * ZoomTimer)
CurrentZoomVol = 0 + ((0.1 / ZoomRate) * ZoomTimer)
ex_audio_set_pitch("lowrumblezoom",CurrentZoomPitch,0)
ex_audio_set_volume("lowrumblezoom",CurrentZoomVol,0)

//Changing the x_view

BaseXView = ease_inout_sine(ZoomTimer,StartX,ChangeX,ZoomRate)
BaseYView = ease_inout_sine(ZoomTimer,StartY,ChangeY,ZoomRate)
view_wview[0] = ease_inout_sine(ZoomTimer,StartW,ChangeW,ZoomRate)
view_hview[0] = ease_inout_sine(ZoomTimer,StartH,ChangeH,ZoomRate)
if (instance_exists(mMoonVisible)) {
mMoonVisible.ZoomMod -= 2
}



} else {
SetVocalFalloff(500,2000)
CurrentViewNumber = 1
CurrentView = MicroView
BaseXView = ViewTargetX
BaseYView = ViewTargetY
view_xview[1] = ViewTargetX
view_yview[1] = ViewTargetY
view_visible[0] = false
view_visible[1] = true
WriteToLog("Changed to MicroView.")
UpdateZoomedListenerPosition()
view_xview[0] = OriginalMacroX
view_yview[0] = OriginalMacroY
view_wview[0] = OriginalMacroW
view_hview[0] = OriginalMacroH
CurrentHandUse = "none"
ex_audio_set_volume("lowrumblezoom",0,30)
ChangingView = false
}

} else if ChangingTo = "Macro" {
if ZoomTimer &lt; ZoomRate {
ZoomTimer += 1
if (instance_exists(mMoon)) {
mMoonVisible.ZoomMod += 2 
}
CurrentZoomPitch = BaseZoomPitch - ((0.2 / ZoomRate) * ZoomTimer)
CurrentZoomVol = 0 + ((0.2 / ZoomRate) * ZoomTimer)
ex_audio_set_pitch("lowrumblezoom",CurrentZoomPitch,0)
ex_audio_set_volume("lowrumblezoom",CurrentZoomVol,0)

//Changing the x_view

BaseXView = ease_inout_sine(ZoomTimer,StartX,ChangeX,ZoomRate)
BaseYView = ease_inout_sine(ZoomTimer,StartY,ChangeY,ZoomRate)
view_wview[1] = ease_inout_sine(ZoomTimer,StartW,ChangeW,ZoomRate)
view_hview[1] = ease_inout_sine(ZoomTimer,StartH,ChangeH,ZoomRate)
} else {
SetVocalFalloff(500,5000)
CurrentViewNumber = 0
ZoomedInTimer = 0
CurrentView = MacroView
BaseXView = 0
BaseYView = ViewTargetY
view_xview[0] = 0
view_yview[0] = ViewTargetY
view_visible[1] = false
view_visible[0] = true
WriteToLog("Changed to MacroView.")
UpdateZoomedListenerPosition()
view_xview[1] = OriginalMicroX
view_yview[1] = OriginalMicroY
view_wview[1] = OriginalMicroW
view_hview[1] = OriginalMicroH
CurrentHandUse = "none"
ex_audio_set_volume("lowrumblezoom",0,30)
ChangingView = false
}
}
} else {
if MovingBackAfter = true {

with mBehavioursDeliberative {
if MovingActive = false  {
MovingActive = true
}

WriteToLog("Moved back or forward.")
MovingDir = "retreat"
MovingTimer = 0
MovingSpeed = mInterfaceController.MovingBackSteps
MoveCalc = false

if mInterfaceController.MovingBackAfterCapped = true {
if PercentForward &lt;= 50 {
MovingChange = 0
} else if PercentForward &gt; 50 {
if mInterfaceController.MovingBackAmount &gt; (PercentForward - 50) {
MovingChange = (PercentForward - 50)
} else {
MovingChange = mInterfaceController.MovingBackAmount
}
}
} else {
MovingChange = mInterfaceController.MovingBackAmount
}
mInterfaceController.MovingBackAfter = false
mInterfaceController.MovingBackSteps = 0
mInterfaceController.MovingBackAmount = 0
mInterfaceController.MovingBackAfterCapped = false
}
}
}

if ChangingView = false {
if ex_audio_is_playing("lowrumblezoom") {
if ex_audio_get_volume("lowrumblezoom") &lt;= 0 {
ex_audio_stop("lowrumblezoom")
}
}
}

//Moon Mod Zoom Mod



//Maintaining audio listener position depending on view.

switch CurrentViewNumber {
case 0:
UpdateZoomedOutListenerPosition();
break;
case 1:
UpdateZoomedListenerPosition();
break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Elemental Touch Controls 

//Create Mouse Object On Press

GrabBPReactions()
TabooInShotReactions()
RubCaulReaction()


if mouse_check_button_pressed(mb_any) and instance_exists(mFinger) = false {
instance_create(mouse_x,mouse_y,mFinger)

if instance_number(mScentMarker) &lt; 5 {
instance_create(mouse_x,mouse_y,mScentMarker)
} else {
CandidateMarker = instance_find(mScentMarker, irandom(instance_number(mScentMarker) - 1))
with CandidateMarker{instance_destroy()}
instance_create(mouse_x,mouse_y,mScentMarker)
}


mCreatureController.Dirt += 0.00005
}

if mouse_check_button_released(mb_any) {
if instance_number(mScentMarker) &lt; 5 {
instance_create(mouse_x,mouse_y,mScentMarker)
} else {
CandidateMarker = instance_find(mScentMarker, irandom(instance_number(mScentMarker) - 1))
with CandidateMarker{instance_destroy()}
instance_create(mouse_x,mouse_y,mScentMarker)
}
}

//Pressing
if mouse_check_button_pressed(mb_any) and PressBegun = false 
and PressFinished = false and LongPressFinished = false 
and mBehavioursDeliberative.PercentForward &gt; 70 {
if place_meeting(mFinger.x,mFinger.y,mFurSuperParent) {
TouchFurReactions()
}
PressBegun = true
mDriveCollectionMaster.NoInteractionTimer = 0

if mCreatureController.NewTouch = false {
mCreatureController.NewTouchTimer = random_range(1000,2000)
}

mCreatureController.Dirt += 0.1

TouchNotNewReactions()

if position_meeting(mouse_x,mouse_y,oCaulCankerCentral) {
CankerTaps += 1
}
if position_meeting(mouse_x,mouse_y,mFurParent) or position_meeting(mouse_x,mouse_y,mFurBrowParent) or position_meeting(mouse_x,mouse_y,mFurCurledParent) {
FurTaps += 1
}
Taps += 1
TapReactions()
PressStatus = "pressing"
}

if PressBegun = false and PressFinished = false {
if TapTimer &gt; 0 {
TapTimer -= 1
} else if TapTimer &lt;= 0 {
Taps = 0
FurTaps = 0
CankerTaps = 0
}
}

if PressBegun = true and PressFinished = false  {
PressTimer += 1
PressReaction()
}

if mouse_check_button_released(mb_any) and PressBegun = true {
PressFinished = true
mInterfaceController.NoNewCut = false
PressFinishTimer = 2
PressBegun = false
DragBegun = false
if ex_audio_is_playing("liptouch") {
ex_audio_set_volume("liptouch",0,200)
}
if PressTimer &gt;= BruiseThreshold {
CauseBruise(LastX,LastY,0.6)
LastPressX = LastX
LastPressY = LastY
}
}

if PressFinished = true {
if PressTimer &gt; TapThreshold {
Taps = 0
}

if PressTimer &gt;= LongPressThreshold {
LongPressFinished = true
}

if PressFinishTimer &gt; 0 {
PressFinishTimer -=1
} else if PressFinishTimer &lt;= 0 {
PressStatus = "not pressing"
PressFinished = false
LongPressFinished = false
DragBegun = false
DragStatus = "not dragging"
DragDistance = 0
DragDirection = 0
DragStartX = 0
DragStartY = 0
DragSpeed = 0
PressTimer = 0
PressFinishTimer = 0
if Taps &gt; 0 {
TapTimer = 80
}
}
}


if PressBegun = true and point_distance(mouse_x,mouse_y,LastX,LastY) != 0 and DragBegun = false {
DragBegun = true
DragStatus = "dragging"
DragStartX = mouse_x
DragStartY = mouse_y
}


if DragBegun = true {

//Wet Drag Sound
if CurrentHandUse != "knife" and CurrentHandUse != "shave"
and CurrentHandUse != "plucking" and CurrentHandUse != "holding" 
and WillSlap = false
{

if position_meeting(mouse_x,mouse_y,mCreatureParent) and position_meeting(mouse_x,mouse_y,oCaulLip) = false and oSarahHead.PickedUp = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false and HandWet = true and oCaulNub.Gripped = false
and mFurController.Held = false {
if DragSpeed &gt; 0 {
if ex_audio_is_playing("wettouch") = false {
if (position_meeting(mouse_x,mouse_y,mFurParent) = false and
position_meeting(mouse_x,mouse_y,mFurBrowParent) = false and
position_meeting(mouse_x,mouse_y,mFurCurledParent) = false) {
ex_audio_set_volume("wettouch",BothVolMod(0.1),0)
} else {
ex_audio_set_volume("wettouch",BothVolMod(0.1),0)
ex_audio_set_pitch("wettouch",random_range(2,3),0)
ex_audio_play("wettouch",1)
}
} else if ex_audio_is_playing("wettouch") {
if ex_audio_is_paused("wettouch") {
ex_audio_resume("wettouch")
}
}
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("wettouch") = false {
ex_audio_pause("wettouch")
}
}
} else {
if ex_audio_is_playing("wettouch") {
ex_audio_stop("wettouch")
}
}


//Play Touching Skin Sound 
if position_meeting(mouse_x,mouse_y,mCreatureParent) and position_meeting(mouse_x,mouse_y,oCaulLip) = false and oSarahHead.PickedUp = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false and HandWet = false
and (
position_meeting(mouse_x,mouse_y,mFurParent) = false and
position_meeting(mouse_x,mouse_y,mFurBrowParent) = false and
position_meeting(mouse_x,mouse_y,mFurCurledParent) = false)
and mFurController.Held = false
and oCaulNub.Gripped = false {
if DragSpeed &gt; 0 {
if ex_audio_is_playing("skintouch") = false {
ex_audio_set_volume("skintouch",BothVolMod(0.1),0)
ex_audio_set_pitch("skintouch",random_range(2,3),0)
ex_audio_play("skintouch",1)
} else if ex_audio_is_playing("skintouch") {
if ex_audio_is_paused("skintouch") {
ex_audio_resume("skintouch")
}
}
ex_audio_set_volume("skintouch",BothVolMod(0.1),0)
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("skintouch") = false {
ex_audio_pause("skintouch")
}
}
} else {
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}


//---------------------------

if position_meeting(mouse_x,mouse_y,mFurSuperParent) 
and position_meeting(mouse_x,mouse_y,mCaulParent) = false
and HandWet = false
{
if DragSpeed &gt; 0 {
if ex_audio_is_playing("hairtouch") = false {
ex_audio_set_volume("hairtouch",BothVolMod(0.2),0)
ex_audio_set_pitch("hairtouch",random_range(0.8,0.9),0)
ex_audio_play("hairtouch",1)
} else if ex_audio_is_playing("hairtouch") {
if ex_audio_is_paused("hairtouch") {
ex_audio_resume("hairtouch")
}
}
ex_audio_set_volume("hairtouch",BothVolMod(0.1),0)
if mCreatureController.Alive &gt; 0 {
}
} else if DragSpeed &lt;= 0 {
if ex_audio_is_paused("hairtouch") = false {
ex_audio_pause("hairtouch")
}
}
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
}
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}

if DragSpeed &gt; 10 {
CankerTaps = 0
FurTaps = 0
}

DragDirection = point_direction(LastX,LastY,mouse_x,mouse_y)
CurrentDir = point_direction(LastX,LastY,mouse_x,mouse_y)
DragSpeed = point_distance(LastX,LastY,mouse_x,mouse_y)
CurrentSpeed = point_distance(LastX,LastY,mouse_x,mouse_y)
CurrentSpeed = clamp(CurrentSpeed,0,SpeedMax)
DragSpeed = clamp(DragSpeed,0,SpeedMax)
DragDistance += DragSpeed
} else {
if ex_audio_is_playing("hairtouch") {
ex_audio_stop("hairtouch")
}
if ex_audio_is_playing("skintouch") {
ex_audio_stop("skintouch")
}
}


LatestMouseAction = PressStatus + " for " + string(PressTimer) + " {tep{, " + string(Taps) + " tap{, " + DragStatus + " toward{ " + string(DragDirection) + " at " + string(DragSpeed) + " for " + string(DragDistance) + " pixel{."


if CurrentSpeed &gt; 0 {
if CurrentDir &gt;= 20 and CurrentDir &lt;= 160 {
VMove = "up"
} else if CurrentDir &gt; 200 and CurrentDir &lt;= 340 {
VMove = "down"
}
if CurrentDir &lt;= 70 and CurrentDir &gt;= -270 {
HMove = "right"
} else if CurrentDir &gt; 110 and CurrentDir &lt; 250 {
HMove = "left"
}
MoveSpeed = CurrentSpeed
} else {
MoveSpeed = CurrentSpeed
VMove = "none"
HMove = "none"
}

if DragBegun = false or place_meeting(mouse_x,mouse_y,mFurSuperParent) = false {
if DragFurTimer &gt; 0 {
DragFurTimer -= 0.4
}
}

DragFurTimer = clamp(DragFurTimer,0,200)

//BruiseTimer 
if mouse_check_button(mb_any) and position_meeting(mouse_x,mouse_y,mCreatureParent)
and DragSpeed &lt; 2
{
BruisePressTimer += 1
} else {
if BruisePressTimer &gt; 0 {
BruisePressTimer -= 1
}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing Between Touch Contexts

if instance_exists(mDebug) = false {

//Changing Zoom Level (Keyboard Or Ritual)
if keyboard_check_pressed(ord('Z'))
and mCreatureController.Alive &gt; 0
and position_meeting(mouse_x,mouse_y,mCreatureParent) 
and mBehavioursDeliberative.PercentForward &gt; 70
and instance_exists(mDebug) = false
and mInterfaceController.ChangingView = false
{
StartZoom(ZoomSpeedCalc(),mouse_x,mouse_y)
mInterfaceController.SSIntensity = 0
}

//Setting To Knife (Keyboard Or Ritual)
if keyboard_check_pressed(ord('K')) 
and CurrentHandUse != "knife" 
and mCreatureController.Alive &gt; 0
and mBehavioursDeliberative.PercentForward &gt;= 70 
and instance_exists(mDebug) = false {
WriteToLog("Hand is now knife.")
CurrentHandUse = "knife"
KnifeTimer = 360
ResetKnifeOnLift = true
}

//Setting To Shaving (Keyboard Or Rituals)
if (keyboard_check_pressed(ord('S')))
and CurrentHandUse != "shave" 
and instance_exists(mDebug) = false
and mCreatureController.Alive &gt; 0
and mBehavioursDeliberative.PercentForward &gt;= 70 {
CurrentHandUse = "shave"
WriteToLog("Hand is now shaving knife.")
ShaveTimer = 7000
}          

//Dragging The Display (Keyboard Or Touchscreen)
if 
keyboard_check(ord('D'))
and instance_exists(mDebug) = false
and SequenceBegun = false
and CurrentHandUse != "knife"
and CurrentHandUse != "shave" and
(
mBehavioursDeliberative.PercentForward &gt; 60
and mBehavioursDeliberative.DisappearingActive = false
) {
if CurrentHandUse != "drag" {
StartDraggingMode()
} else {
CurrentHandUse = "none"
DragTimer = 0
}
}
}



if CurrentHandUse = "plucking" and mouse_check_button_released(mb_any) {
CurrentHandUse = "none"
}

if CurrentHandUse = "knife" {

if mouse_check_button(mb_any) = false {
KnifeTimer -= 1
} 

if mouse_check_button(mb_any) = false and KnifeTimer &lt;= 0 {
CurrentHandUse = "none"
}

}

//Stop Holding Things If Let Go
if mouse_check_button_released(mb_any) and CurrentHandUse = "holding" {
CurrentHandUse = "none"
}

if CurrentHandUse = "shave" {
//Sometimes randomly change to knife when shaving if dragging too fast
if DragBegun = true and DragSpeed &gt; 40 {
KnifeOrNot = irandom_range(1,100)
if KnifeOrNot &gt; 97 {
StartWounding()
with oMoleHerd {
State = "shivering"
ShiverTimer = random_range(30,100)
}
mDriveCollectionMaster.CutReact = true
}
}

//Stop Shaving If Enough Time Has Passed 
if ShaveTimer &lt;= 0 {
CurrentHandUse = "none"
}

if mouse_check_button(mb_any) = false {
ShaveTimer -= 1
}
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dragging View With One Finger

//If far enough forward and not disappearing...
if mBehavioursDeliberative.PercentForward &gt; 90 and mBehavioursDeliberative.DisappearingActive = false 
{

//If having started drag...
if CurrentHandUse = "drag" and mCreatureController.Alive &gt; 4 {
//-------------------------------------------------

DragSlowdown = 0.1
+ ((0.02 / 100) * mCreatureController.Lust)
- ((0.02 / 100) * mCreatureController.Tiredness)
- ((0.02 / 100) * mCreatureController.Pain)
- ((0.02 / 100) * mCreatureController.Stress)
+ ((0.02 / 100) * mCreatureController.CloseToAnne)
+ (0.02 * mCreatureController.Triad)
- ((0.03 / 100) * mCreatureController.Resistance)
+ (0.02 * IsInRitual())

DragSlowdown = clamp(DragSlowdown,0.01,0.3)

if mouse_check_button_pressed(mb_any) {
DragX = mouse_x
DragY = mouse_y
OriginalDragX = DragX
OriginalDragY = DragY
}
}
}

//Dragging
if mouse_check_button(mb_any) and position_meeting(mouse_x,mouse_y,mCreatureParent) 
and position_meeting(mouse_x,mouse_y,sSigilMoleParent) = false
and instance_exists(mDebug) = false
and ChangingView = false
and position_meeting(mouse_x,mouse_y,oCaulLiquid) = false
and Cleaning = false
and Healing = false
and position_meeting(mouse_x,mouse_y,oCaulNub) = false
and position_meeting(mouse_x,mouse_y,oHornLeft) = false
and position_meeting(mouse_x,mouse_y,oHornRight) = false
{
TwitchIfNearBP(mouse_x,mouse_y,300)

//TabooLayer1
//If the taboo layer is still healthy...
if oTabooLayer1.Health &gt; 0 {
//...And if you are trying to drag the view LOWER than that...
if 
((CurrentView = MacroView and view_yview[0] &gt; (oTabooLayer1.y - view_hview[0]))
or 
(CurrentView = MicroView and view_yview[1] &gt; (oTabooLayer1.y - view_hview[1])))
and mouse_y &lt; OriginalDragY
{
//Stop you dragging any further.
oTabooLayer1.Health -= 0.0005
TryingToGoDown1 = true
//React Against It
TryingToGoDownReactions(oTabooLayer1)
} else {
TryingToGoDown1 = false
}
} else {
TryingToGoDown1 = false
}

//TabooLayer2
//If the taboo layer is still healthy...
if oTabooLayer2.Health &gt; 0 {
//...And if you are trying to drag the view LOWER than that...
if 
((CurrentView = MacroView and view_yview[0] &gt; (oTabooLayer2.y - view_hview[0]))
or 
(CurrentView = MicroView and view_yview[1] &gt; (oTabooLayer2.y - view_hview[1])))
and mouse_y &lt; OriginalDragY
{
//Stop you dragging any further.
oTabooLayer2.Health -= 0.0005
TryingToGoDown2 = true

if ex_audio_is_playing("lowrumblerf2") = false {
ex_audio_play("lowrumblerf2",1)
}

//React Against It
TryingToGoDownReactions(oTabooLayer1)
} else {
TryingToGoDown2 = false
}
} else {
TryingToGoDown2 = false
}


if TryingToGoDown1 = true or TryingToGoDown2 = true {
if ex_audio_is_playing("lowrumblerf2") = false {
ex_audio_play("lowrumblerf2",1)
}
EyeSquint(3,true,60)
ChangeEmotionStep("happy","down",0.03)
ChangeEmotionStep("anger","up",0.03)
mCreatureController.CloseToAnne += 0.03
if Chance(1){VocaliseChance(100)}
} else {
if mCreatureController.Alive &gt; 0 {
if mBehavioursDeliberative.PercentForward &lt; 100 {
//Firstly, come forward if not fully forward.
if mBehavioursDeliberative.MovingActive = false {
MoveBackForward("comeforward",30,100-mBehavioursDeliberative.PercentForward)
}
} else {
//If all of this is in place, then can come forward.
if device_mouse_check_button(0,mb_any) {
//The actual dragging tech.
BaseXView += (DragX - mouse_x) * DragSlowdown
BaseYView += (DragY - mouse_y) * DragSlowdown


//Stop your x moving too far left or right, or up or down.
BaseXView = clamp(BaseXView,0,(room_width - view_wview[CurrentViewNumber]))
BaseYView = clamp(BaseYView,0,(room_height - view_hview[CurrentViewNumber]) + 200)
}
}
}
}

} else {
TryingToGoDown1 = false
TryingToGoDown2 = false
}



//Counting Down Dragging Timer If Not Touching
if CurrentHandUse = "drag" {

if DragTimer &gt; 0 {
if mouse_check_button(mb_any) = false {
DragTimer -= 1
}
//Resetting Drag
if mBehavioursDeliberative.PercentForward &lt;= 90 
or mCreatureController.Alive &lt;= 0
or mBehavioursDeliberative.Bucking = true {
DragTimer = 0
CurrentHandUse = "none"
}

} else {
CurrentHandUse = "none"
DragTimer = 0
}
}


if (TryingToGoDown1 = false and TryingToGoDown2 = false) 
or CurrentHandUse = "none" or mouse_check_button_released(mb_any)
{
if ex_audio_is_playing("lowrumblerf2") {
ex_audio_stop("lowrumblerf2")
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Touching Wetness &amp; Smearing

//Get rid of item on player's hand if time has passed.
if HandWet = true {
if ResetTimer &gt; 0 {
ResetTimer -= 1
} else if ResetTimer &lt;= 0 {
HandWet = false
HandWetType = "none"
SmearAmount = 0
SmearAmountMax = 0
}
}

//Smearing with wet hand, keep it going for a while.
if position_meeting(mouse_x,mouse_y,mCreatureParent) 
and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false
and mBehavioursDeliberative.PercentForward &gt; 60 
and instance_exists(mDebug) = false
and place_meeting(mouse_x,mouse_y,mMouthParent) = false {
if instance_exists(mFinger) {
if HandWet = true {
if SmearAmount &gt; 0 {
if mouse_check_button_pressed(mb_any) {
SmearSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(SmearSound,mouse_x,mouse_y,1)
ex_audio_set_volume(SmearSound,BothVolMod(0.1),0)
ex_audio_set_pitch(SmearSound,random_range(2.3,2.7),0)
ex_audio_play(SmearSound,0)
CreateParticleSplash(mouse_x,mouse_y,sprite_get_width(mFinger) / 2,ps_shape_ellipse,ps_distr_gaussian,mInterfaceController.HandWetColour,15,30,0.03,0.08,0,360,30,80,5,20)
SmearLiquidReaction()
if HandWetType != "cleanpotion" {
mCreatureController.Dirt += 0.06
ThisSmear = instance_create(mouse_x,mouse_y,mSmear)
ThisSmear.image_blend = HandWetColour
}
} else if mouse_check_button(mb_any) {
if HandWetType != "cleanpotion" {
mCreatureController.Dirt += 0.06
ThisSmear = instance_create(mouse_x,mouse_y,mSmear)
ThisSmear.image_blend = HandWetColour
}
}
SmearAmount -= 1 
} else if SmearAmount &lt;= 0 {
WriteToLog("Smeared " + HandWetType + " on creature.")
HandWet = false
HandWetType = "none"
SmearAmount = 0
SmearAmountMax = 0
}
}
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cleaning &amp; Healing

if Healing = true {

if mouse_check_button(mb_any) and DragBegun = true {
CreateParticleSplash(mouse_x,mouse_y,3,ps_shape_ellipse,ps_distr_gaussian,c_black,10,30,0.02,0.05,0,360,20,40,0.01,50)
if HealingTimer &gt; 0 {
HealingTimer -= 1
}
}


if instance_exists(mFinger) {


with mFinger{
TouchingBruise = instance_place(x,y,oBruise)
if TouchingBruise != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
TouchingBruise.image_alpha -= 0.05
TouchingBruise.CurrentXScale -= 0.05
TouchingBruise.CurrentYScale = TouchingBruise.CurrentXScale
}
}

with mFinger{
TouchingWound = instance_place(x,y,oWound)
if TouchingWound != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
if TouchingWound.ScabGrown = false {
TouchingWound.ScabAlpha += 0.01
} else {
TouchingWound.CurrentAlpha -= 0.01
}
}
}

with mFinger{
TouchingStabWound = instance_place(x,y,oStabWound)
if TouchingStabWound != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
if TouchingStabWound.ScabGrown = false {
TouchingStabWound.ScabAlpha += 0.01
} else {
TouchingStabWound.CurrentAlpha -= 0.01
}
}
}

with mFinger {
if place_meeting(x,y,oWen) {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
}
}

with mFinger {
TouchingCanker = instance_place(x,y,oCaulCankerCentral)
if TouchingCanker != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
TouchingCanker.OriginalXScale -= 0.001
TouchingCanker.OriginalYScale -= 0.001
}
}

with mFinger {
TouchingEyeLeft = instance_place(x,y,oEyeballLeft)
if TouchingEyeLeft != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
TouchingEyeLeft.Blackness -= 0.08
}
}

with mFinger {
TouchingEyeRight = instance_place(x,y,oEyeballRight)
if TouchingEyeRight != noone {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
TouchingEyeRight.Blackness -= 0.08
}
}

with mFinger {
if place_meeting(x,y,oHornSocketRightBack) {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
if oHornRight.Growing = true {
oHornRight.y -= 0.01
}
}
}

with mFinger {
if place_meeting(x,y,oHornSocketLeftBack) {
mCreatureController.Pain -= 0.08
mCreatureController.Tiredness -= 0.08
mCreatureController.Alive -= 0.08
if oHornLeft.Growing = true {
oHornLeft.y -= 0.01
}
}
}

}

if HealingTimer &lt;= 0 {
HealingTimer = 0 
Healing = false
}
}


if Cleaning = true {

if mouse_check_button(mb_any) and DragBegun = true {
CreateParticleSplash(mouse_x,mouse_y,3,ps_shape_ellipse,ps_distr_gaussian,c_black,10,30,0.02,0.05,0,360,20,40,0.01,50)
if CleaningTimer &gt; 0 {
CleaningTimer -= 1
} 
}

if CleaningTimer &lt;= 0 {
CleaningTimer = 0 
Cleaning = false
}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ZoomedInTimer

if CurrentView = MicroView {
ZoomedInTimer += 1
}

if ZoomedInTimer = 1200 {
mDriveCollectionMaster.alarm[1] = 60
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mole Sequences

if SequenceBegun = false {
if PostDisplay = false and SigilSurfaceAlpha &lt;= 0 {
if mInterfaceController.CurrentView = MicroView and CurrentHandUse != "knife" and mCreatureController.Alive &gt; 0 {
if position_meeting(mouse_x,mouse_y,sSigilMoleParent) and mouse_check_button(mb_any) and instance_exists(mDebug) = false {
SequenceBegun = true

with sSigilMoleParent {
if position_meeting(mouse_x,mouse_y,self.id) and Occupied = true {
TouchSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(TouchSound,mouse_x,mouse_y,1)
ex_audio_set_pitch(TouchSound,random_range(0.8,1.2),0)
ex_audio_set_volume(TouchSound,BothVolMod(0.1),0)
ex_audio_play(TouchSound,0)
Touched = true
ShakeModX = 0
ShakeModMod = 0
CreateParticleSplash(x,y,7,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,0.03,0.05,0.03,0.06,30,150,40,80,0,20)
mInterfaceController.SequenceArray[mInterfaceController.NextSequencePos] = self.id
mInterfaceController.NextSequencePos = 1
mInterfaceController.CandidateSymbol = string(ID) + ","
mInterfaceController.LatestMole = self.id
mInterfaceController.LatestSigil = "drawing..."

WriteToLog("Begun mole sequence.")
}
}

if mDriveCollectionMaster.RealReactionsOn = true {

if SequenceTimer &lt;= 0 {
ChangeEmotion("surprise","up",0.9,40)
LittleJump()
}

TwitchRun(irandom_range(5,10))

if IsInRitual() {
ChangeEmotion("anger","down",0.8,7)
ChangeEmotion("happy","up",0.9,7)
ChangeEmotion("sad","down",0.9,7)
if mBehavioursReactive.CaulVibrateActive = false {
StartCaulVibrateBehaviour(400)
}
} else {
ChangeEmotion("anger","up",0.8,7)
ChangeEmotion("happy","down",0.9,7)
ChangeEmotion("sad","up",0.9,7)
if Chance(50 - (mCreatureController.Triad * 100)) {
MoveBackForward("retreat",20,20)
}
VocaliseChance(10 + ((20 / 100) * mCreatureController.Resistance))
}
mCreatureController.BaseLust += 5 * mDriveCollectionMaster.ISModifier
mCreatureController.BasePain += 5 * mDriveCollectionMaster.ISModifier
if Chance(0 + ((60 / 100) * (100 * mCreatureController.Triad))) {
EyeSquint(3,true,300)
}
}

SequenceTimer = irandom_range(500,1200)

SigilSurfaceAlpha = 1

ex_audio_set_pitch("lowrumblesigil",0.9,0)
ex_audio_set_volume("lowrumblesigil",1,40)
ex_audio_play("lowrumblesigil",true)
ex_audio_set_volume("sigilloop",0,0)
ex_audio_set_pitch("sigilloop",random_range(0.8,1.2),0)
}
}
}
} else if SequenceBegun = true {

SigilProgressReactions()

if DragBegun = true {
if ex_audio_is_playing("sigilloop") = false {
ex_audio_play("sigilloop",true)
ex_audio_set_volume("sigilloop",0.3,30)
} 
for (i = 0; i &lt; 30; i++) {
instance_create(mouse_x,mouse_y,mSigilStain)
}
} else {
if ex_audio_is_playing("sigilloop") {
ex_audio_stop("sigilloop")
}
}

CreateSigilStain(100,0,360,0.8,1.3,0.001,0.3,0.4,0.001,0.002,DebugRedTextColour,mouse_x,mouse_y)

part_emitter_region(SigilPartSys,SigilEmit,mouse_x - 10,mouse_x + 10,mouse_y - 10, mouse_y + 10, ps_shape_ellipse,ps_distr_gaussian)
part_emitter_burst(SigilPartSys,SigilEmit,SigilPart,10)

SigilBruiseAlpha += 0.0005

//Touching Other Moles
with sSigilMoleParent {
if position_meeting(mouse_x,mouse_y,self) and Touched = false and Occupied = true {
TouchSound = choose("touchwet1","touchwet2","touchwet3")
ex_audio_set_position(TouchSound,mouse_x,mouse_y,1)
ex_audio_set_pitch(TouchSound,random_range(0.8,1.2),0)
ex_audio_set_volume(TouchSound,BothVolMod(0.1),0)
ex_audio_play(TouchSound,0)
CreateParticleSplash(x,y,7,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,0.003,0.005,0.03,0.06,direction - 210,direction - 150,40,80,0,20)
TwitchRun(irandom_range(15,20))

mInterfaceController.SequenceArray[mInterfaceController.NextSequencePos] = self.id
mInterfaceController.NextSequencePos += 1
mInterfaceController.CandidateSymbol += string(ID) + ","
mInterfaceController.LatestMole = self.id
Touched = true
} 
}

//Stop The Sequence If Let Go.
if mouse_check_button_released(mb_any) {
ex_audio_stop("sigilloop")
ex_audio_set_volume("lowrumblesigil",0,100)
PostDisplay = true
Timer = 300
SequenceBegun = false
MovingOut = true
}
}

//Resetting the system.
if SequenceBegun = false and PostDisplay = false {
CandidateSymbol = ""
NextSequencePos = 0 
SequenceArray = 0
SequenceArray[0] = 0
mInterfaceController.LatestSigil = "none"
with sSigilMoleParent {
Touched = false
}
if SigilSurfaceAlpha &gt; 0 {
SigilSurfaceAlpha -= 0.001
}
if SigilBruiseAlpha &gt; 0 {
SigilBruiseAlpha -= 0.001
}
}

//Displaying the sigil after recognition.
if PostDisplay = true {
if Timer &gt; 0 {
Timer -= 1
SigilAlpha -= (0.3 / 300)
} else {
PostDisplay = false
NextSequencePos = 0
SequenceArray = 0
SequenceArray[0] = 0
Status = "none"
CandidateSymbol = ""
SigilAlpha = 0
with sSigilMoleParent {
Touched = false
}
}
}

if SequenceBegun = false {
if ex_audio_is_playing("lowrumblesigil") = true {
if ex_audio_get_volume("lowrumblesigil") &lt;= 0 {
ex_audio_stop("lowrumblesigil")
}
}
}

if MovingOut = true and SequenceBegun = false {
if IsInRitual() {
MoveToXY(500,1000,MoveSpeedCalc(),MacroView,ZoomSpeedCalc())
}
MovingOut = false
}

SigilBruiseAlpha = clamp(SigilBruiseAlpha,0,1)

if SequenceTimer &gt; 0 {
SequenceTimer -= 1
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wounding

if CurrentHandUse = "knife" 
and Wounding = false
and DrawingPath = false
and mouse_check_button_pressed(mb_any)
and instance_exists(mDebug) = false
and position_meeting(mouse_x,mouse_y,mCreatureParent)
and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false
and position_meeting(mouse_x,mouse_y,oStabWound) = false
and position_meeting(mouse_x,mouse_y,oWound) = false
and position_meeting(mouse_x,mouse_y,oEyeballLeft) = false
and position_meeting(mouse_x,mouse_y,oEyeballRight) = false
and position_meeting(mouse_x,mouse_y,mMouthParent) = false
and position_meeting(mouse_x,mouse_y,oWen) = false
and position_meeting(mouse_x,mouse_y,sSigilMoleParent) = false
and position_meeting(mouse_x,mouse_y,oCellarTop) = false
and position_meeting(mouse_x,mouse_y,oCaulCankerCentral) = false
and instance_exists(mFinger)
and mBehavioursDeliberative.PercentForward &gt;= 60
and NoNewCut = false
and ((mouse_x &gt; 221 and mouse_x &lt; 1141) and (mouse_y &gt; 600 and mouse_y &lt; 5199))
{
StartWounding()
with oMoleHerd {
State = "shivering"
ShiverTimer = random_range(30,100)
}

mDriveCollectionMaster.CutReact = true
}

if Wounding = true {
StartScreenShake(1,8,1)

if DragBegun = true and DragSpeed &gt; 0 {
if ex_audio_is_paused(CutSound) {
ex_audio_resume(CutSound)
}
} else {
if ex_audio_is_playing(CutSound) {
ex_audio_pause(CutSound)
}
}

//Particles And Stains
CreateStain(20,0,360,10,50,0.3,0.05,0.1,0.1,0.2,DebugRedTextColour,mouse_x,mouse_y)
CreateParticleSplash(mFinger.x,mFinger.y,2,ps_shape_ellipse,ps_distr_gaussian,DebugRedTextColour,10,30,0.05,0.1,0,360,30,50,0.01,10)

//Increase Cut Distance &amp; Timer
CutDistance += point_distance(LastX,LastY,mFinger.x,mFinger.y)
ex_audio_set_pitch(CutSound,InitialPitch + ((0.1 / MaxCutLength) * CutDistance))
ex_audio_set_volume(CutSound,BothVolMod(0.8),1)
CutTimer += 1

//Add Points To Path
if CutTimer mod 3 = 0 {
path_add_point(ThisWoundPath,mFinger.x,mFinger.y,0)
}

if mouse_check_button_released(mb_any)
or position_meeting(mouse_x,mouse_y,mCreatureParent) = false
or position_meeting(mouse_x,mouse_y,oStabWound)
or position_meeting(mouse_x,mouse_y,oWound)
or position_meeting(mouse_x,mouse_y,mMouthParent)
or position_meeting(mouse_x,mouse_y,mCellarParent)
or position_meeting(mouse_x,mouse_y,oCaulCankerCentral)
or (CuttingWhat = "skin" and position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate))
or CutDistance &gt; MaxCutLength
or ((mouse_x &lt; 221 or mouse_x &gt; 1141) or (mouse_y &lt; 600 or mouse_y &gt; 5199))
{
EndCut()
}

if CuttingWhat = "cheekleft" {
if position_meeting(mouse_x,mouse_y,oCheekLeft) = false {
EndCut()
}
} else if CuttingWhat = "cheekright" {
if position_meeting(mouse_x,mouse_y,oCheekRight) = false {
EndCut()
}
} else if CuttingWhat = "browleft" {
if position_meeting(mouse_x,mouse_y,oBrowLeft) = false {
EndCut()
}
} else if CuttingWhat = "browright" {
if position_meeting(mouse_x,mouse_y,oBrowRight) = false {
EndCut()
}
} else if CuttingWhat = "tophead" {
if position_meeting(mouse_x,mouse_y,mTopOfHeadTemplate) = false {
EndCut()
}
} else if CuttingWhat = "nose" {
if position_meeting(mouse_x,mouse_y,oNose1) = false {
EndCut()
}
} else if CuttingWhat = "caulbowl" {
if position_meeting(mouse_x,mouse_y,oCaulBowl) = false {
EndCut()
}
} else if CuttingWhat = "cauljug" {
if position_meeting(mouse_x,mouse_y,oCaulJug) = false {
EndCut()
}
}
}




//Poking For Too Long Causes A Bruise
if PressBegun = true and mouse_check_button_released(mb_any) and BruisePressTimer &gt; 450 and CurrentHandUse = "none" {
CauseBruise(LastX,LastY,5)
WriteToLog("Bruise caused.")
LastPressX = LastX
LastPressY = LastY
}

if HeardVeloc = true {
if VelocTimer &gt; 0 {
VelocTimer -= 1
} else {
VelocTimer = 0
HeardVeloc = false
}
}


if CurrentHandUse = "burstwen" {
if BurstWenTimer &gt; 0 {
BurstWenTimer -= 1
} else {
BurstWenTimer = 0
CurrentHandUse = "none"
}
}

//Registering Slaps, Causing A Bruise And Possibly A Black Eye

if PotentialSlap = false {
if (instance_exists(mFinger) and place_meeting(mFinger.x,mFinger.y,mCreatureParent) = false)
and mouse_check_button_pressed(mb_any)
and CurrentView = MacroView
and CurrentHandUse = "none"
and HeardVeloc = true
{
PotentialSlap = true
WillSlap = false
SlapWindow = 400
}
}

if PotentialSlap = true {
SlapWindow -= 1

if SlapWindow &lt;= 0 {
PotentialSlap = false
WillSlap = false
}

if DragSpeed &gt; 60 {
WillSlap = true
}

if WillSlap = true and DragSpeed &lt;= 0 {
WillSlap = false

if mouse_x &lt; (view_wview[CurrentView] / 2) {
SlapDir = 1
} else {
SlapDir = -1
}
}


if mouse_check_button_released(mb_any) {
if WillSlap = true and position_meeting(mouse_x,mouse_y,mCreatureParent) {
SlapSound = choose("slap1","slap2","slap3")
ex_audio_set_pitch(SlapSound,random_range(1.9,3.1),0)
ex_audio_set_volume(SlapSound,BothVolMod(1))
ex_audio_play(SlapSound,0)
RandomShake()
SlapMove = true
SlapToMove = irandom_range(150,280) * SlapDir
WriteToLog("Slapped.")
EyeSquint(2,true,irandom_range(60,130))

//REACTIONS

//Make eyes black
if point_distance(mouse_x,mouse_y,oEyeballLeft.x,oEyeballLeft.y) &lt; 70 {
oEyeballLeft.TargetBlackness = 0.9
} else if point_distance(mouse_x,mouse_y,oEyeballRight.x,oEyeballRight.y) &lt; 70 {
oEyeballRight.TargetBlackness = 0.9
}
if point_distance(mouse_x,mouse_y,oCheekLeft.x,oCheekLeft.y) &lt; 300 {
oCheekLeft.RednessTemp = 0.7
} else if point_distance(mouse_x,mouse_y,oCheekRight.x,oCheekRight.y) &lt; 300 {
oCheekRight.RednessTemp = 0.7
}

//Bruise &amp; Shake &amp; Twitches
if mDriveCollectionMaster.RealReactionsOn = true {
CauseBruise(mouse_x,mouse_y,random_range(0.7,1.2))
TwitchIfNearBP(mouse_x,mouse_y,500)
TwitchIfNearBP(mouse_x,mouse_y,500)
TwitchIfNearBP(mouse_x,mouse_y,500)
StopVocalisation()
StopVocalPhrase()
StopYawnBehaviour()
StopSneezeBehaviour()
ChanceToWake(50)
StartBlinkBehaviour()
choose(StartEyebrowTwitchLeftBehaviour(),StartEyebrowTwitchRightBehaviour)
StartTwitchBehaviour(3,3,1)
choose(StartCheekTwitchLeftBehaviour(),StartCheekTwitchRightBehaviour())
choose(StartMouthSideLeftTwitchBehaviour(choose("down","up")),StartMouthSideRightTwitchBehaviour(choose("down","up")))


if SlapTimer &lt;= 0 {
LittleJump()
ChangeEmotion("surprise","up",0.6,10 + (40 * mCreatureController.Triad))
SlapTimer = irandom_range(10000,20000)
}

if mDriveCollectionMaster.InRitual = true {
if Chance(ChanceToRitualReact() * ReactChance()){StartSniffBehaviour(20,20,1,1.2)}
if Chance(ChanceToRitualReact() * ReactChance()){LittleJump()}
mDriveCollectionMaster.BaseBreathRate += 0.07
TwitchRun(irandom_range(20,40))
mCreatureController.BaseResistance -= 20 * mDriveCollectionMaster.ISModifier
mCreatureController.BaseAlive -= 0.3 * mDriveCollectionMaster.ISModifier
mCreatureController.BaseStress += 10 * mDriveCollectionMaster.ISModifier
mCreatureController.BasePain += 10 * mDriveCollectionMaster.ISModifier
mCreatureController.CloseToAnne += 10 * mDriveCollectionMaster.ISModifier
ChangeEmotion("happy","up",0.3,10)
ChangeEmotion("fear","up",0.3,40)
if Chance(70 * ReactChance()) and mBehavioursDeliberative.PercentForward &lt; 100 {MoveBackForward("comeforward",30 - (15 * mCreatureController.Triad),100 - mBehavioursDeliberative.PercentForward)}

} else {
EmotionRequest()
if Chance(ChanceToRitualReact() * ReactChance()){StartSniffBehaviour(20,20,1,1.2)}
if Chance(ChanceToRitualReact() * ReactChance()){LittleJump()}
mDriveCollectionMaster.BaseBreathRate += 0.07
if Chance(70 * ReactChance()) {MoveBackForward("retreat",30 - ((15 / 100) * mCreatureController.Pain),10)}
TwitchRun(irandom_range(20,40))
ChangeEmotion("happy","down",0.4,30)
ChangeEmotion("shame","up",0.5,20 + (20 / mCreatureController.Triad))
ChangeEmotion("fear","up",0.5,30 - (20 / mCreatureController.Triad))
ChangeEmotion("anger","up",0.3,((35 / 100) * mCreatureController.Resistance))
mCreatureController.CloseToAnne -= 10 * mPlotController.ISModifier
mCreatureController.BaseSubIntent -= 0.1 * mPlotController.ISModifier
mCreatureController.BaseResistance -= 20 * mPlotController.ISModifier
mCreatureController.BaseTrust -= 20 * mPlotController.ISModifier
mCreatureController.BaseLust -= 20 * mPlotController.ISModifier
mCreatureController.BaseAlive -= 0.2 * mPlotController.ISModifier
mCreatureController.BaseStress += 20 * mPlotController.ISModifier
mCreatureController.BasePain += 10 * mPlotController.ISModifier
mCreatureController.BaseTiredness -= 10 * mPlotController.ISModifier
}
}
}
PotentialSlap = false
mDriveCollectionMaster.alarm[1] = 60
}
}

if SlapTimer &gt; 0 {
SlapTimer -= 1
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controlling Slap

if SlapMove = true {
if SlapDir = -1 {
if CurrentSlapAmount &gt; SlapToMove {
CurrentSlapAmount -= 60
} else {
SlapMove = false
}
} else if SlapDir = 1 {
if CurrentSlapAmount &lt; SlapToMove {
CurrentSlapAmount += 60
} else {
SlapMove = false
}
}

} else {
if CurrentSlapAmount &lt; 0 {
CurrentSlapAmount += 5
} else if CurrentSlapAmount &gt; 5 {
CurrentSlapAmount -= 5
} else {
CurrentSlapAmount = 0
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Counting Down Finger Light Time

if FingerLightOn = true {
if CurrentLightTime &gt; 0 {
CurrentLightTime -= 1
} else if CurrentLightTime &lt;= 0 {
CurrentLightTime = 0
FingerLightOn = false
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controlling Voice Master Pitch

BaseSoundPitch = 1 + mDriveCollectionMaster.RitualPitchMod + oThroat.PitchMod + (0.3 * oThroat.Cut)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ScreenShake &amp; Final Calculation Of X &amp; Y View &amp; Jumping

ScreenShake()

if Jumping = true {
if JumpDir = "up" {
if JumpMod &lt; JumpAmount {
JumpMod += 15
} else if JumpMod &gt;= JumpAmount {
JumpDir = "down" 
}
} else if JumpDir = "down" {
if JumpMod &gt; 0 {
JumpMod -= 15
} else if JumpMod &lt;= 0 {
JumpMod = 0
Jumping = false
}
}
}


//No floating if moving back and forward or moving to XY
if
mBehavioursDeliberative.XYMove = true or
mBehavioursDeliberative.MovingActive = true
or mCreatureController.Alive &lt;= 0
or CurrentView = MicroView
or IsInRitual()
or (instance_exists(oEarLeft) and oEarLeft.Pulling = true)
or (instance_exists(oEarRight) and oEarRight.Pulling = true)
{
Floating = false
} else {
Floating = true
}




if Floating = true {

//Start floating out in a direction
if FinishedFloatOut = false {

if FloatLength &lt; TotalFloatLength {
FloatLength += 0.5

//When you reach the end of the float out, turn around and come back.
} else {
FinishedFloatOut = true
}

} else {
FloatLength -= 0.5

//When back at centre, choose a new random direction and length (opposite)
if FloatLength &lt;= 0 {
if FloatDir = "left" {
FloatDir = "right"
} else {
FloatDir = "left"
}

if FloatDir = "left" {
FloatComp = irandom_range(-45,45)
} else {
FloatComp = irandom_range(135,215)
}

FloatTotalLength = irandom_range(50,100)
FloatLength = 0
FinishedFloatOut = false
}

}

} else {
FinishedFloatOut = false
FloatDir = "left"

if FloatLength &gt; 0 {
FloatLength -= 1
}
}


//Add to the two FloatMods, in the right direction, at the right speed.

FloatModX = lengthdir_x(FloatLength,FloatComp)
FloatModY = lengthdir_y(FloatLength,FloatComp)

FloatLength = clamp(FloatLength,0,200)


BreathYMod = clamp(BreathYMod,0,100)

if CurrentView = MicroView {
view_xview[1] = BaseXView + ShakeMod + FloatModX + mDriveCollectionMaster.RitualModX + CurrentSlapAmount
view_yview[1] = BaseYView + (BreathYMod / 3) + JumpMod - SlipMod - DeadMod - mBehavioursReactive.SleepDroopYCurrent + FloatModY
} else if CurrentView = MacroView {
view_xview[0] = BaseXView + ShakeMod + FloatModX + mDriveCollectionMaster.RitualModX + CurrentSlapAmount
view_yview[0] = BaseYView + (BreathYMod / 2) + JumpMod - SlipMod - DeadMod - mBehavioursReactive.SleepDroopYCurrent + FloatModY 
}


if oTabooLayer1.Health &gt; 0 {
//MacroView Clamp
view_yview[0] = clamp(view_yview[0],0,oTabooLayer1.y - view_hview[0] + 30)
//MicroView Clamp
view_yview[1] = clamp(view_yview[1],0,oTabooLayer1.y - view_hview[1] + 30)
} else {
if oTabooLayer2.Health &gt; 0 {
//MacroView Clamp
view_yview[0] = clamp(view_yview[0],0,oTabooLayer2.y - view_hview[0] + 30)
//MicroView Clamp
view_yview[1] = clamp(view_yview[1],0,oTabooLayer2.y - view_hview[1] + 30)
}
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///WinksToRun

if WinksToRun &gt; 0 {
if mBehavioursReactive.WinkingActive = false {
StartWinkBehaviour("left")
WinksToRun -= 1
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Close Eavesdrop And Pareidolia

CloseEavesdropAndPareidolia()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw The Sigil Surface



SigilSurfaceX = oHead1.x - 120
SigilSurfaceY = oHead1.y - 388

draw_sprite_ext(sSigilBruise,0,SigilSurfaceX,SigilSurfaceY,1,1,0,c_white,SigilBruiseAlpha)

if !surface_exists(SigilSurface) {
SigilSurface = surface_create(301,298)
}

if SigilSurfaceAlpha &lt;= 0 {
surface_set_target(SigilSurface)
draw_clear_alpha(c_black,0)
surface_reset_target()
} 

draw_surface_ext(SigilSurface,SigilSurfaceX,SigilSurfaceY,1,1,0,c_white,SigilSurfaceAlpha)




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
