<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sWander</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

State = "wandering"
DetectionRadius = 100
DirectionChangeRate = 1
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
AlignVar = 0
SepVar = 0
AvgX = 0
AvgY = 0
Neighbours = 0
WanderRange = 80
DitherMod = 2
CollisionAhead = noone
speed = 45 / room_speed

CollisionLength = 100
CollisionWidth = 35

direction = CurrentHeading
image_angle = direction

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sensing &amp; Changing States

ColPointXM = x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = y + lengthdir_y(CollisionLength,CurrentHeading)

ColPointXL = x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)

ColPointXR = x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(x,y,ColPointXM,ColPointYM,tCollision,true,true)
CollisionAhead2 = collision_line(x,y,ColPointXL,ColPointYL,tCollision,true,true)
CollisionAhead3 = collision_line(x,y,ColPointXR,ColPointYR,tCollision,true,true)
CollidingWall = instance_place(x + hspeed,y + vspeed,tCollision)
CollidingWander = instance_place(x + hspeed,y+vspeed,tWander)

if instance_exists(tSeek) {
NearestSeek = instance_nearest(x,y,tSeek)
if point_distance(x,y,NearestSeek.x,NearestSeek.y) &lt;= DetectionRadius 
{
State = "seeking"
} else {
State = "wandering"
}
} else {
State = "wandering"
}

if State = "seeking" {
DirectionChangeRate = 5
} else if State = "wandering" {
if CollisionAhead != noone {
DirectionChangeRate = 5
} else {
DirectionChangeRate = 1
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Seeking

if State = "seeking" {
Target = instance_nearest(x,y,tSeek) 
DesiredHeading = point_direction(x,y,Target.x,Target.y)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wandering (&amp; Flocking)



if State = "wandering" {

//Reset Flocking Variables
AlignVar = 0
CohVar = 0
SepVar = 0
Neighbours = 0

if CollidingWall = noone and CollidingWander = noone and CollisionAhead1 = noone and CollisionAhead2 = noone and CollisionAhead3 = noone {
with tWander {
//Alignment Calculation
NDistance = point_distance(other.x,other.y,x,y)
if (id != other.id) and (NDistance &lt;= other.DetectionRadius * 1.5) { 
other.AlignVar += CurrentHeading
other.CohVar += point_direction(other.x,other.y,x,y)
other.SepVar += point_direction(x,y,other.x,other.y)
other.Neighbours += 1
}
}


if Neighbours &gt; 0 {
AverageHeading = ((AlignVar / Neighbours) + (CohVar / Neighbours) + (SepVar / Neighbours))  / 3
DesiredHeading = AverageHeading + irandom_range(((WanderRange / 2) * -1),(WanderRange / 2))
DirectionChangeRate = 5
}else if Neighbours &lt;= 0 {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
WanderModLower = CurrentHeading - (WanderRange / 2)
WanderModHigher = CurrentHeading + (WanderRange / 2)
DesiredHeading = irandom_range(WanderModLower,WanderModHigher)
}
}
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Then, Collision Avoidance &amp; Separation


if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 20)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 20)
}
}

if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 20)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 20)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 20)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 20)
}
}


//Colliding 

if CollidingWall {
DistX = sign(x - CollidingWall.x) //* 2
DistY = sign(y - CollidingWall.y) //* 2
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}

if CollidingWander {
DistX = sign(x - CollidingWander.x) //* 2
DistY = sign(y - CollidingWander.y)// * 2
x += DistX
y += DistY
DirectionChangeRate = 5
}









</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Heading

//Whatever the desired heading, turn towards it.
if CurrentHeading != DesiredHeading {
if DesiredHeading &gt; CurrentHeading + DitherMod {
CurrentHeading += DirectionChangeRate
} else if DesiredHeading &lt; CurrentHeading - DitherMod {
CurrentHeading -= DirectionChangeRate
}
} 

direction = CurrentHeading
image_angle = CurrentHeading

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wrap To Game

if x &gt; room_width {
x = 0
} else if x &lt; 0 {
x = room_width
}

if y &gt; room_height {
y = 0
} else if y &lt; 0 {
y = room_height
} 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Self And Debug

draw_self()

if keyboard_check(ord('D')) {
draw_set_color(c_orange)
draw_circle(x,y,DetectionRadius,true)
draw_set_color(c_black)
draw_set_font(fController)
draw_text(x, y + 20, string(Neighbours))
draw_set_color(c_purple)
draw_line(x,y,ColPointXM,ColPointYM)
draw_line(x,y,ColPointXL,ColPointYL)
draw_line(x,y,ColPointXR,ColPointYR)
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
