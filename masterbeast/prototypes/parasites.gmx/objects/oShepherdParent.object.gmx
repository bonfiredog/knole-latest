<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

//Positioning
Facing = "right"
FacingScale = 1
Born = false


SleepTimerBegun = false
SleepTimer = 0
SleepingBegun = false
RandomSleepChangeTimer = 0
SatBegun = false

PatrolTimer = 1000
PatrolPauseTimer = 0
PatrolPausing = false
FidgetTimer = 0

FishSpotPicked = false
FishSpotX = 0
FishSpotY = 0
FishBegun = false

MoleCutInRange = false


//Behaviours
State = "standing"
WalkingSpeed = 40
SpeedChangeRate = 0.5
Lifting = "right"
LiftDir = "up"
FishingShakeTimer = 500
FishingShake = false 
FishDown = false
NumberOfShakes = 0
CrookUp = 0
OrigCrook = 0
LineMod = 0
FleeStamped = false
PUSitting = false
PUCountdown = 60
PUStanding = false
PUp = false
Drop = false
Health = 100

CrookState = "none"
CrookReset = false

NumberOfStamps = 0
StampSpeed = 0
StampDirection = "up"
StartStamp = false

NumberOfJabs = 0
JabSpeed = 0
JabDirection = "out"
StartJab = false

CrookShakeTime = 0
ShakeSpeed = 3

ShoutMod = 0
ShoutDir = "left"
Calling = false

Hunting = true
HuntingTimer = 0
DoneTurning = false
DTTimer = 70
HuntDest = noone
Checking = false
CheckTimer = 70



//Drives
PlatonicGoal = "none"
TabooStamped = false
AlertLevel = 85
AlertChange = 0.01
TODFactor = 1
TODDecision = 0
MoleFactor = 0
MoleDecision = 0
TempFactor = 0
TempDecision = 0
PlayerFactor = 0
PlayerDecision = 0
FishLeftX = tEyeLeft.x + lengthdir_x((tEyeLeft.sprite_width / 2) + 8, 30)
FishLeftY = tEyeLeft.y + lengthdir_y((tEyeLeft.sprite_width / 2) + 8, 30)
FishRightX = tEyeRight.x + lengthdir_x((tEyeRight.sprite_width / 2) + 8, 30)
FishRightY = tEyeRight.y + lengthdir_y((tEyeRight.sprite_width / 2) + 8, 30)
PatrolPause = false
PauseTimer = 200
PatrolPauseTurned = false


//Collisions
GapAhead1 = false
GapAhead2 = false
GapAhead3 = false
CollidingWall = noone
CollidingWound = noone
NearestMole = noone
NearestScent = noone
NearestFur = noone
SensedMole = false
SensedScent = false
SensedFur = false
LastRememberedMole = noone
LastRememberedFur = noone
LastRememberedScent = noone
LastRememberedMoleHole = noone
PlayerTouching = false
SenseRadius = 100

//Bearing And Speed
DesiredHeading = 320
CurrentHeading = 0
DitherMod = 5
DirectionChangeRate = 1
CurrentSpeed = 0
DesiredSpeed = 0
CollisionLength = 50
GapLength = 25
CollisionWidth = 35

//Miscellaneous Functions
OriginalBreathRate = 1
BreathRate = OriginalBreathRate
BreathBeMod = 0
WakingUp = true
WakingTimer = 0

BaseDepth = 1
OriginalDepth = BaseDepth

MasterEyesShut = false
IsCold = false

alarm[0] = 20
alarm[1] = 20

StampTimer = irandom_range(400,1000)









</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set Platonic Goal

//WhatShouldIBeDoingToday()

alarm[1] = 30000
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check Radius Mods
if place_meeting(oShepherdBody.x,oShepherdBody.y,tFurRegion) {
FurMod = 30
} else {
FurMod = 0
}

if tController.TimeOfDay = "evening" {
TimeMod = 10
} else if tController.TimeOfDay = "night" {
TimeMod = 20
} else {
TimeMod = 0
}

if tController.Temperature = "cold" {
IsCold = true 
ColdMod = 20
} else {
IsCold = false
ColdMod = 0
}

SenseRadius = 100 - FurMod - TimeMod + ColdMod
alarm[0] = 2000
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set Facing Scale &amp; Move With Body

if Facing = "right" {
FacingScale = 1
} else if Facing = "left" {
FacingScale = -1
}

x = oShepherdBody.x
y = oShepherdBody.y
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Alertness

//Alert Change Rate - how quickly does alert go down? 
if Born = true {
if tController.TimeOfDay = "night" {
TODFactor = 0
TODDecision = 1
} else {
TODFactor = 0.005
TODDecision = -1
}

if tController.Temperature = "cold" {
TempFactor = 0
TempDecision = 0.5
} else {
TempFactor = 0.005
TempDecision = -0.5
}

if PlayerTouching = true {
PlayerFactor = 0
PlayerDecision = 1
} else {
PlayerFactor = 0.005
PlayerDecision = -1
}

if SensedMole = true {
MoleFactor = 0
MoleDecision = 1
} else {
MoleFactor = 0.005
MoleDecision = -1
}

AlertChange = 0.002 + TODFactor + TempFactor + MoleFactor + PlayerFactor


if AlertLevel &gt; 0 and AlertLevel &lt;= 99 {
AlertLevel -= AlertChange
}

//Whether to flee or fight dependent on various factors.

else if AlertLevel = 100 {

if Hunting = false {
AlertUp(0)
FleeOrNotAlert = 50 + TODDecision + TempDecision + MoleDecision + PlayerDecision

FleeOrNotAlert = clamp(FleeOrNotAlert,0,100)

if FleeOrNotAlert &lt;= 50 {
if instance_exists(tScentMarker) {
Source = instance_nearest(x,y,tScentMarker)
} else {
Source = instance_nearest(x,y,tMole)
}
StartFleeing(Source,5000)
} else if FleeOrNotAlert &gt; 50 {
Hunting = true
HuntingTimer = 10000
DoneTurning = false 
HuntDest = noone
StartStanding()
DTTimer = 70
}
AlertLevel = 30
} else {
AlertLevel = 30
HuntingTimer = 10000
}
}
}


if Hunting = true and AlertLevel &lt;= 0 {
Hunting = false 
HuntingTimer = 0
DTTimer = 0
DoneTurning = false
}

AlertLevel = clamp(AlertLevel,0,100)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Senses And Memory

//Collision Sensing
if Born = true {

ColPointXM = oShepherdBody.x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = oShepherdBody.y + lengthdir_y(CollisionLength,CurrentHeading)
ColPointXL = oShepherdBody.x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = oShepherdBody.y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)
ColPointXR = oShepherdBody.x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = oShepherdBody.y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

GapPointXM = oShepherdBody.x + lengthdir_x(GapLength,CurrentHeading)
GapPointYM = oShepherdBody.y + lengthdir_y(GapLength,CurrentHeading)
GapPointXL = oShepherdBody.x + lengthdir_x(GapLength,CurrentHeading - CollisionWidth)
GapPointYL = oShepherdBody.y + lengthdir_y(GapLength,CurrentHeading - CollisionWidth)
GapPointXR = oShepherdBody.x + lengthdir_x(GapLength,CurrentHeading + CollisionWidth)
GapPointYR = oShepherdBody.y + lengthdir_y(GapLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXM,ColPointYM,tCollision,true,true)
CollisionAhead2 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXL,ColPointYL,tCollision,true,true)
CollisionAhead3 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXR,ColPointYR,tCollision,true,true)

WoundAhead1 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXM,ColPointYM,tWound,true,true)
WoundAhead2 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXL,ColPointYL,tWound,true,true)
WoundAhead3 = collision_line(oShepherdBody.x,oShepherdBody.y,ColPointXR,ColPointYR,tWound,true,true)

if collision_point(GapPointXL,GapPointYL,tHead,true,true) = noone {
GapAhead1 = true
} else {
GapAhead1 = false
}

if collision_point(GapPointXM,GapPointYM,tHead,true,true) = noone {
GapAhead2 = true
} else {
GapAhead2 = false
}

if collision_point(GapPointXR,GapPointYR,tHead,true,true) = noone {
GapAhead3 = true
} else {
GapAhead3 = false
}

CollidingWall = instance_place(oShepherdBody.x + hspeed,oShepherdBody.y + vspeed,tCollision)
CollidingWound = instance_place(oShepherdBody.x + hspeed,oShepherdBody.y + vspeed,tWound)


//Always note where the nearest POI is.

NearestMole = instance_nearest(oShepherdBody.x,oShepherdBody.y,tMole)
NearestScent = instance_nearest(oShepherdBody.x,oShepherdBody.y,tScentMarker)
NearestFur = instance_nearest(oShepherdBody.x,oShepherdBody.y,tFurRegion)
NearestMoleHole = instance_nearest(x,y,tMoleHole)

//Detect whether a certain POI is within 
//the sense radius, and update memory of where the last-seen POI is.

if distance_to_object(NearestMole) &lt;= SenseRadius {
SensedMole = true
LastRememberedMole = NearestMole
} else {
SensedMole = false
}

if distance_to_object(NearestFur) &lt;= SenseRadius {
SensedFur = true
LastRememberedFur = NearestFur
} else {
SensedFur = false
}

if distance_to_object(NearestMoleHole) &lt;= SenseRadius {
SensedMoleHole = true
LastRememberedMoleHole = NearestMoleHole
} else {
SensedMoleHole = false
}


if distance_to_object(NearestScent) &lt;= SenseRadius {
SensedScent = true 
LastRememberedScent = NearestScent
} else {
SensedScent = false
}

if mouse_check_button_pressed(mb_any) or mouse_check_button(mb_any) {
PlayerTouching = true
} else {
PlayerTouching = false
}

//Is a mole in range being cut?
if SensedMole = true {
with tMole {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius
and Cutting = true {
other.MoleCutInRange = true
}
}
} else {
MoleCutInRange = false
}

//Are cows following?
if SensedMole = true {
with tMole {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius
and State = "following" {
other.FollowingCowsInRadius = true
}
}
} else {
FollowingCowsInRadius = false
}

//Is any mole in range clustering?
if SensedMole = true {
with tMole {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius
and State = "following" {
other.MolesClustering = true
}
}
} else {
MolesClustering = false
}
}

if tController.CurrentView = "out" {
ViewSpeedMod = 0.07
} else if tController.CurrentView = "in" {
ViewSpeedMod = 1
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drives
//------ In order of importance: most important at the top, least important at the bottom.

if Born = true {

//If the player is touching, alert (low).
if PlayerTouching = true {
AlertLevel += 0.01
}

TabooStamped = false

//----------------------------------------------------------------------------------
//Stay at home until the flee timer has ended.

if State = "sitting" and RetreatedToHome = true and FleeTimer &gt; 0 {

DesiredHeading = 0
CurrentHeading = DesiredHeading
if oShepherdBody.SitYMod &gt;= 14 {
oShepherdBody.x = oShepherdHome.x
oShepherdBody.y = oShepherdHome.y
}

if FleeTimer &gt; 0 {
FleeTimer -= 1
} else if FleeTimer &lt;= 0 {
FleeTimer = 0
SourceOfFear = noone
FleeStamped = false
RetreatedToHome = false
}

//----------------------------------------------------------------------------------
//Flee from mouth if close enough and creature vocalises
} else if audio_is_playing(aCreatureRoar) and point_distance(x,y,tMouth.x,tMouth.y) &lt; 300
and (State = "walking" or State = "sitting" or State = "standing" or State = "sleeping" or State = "fishing" or State = "fleeing" or State = "turnbackandforth")
{
StartFleeing(tMouth,700)


//----------------------------------------------------------------------------------
//Flee from player contact
} else if PlayerTouching = true
and point_distance(x,y,tMousePointer.x,tMousePointer.y) &lt;= SenseRadius { 
StartFleeing(tMousePointer,1000)

//--------------------------------------------------------------------------------------
//Fleeing from player touching and night-time (in final code, if light is on).

} else if instance_exists(tMousePointer) 
and point_distance(x,y,tMousePointer.x,tMousePointer.y) &lt; 400
and tController.TimeOfDay = "night" {
StartFleeing(tMousePointer,600)


//--------------------------------------------------------
//If mole is attacked in view, start hunting immediately.
} else if
MoleCutInRange = true and Hunting = false {
Hunting = true
HuntingTimer = 10000
DoneTurning = true
HuntDest = tMousePointer
StartStanding()
DTTimer = 0
AlertLevel = 30


//ALERTS

//--------------------------------------
//If encounter a mole-hole, alert.
} else if 
instance_exists(tMoleHole) 
and NearestMoleHole != LastRememberedMoleHole 
and point_distance(x,y,NearestMoleHole.x,NearestMoleHole.y) &lt;= SenseRadius 
and (State = "standing" or State = "walking" or State = "sitting" or State = "fishing")

{
AlertUp(4)

//--------------------------------------------------------------------------------------
//If sense a scent, alert (mid).

} else if instance_exists(tScentMarker) 
and NearestScent != LastRememberedScent and point_distance(x,y,NearestScent.x,NearestScent.y) &lt;= SenseRadius 
and (State = "standing" or State = "walking" or State = "sitting" or State = "fishing" or State = "sleeping")
{
AlertUp(7)


//----------------------------------------------------------------------------------
//If cow found not activated, activate by coming close, jabbing and calling. (Maybe stamp afterwards as well). 
//Only if walking, sitting or standing or fishing

} else if SensedMole = true and NearestMole.Energy &lt;= 0 and 
(State = "walking" or State = "sitting" or State = "standing" or State = "fishing")
{

DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)
if distance_to_object(NearestMole) &gt; 20 {
StartWalking()
} else {
if State != "standing" {
StartStanding()
}
StartShaking(2,3)
CallOrNot = choose(-1,-1,1)
if CallOrNot = 1 {
Call()
}
}



//---------------------------------------------------------------------------------
//Taboo Areas (avoid and stamp cows away)
//Only if walking, sitting or standing

} else if instance_exists(tTabooParent) 
and point_distance(x,y,instance_nearest(x,y,tTabooParent).x,instance_nearest(x,y,tTabooParent).y) &lt;= (SenseRadius + (instance_nearest(x,y,tTabooParent).sprite_width / 2))
and (State = "walking" or State = "standing" or State = "sitting")
{


if instance_exists(tMole) {
if point_distance(x,y,NearestMole.x,NearestMole.y) &lt;= SenseRadius {
if TabooStamped = false {
StartStamping(3,2)
TabooStamped = true
}
}
}

if State != "walking" {
StartWalking()
}

if instance_exists(tTabooParent){
DesiredHeading = point_direction(instance_nearest(x,y,tTabooParent).x,instance_nearest(x,y,tTabooParent).y,x,y)
}

//-------------------------------------------
//if Alert is high enough, and cows are found and they are not following, make them follow.

} else if AlertLevel &gt; 50
and SensedMole = true
and (State = "walking" or State = "standing")
and NearestMole.State != "following" {

StartShaking(5,1)
Call()

with tMole {
if point_distance(x,y,other.x,other.y) &lt;= SenseRadius {
if State != "following" {
State = "following"
}
}
}


//--------------------------------------------------------------------------------------
//If cows in radius, and following, and alert is low, turn stamp, then continue, maybe call.

} else if FollowingCowsInRadius = true 
and AlertLevel &lt;= 50 and StampTimer &gt; 0 
and (State = "standing" or State = "walking") {

if StampTimer &gt; 0 {
StampTimer -= 1
} else {
DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)
CurrentHeading = DesiredHeading
StartStamping(3,3)
Call()
StampTimer = irandom_range(400,1000)
}


//--------------------------------------------------------------------------------------
//If fleeing moles in radius, stamp

} else if SensedMole = true
and NearestMole.State = "fleeing"
and (State = "standing" or State = "walking" or State = "sitting") {

if State != "standing" or State != "walking" {
StartStanding()
} else if State = "standing" or State = "walking" {
StartStamping(3,3)
Call()
}



//--------------------------------------------------------------------------------------
//If come across a clustering moles, stamp apart, and call.

} else if SensedMole = true 
and MolesClustering = true
and (State = "standing" or State = "walking" or State = "sitting")
{
DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)
CurrentHeading = DesiredHeading
StartStamping(3,3)
Call()

} else {
//-------------------------------------------- BASE GOALS
switch PlatonicGoal {

//-------------------------------------------------------
case "sleep":

DistanceToHome = point_distance(oShepherdBody.x,oShepherdBody.y + 14,oShepherdHome.x,oShepherdHome.y)

if SatBegun = false {
if DistanceToHome &gt; 1 {
if State != "walking" {
StartWalking()
}
DesiredHeading = point_direction(oShepherdBody.x,oShepherdBody.y + 14,oShepherdHome.x,oShepherdHome.y)
CurrentHeading = DesiredHeading
} else if DistanceToHome &lt; 1 {
SatBegun = true 
DesiredHeading = 0
CurrentHeading = DesiredHeading
}
} else if SatBegun = true {
if oShepherdBody.SitYMod &gt;= 14 {
oShepherdBody.x = oShepherdHome.x
oShepherdBody.y = oShepherdHome.y
}
if SleepingBegun = false {
if SleepTimerBegun = false {
StartSitting()
SleepTimerBegun = true
SleepTimer = irandom_range(120,200)
} else if SleepTimerBegun = true {
if AlertLevel &lt; 20 {
if SleepTimer &gt; 0 {
SleepTimer -= 1
} else {
StartSleeping()
SleepingBegun = true
RandomSleepChangeTimer = irandom_range(60,800)
}
}
}
} else if SleepingBegun = true {
if State = "sleeping" {
if RandomSleepChangeTimer &gt; 0 {
RandomSleepChangeTimer -= 1
} else {
StartSleeping() 
RandomSleepChangeTimer = irandom_range(60,800)
}
} else {
StartSleeping()
}
}
}
break;

//------------------------------------------------------------
case "patrol":
if PatrolPausing = false {
if PatrolTimer &gt; 0 {
PatrolTimer -= 1
if State != "walking" {
StartWalking()
}
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
WanderModLower = CurrentHeading - 30
WanderModHigher = CurrentHeading + 30
DesiredHeading = irandom_range(WanderModLower,WanderModHigher)
}

if instance_exists(tMole) {
if SensedMole = true and NearestMole.State = "grazing"
and NearestMole != LastRememberedMole
and PatrolPausing = false {
PatrolTimer = 0
PatrolPauseTimer = irandom_range(10,50) * AlertLevel
PatrolPausing = true
FidgetTimer = irandom_range(600,1500)
MolePausing = true
StartStanding()
if Facing = "right" {
DesiredHeading = 0
} else if Facing = "left" {
DesiredHeading = 180
}
}
}

} else {
PatrolTimer = 0
PatrolPauseTimer = irandom_range(10,50) * AlertLevel
PatrolPausing = true
FidgetTimer = irandom_range(600,1500)
StartStanding()
MolePausing = false
if Facing = "right" {
DesiredHeading = 0
} else if Facing = "left" {
DesiredHeading = 180
}
}
} else if PatrolPausing = true {
if PatrolPauseTimer &gt; 0 {
PatrolPauseTimer -= 1

if FidgetTimer &gt; 0 {
FidgetTimer -= 1
} else if FidgetTimer &lt;= 0 {
Fidget = choose(1,2,3,4,5)

if Fidget = 1 {
StartSitting()
} else if Fidget = 2 {
StartStanding()
} else if Fidget = 3 {
StartShaking(40,0.1 * AlertLevel)
} else if Fidget = 4 {
TurnBackAndForth(irandom_range(1,3),2)
} else if Fidget = 5 {
if AlertLevel &gt; 30 {
Call()
}
}
FidgetTimer = irandom_range(80,300)
}

if MolePausing = true and SensedMole = false {
PatrolPauseTimer = 0
PatrolTimer = irandom_range(1000,2000)
PatrolPausing = false
FidgetTimer = 0
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
MolePausing = false
}
} else {
PatrolPauseTimer = 0
PatrolTimer = irandom_range(1000,2000)
PatrolPausing = false
FidgetTimer = 0
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
MolePausing = false
}
}

break;
case "ritual":

break;
//------------------------------------------------------------
case "fishleft":

if FishSpotPicked = false {
Len = irandom_range((tEyeLeft.sprite_width / 2),80)
Dir = choose(irandom_range(45,80),irandom_range(100,150))

FishSpotX = tEyeLeft.x + lengthdir_x(Len,Dir)
FishSpotY = tEyeLeft.y + lengthdir_y(Len,Dir)
FishSpotPicked = true
}

DistanceToFishSpot = point_distance(oShepherdBody.x,oShepherdBody.y,FishSpotX,FishSpotY)

if FishBegun = false {
if DistanceToFishSpot &gt; 1 {
if State != "walking" {
StartWalking()
}
DesiredHeading = point_direction(oShepherdBody.x,oShepherdBody.y,FishSpotX,FishSpotY)
CurrentHeading = DesiredHeading
} else if DistanceToFishSpot &lt; 1 {
FishBegun = true 

if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &gt; 270 or point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &lt; 90 {
DesiredHeading = 0
} else if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &gt; 90 and point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &lt;= 270 {
DesiredHeading = 180
}
CurrentHeading = DesiredHeading
}

} else if FishBegun = true {
if State != "fishing" {
StartFishing()
} 
if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &gt; 270 or point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &lt; 90 {
DesiredHeading = 0
} else if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &gt; 90 and point_direction(oShepherdBody.x,oShepherdBody.y,tEyeLeft.x,tEyeLeft.y) &lt;= 270 {
DesiredHeading = 180
}
CurrentHeading = DesiredHeading

}
break;
//------------------------------------------------------------
case "fishright":
if FishSpotPicked = false {
Len = irandom_range((tEyeRight.sprite_width / 2),80)
Dir = choose(irandom_range(45,80),irandom_range(100,150))

FishSpotX = tEyeRight.x + lengthdir_x(Len,Dir)
FishSpotY = tEyeRight.y + lengthdir_y(Len,Dir)
FishSpotPicked = true
}

DistanceToFishSpot = point_distance(oShepherdBody.x,oShepherdBody.y,FishSpotX,FishSpotY)

if FishBegun = false {
if DistanceToFishSpot &gt; 1 {
if State != "walking" {
StartWalking()
}
DesiredHeading = point_direction(oShepherdBody.x,oShepherdBody.y,FishSpotX,FishSpotY)
CurrentHeading = DesiredHeading
} else if DistanceToFishSpot &lt; 1 {
FishBegun = true 

if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &gt; 270 or point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &lt; 90 {
DesiredHeading = 0
} else if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &gt; 90 and point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &lt;= 270 {
DesiredHeading = 180
}
CurrentHeading = DesiredHeading
}

} else if FishBegun = true {
if State != "fishing" {
StartFishing()
} 
if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &gt; 270 or point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &lt; 90 {
DesiredHeading = 0
} else if point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &gt; 90 and point_direction(oShepherdBody.x,oShepherdBody.y,tEyeRight.x,tEyeRight.y) &lt;= 270 {
DesiredHeading = 180
}
CurrentHeading = DesiredHeading
}

break;
case "herdsouth":


break;
case "sendnorth":

}
}
}

















/*

//--------------------------------------------------------------------------------------


//Hunting

if Hunting = true {

if DoneTurning = false {
TurnBackAndForth(2,60)
if DTTimer &gt; 0 {
DTTimer -= 1
} else if DTTimer &lt;= 0 {
DoneTurning = true
StartWalking()
}
} else if DoneTurning = true {

//Check (Always) For A Better Destination

if Checking = false {
if PlayerTouching = true {
HuntDest = tMousePointer
} else if instance_exists(tScentMarker) and point_distance(x,y,NearestScent.x,NearestScent.y) &lt;= SenseRadius {
HuntDest = NearestScent
} else if instance_exists(LastRememberedScent) {
HuntDest = LastRememberedScent
} else {
HuntDest = noone
}
}


//Move Towards Destination
if Checking = false {
if HuntDest != noone {
DesiredHeading = point_direction(x,y,HuntDest.x,HuntDest.y) 
} else {

}
}

//If reach destination, pause, turn back and forth and then repeat the better destination checking.
if HuntDest != noone and point_distance(x,y,HuntDest.x,HuntDest.y) &lt;= 20 {
if HuntDest != tMousePointer {
if Checking = false {
StartStanding()
TurnBackAndForth(3,30)
Checking = true
CheckTimer = 70
} else if Checking = true {
if CheckTimer &gt; 0 {
CheckTimer -= 1
} else {
Checking = false
CheckTimer = 0
HuntDest = noone
}
}

} else {
CurrentHeading = point_direction(x,y,HuntDest.x,HuntDest.y)
if CrookState != "jabbing" {
StartJabbing(5,100)
Hunting = false 
HuntingTimer = 0
DTTimer = 70
DoneTurning = false
StartFleeing(tMousePointer,2000)
Checking = false
CheckTimer = 0
}
}
}


if HuntingTimer &gt; 0 {
HuntingTimer -= 1
} else if HuntingTimer &lt;= 0 {
Hunting = false
HuntingTimer = 0
DTTimer = 70
DoneTurning = false
StartStanding()
Checking = false
CheckTimer = 0
}



}
}

//---------------------------------------------------------------------------------------

}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Behaviours

if Born = true {






BreathRate = OriginalBreathRate + BreathBeMod + (WalkingSpeed / 40) + ((4 / 100) * AlertLevel)
if tController.Temperature = "cold" {
TempSpeedMod = 1.5
} else {
TempSpeedMod = 1
}

//---------------------------------------------------------------
//WALKING
if State = "walking" {
BreathBeMod = 0.5
Walking()
WalkingSpeed = (40 + ((15 / 100) * AlertLevel)) / TempSpeedMod


//---------------------------------------------------------------------
//STANDING
} else if State = "standing" {
BreathBeMod = 0
Standing()

//-----------------------------------------------------------------------
//SITTING
} else if State = "sitting" {
BreathBeMod = -1
Sitting()

//------------------------------------------------------------------------
//SLEEPING/MEDITATING
} else if State = "sleeping" {
BreathBeMod = -1
Sleeping()

//-----------------------------------------------------------------------
//FISHING
} else if State = "fishing" {
BreathBeMod = -1
Fishing()

//------------------------------------------------------------------------
//TURN BACK AND FORTH
} else if State = "turnbackandforth" {
if TurnNumber &gt; 0 {
if TurnTimer &gt; 0 {
TurnTimer -= TurnSpeed
} else if TurnTimer &lt;= 0 {
TurnNumber -= 1
if TurnDir = 0 {
direction = 180 
TurnDir = 180
} else if TurnDir = 180 {
direction = 0
TurnDir = 0
}
TurnTimer = 60
}
} else {
if TurnDir = 0 {
DesiredHeading = 0
CurrentHeading = 0
} else if TurnDir = 180 {
DesiredHeading = 180
CurrentHeading = 180
}
StartStanding()
}


//------------------------------------------------------------------------
//FLEEING

} else if State = "fleeing" {
Fleeing()
BreathBeMod = 3
WalkingSpeed = (100 + ((15 / 100) * AlertLevel)) / TempSpeedMod
}

//------------------------------------------------------------------------
//MISCELLANEOUS BEHAVIOURS

Dropping()
PickingUp()

if MasterEyesShut = true {
oShepherdHead.EyesShut = true
}

if Calling = true {
if audio_is_playing(aMakeUsRich) {
if ShoutDir = "left" {
if ShoutMod &gt; -0.3 {
ShoutMod -= 0.3
} else if ShoutMod &lt;= -0.3 {
ShoutDir = "right"
}
} else if ShoutDir = "right" {
if ShoutMod &lt; 0.3 {
ShoutMod += 0.3
} else if ShoutMod &gt;= 0.3 {
ShoutDir = "left"
}
}
} else {
Calling = false
ShoutMod = 0
}
}

ShoutMod = clamp(ShoutMod,-2,2)

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Being Cut And Health

if tController.CurrentView = "in" 
and position_meeting(mouse_x,mouse_y,self.id) 
and tController.Knife = true
and tController.KnifeSpeed &gt; 0 {
Cutting = true 
} else {
Cutting = false
}

if Cutting = true {
Health -= 0.07
}

if Health &lt;= 0 {
tController.Destroyed = true
with oShepherdBody {
instance_destroy()
}
with oShepherdLegLeft {
instance_destroy()
}
with oShepherdLegRight {
instance_destroy()
}
with oShepherdCrook {
instance_destroy()
}
with oShepherdHead {
instance_destroy()
}
with oShepherdBag {
instance_destroy()
}
instance_destroy()
}

Health = clamp(Health,0,100)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Crook Micro-behaviours
if Born = true {
if CrookState != "none" {
if State = "walking" or State = "standing" or State = "fleeing" {

if CrookState = "shaking" {
Shaking()
}

if CrookState = "stamping" {
Stamping()
}

if CrookState = "jabbing" {
Jabbing()
}

} else {
CrookState = "none"
}

}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Staying On Body &amp; Collision

if Born = true {

///Then, Collision Avoidance &amp; Separation

if State != "turnbackandforth" and State != "fishing" {


if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}


if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}


if WoundAhead1 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,WoundAhead1.x,WoundAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead2 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,WoundAhead2.x,WoundAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead3 != noone {
//Turning
HeadingToCol = point_direction(oShepherdBody.x,oShepherdBody.y,WoundAhead3.x,WoundAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}


//Colliding 

if CollidingWall {
DistX = sign(oShepherdBody.x - CollidingWall.x)
DistY = sign(oShepherdBody.y - CollidingWall.y)
oShepherdBody.x += DistX
oShepherdBody.y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}

if CollidingWound {
DistX = sign(oShepherdBody.x - CollidingWound.x)
DistY = sign(oShepherdBody.y - CollidingWound.y)
oShepherdBody.x += DistX
oShepherdBody.y += DistY
CurrentHeading = point_direction(CollidingWound.x,CollidingWound.y,x,y)
DirectionChangeRate = 5
}


//Avoiding Edge Of Room
if GapAhead1 = true or GapAhead3 = true or GapAhead2 = true {
if GapAhead3 = true {
DesiredHeading = (CurrentHeading - 30)
} else if GapAhead1 = true {
DesiredHeading = (CurrentHeading + 30)
} else if GapAhead2 = true {
DesiredHeading = (CurrentHeading - 30)
}
}

//Clamping To Body
x = clamp(x,tHead.x - (tHead.sprite_width / 2),tHead.x + (tHead.sprite_width / 2))
y = clamp(y,tHead.y - (tHead.sprite_height / 2),tHead.y + (tHead.sprite_height / 2))


//Set Current Depth Depending On Nearby Moles
HighestColliderY = 0
HighestCollider = noone

with (tMole) {
if place_meeting(x,y,other) {
if oShepherdBody.y &gt; other.HighestColliderY {
other.HighestCollider = id
other.HighestColliderY = y
}
}
}

if HighestCollider != noone {
if HighestColliderY &gt; oShepherdBody.y {
BaseDepth = HighestCollider.depth + 0.0001
} else {
BaseDepth = OriginalDepth
}
} else {
BaseDepth = OriginalDepth
}

depth = oShepherdParent.BaseDepth - 0.00001
with oShepherdBody {
depth = oShepherdParent.BaseDepth - 0.00002
}
with oShepherdLegRight {
depth = oShepherdParent.BaseDepth - 0.00003
}
with oShepherdLegLeft {
depth = oShepherdParent.BaseDepth - 0.00004
}
with oShepherdCrook {
depth = oShepherdParent.BaseDepth - 0.00005
}
with oShepherdBag {
depth = oShepherdParent.BaseDepth - 0.000015
}

}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Coming To Desired Speed And Direction

//Speed
//if CurrentSpeed != DesiredSpeed {
if CurrentSpeed &lt; DesiredSpeed {
CurrentSpeed += SpeedChangeRate
} else if CurrentSpeed &gt; DesiredSpeed {
CurrentSpeed -= SpeedChangeRate
}
//}

oShepherdBody.hspeed = CurrentSpeed
oShepherdBody.vspeed = CurrentSpeed

//Direction

if State != "turnbackandforth" {
if CurrentHeading &gt; DesiredHeading
or CurrentHeading &lt; DesiredHeading
{
if sign(angle_difference(CurrentHeading,DesiredHeading)) = -1 {
CurrentHeading += DirectionChangeRate
} else if sign(angle_difference(CurrentHeading,DesiredHeading)) = 1 {
CurrentHeading -= DirectionChangeRate
}
} 
if CurrentHeading = 90 {
CurrentHeading = 89
}
if CurrentHeading = 270 {
CurrentHeading = 269
}


oShepherdBody.direction = CurrentHeading
direction = CurrentHeading
}



if (direction &gt; 270 and direction &lt;= 360) or (direction &gt;= 0 and direction &lt;= 90) {
Facing = "right"
} else {
Facing = "left"
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Test Controls

if Born = false {
if keyboard_check_pressed(ord('B')) {
oShepherdBody.x = oShepherdHome.x
oShepherdBody.y = oShepherdHome.y
oShepherdBody.BaseY = oShepherdHome.y
Born = true
}
}


if keyboard_check_pressed(ord('W')) {
StartWalking()
}

if keyboard_check_pressed(ord('A')) {
StartStanding()
}

if keyboard_check_pressed(ord('S')) {
StartSitting()
}

if keyboard_check_pressed(ord('C')) {
StartSleeping()
}

if keyboard_check_pressed(ord('F')) {
StartFishing()
}

if keyboard_check_pressed(ord('K')) {
StartStamping(3,3)
}

if keyboard_check_pressed(ord('L')) {
StartShaking(60,3)
}

if keyboard_check_pressed(ord('J')) {
StartJabbing(3,1)
}

if keyboard_check_pressed(ord('U')) {
TurnBackAndForth(3,5)
}




//Basic Controls (TO REMOVE *************)
if keyboard_check(ord('Q')) {
DesiredHeading = point_direction(x,y,mouse_x,mouse_y)
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing With Zoom &amp; UI

if tController.CurrentView = "out" {
with oShepherdBody {
draw_sprite_ext(sShepherdOut,0,x,y,0.3,0.3,0,c_white,1)
}
} else if tController.CurrentView = "in" {
with sShepherdFootprint {
draw_self()
}
with oShepherdCrook {
draw_self()
draw_line_colour(LineStartX,LineStartY,LineEndX,LineEndY,c_black,c_black)
}
with oShepherdLegLeft {
draw_self()
}
with oShepherdLegRight {
draw_self()
}
with oShepherdBody {
draw_self()
}
with oShepherdBag {
draw_self()
}
with oShepherdHead {
///Draw Self And Eyes
draw_self()
draw_sprite_ext(CurrentEyes,0,EyeX,EyeY,0.3,0.3 - ((0.3 / 100) * BlinkPercent),image_angle,c_white,1)
}
}

//Drawing UI

if tController.ChosenMole = self.id {
draw_set_colour(c_lime)
draw_set_alpha(0.7)

PosX = oShepherdBody.x
PosY = oShepherdBody.y

draw_circle(PosX,PosY,SenseRadius,true)


draw_set_color(c_purple)
draw_line(PosX,PosY,ColPointXM,ColPointYM)
draw_line(PosX,PosY,ColPointXL,ColPointYL)
draw_line(PosX,PosY,ColPointXR,ColPointYR)
draw_set_colour(c_blue)
draw_line(x,y,x + lengthdir_x(40,DesiredHeading),y + lengthdir_y(40,DesiredHeading))
draw_set_colour(c_red)


draw_set_halign(fa_center)
draw_set_valign(fa_center)
draw_set_color(c_red)
draw_set_alpha(1)
draw_set_font(fMoleIn)

PosY -= (SenseRadius + 18)

draw_line(PosX - 30,PosY - 3,PosX - 30,PosY + 3)
draw_line(PosX + 30,PosY - 3,PosX + 30,PosY + 3)
draw_line(PosX - 30,PosY,((PosX - 30) + ((60 / 100) * AlertLevel)),PosY)

PosY -= 15
draw_text(PosX,PosY,"Alert Level")

PosY -= 18
draw_text(PosX,PosY,State)
PosY -= 18 
draw_text(PosX,PosY,"Platonic Goal: " + PlatonicGoal)
PosY -= 18
draw_text(PosX,PosY,"Distance: " + string(point_distance(oShepherdBody.x,oShepherdBody.y + 10,oShepherdHome.x,oShepherdHome.y)))



if State = "turnbackandforth" {
PosY -= 18 
draw_text(PosX,PosY,string(TurnTimer))
PosY -= 18 
draw_text(PosX,PosY,string(TurnNumber) + " turns left")
}


PosY -= 18
draw_text(PosX,PosY,CrookState)
if SensedFur = true {
PosY -= 18
draw_text(PosX,PosY,"sensed fur")
} else {
PosY -= 18
draw_text(PosX,PosY,"no fur")
}
if SensedMole = true {
PosY -= 18
draw_text(PosX,PosY,"sensed mole")
} else {
PosY -= 18
draw_text(PosX,PosY,"no moles")
}

if SensedScent = true {
PosY -= 18
draw_text(PosX,PosY,"sensed scent")
} else {
PosY -= 18
draw_text(PosX,PosY,"no scent")
}
if PlayerTouching = true {
PosY -= 18
draw_text(PosX,PosY,"player touching")
} else {
PosY -= 18
draw_text(PosX,PosY,"no player touching")
}
if GapAhead1 = true or GapAhead2 = true or GapAhead3 = true {
PosY -= 18
draw_text(PosX,PosY,"Gap Ahead")
}
if CollisionAhead1 != noone or CollisionAhead2 != noone or CollisionAhead3 != noone {
PosY -= 18
draw_text(PosX,PosY,"Collision Ahead")
}
PosY -= 18
draw_text(PosX,PosY,"Items In Bag: " + string(oShepherdBag.BagNumber))

PosY -= 18
draw_text(PosX,PosY,"Desired Speed: " + string(DesiredSpeed))
PosY -= 18
draw_text(PosX,PosY,"Current Speed: " + string(CurrentSpeed))
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
