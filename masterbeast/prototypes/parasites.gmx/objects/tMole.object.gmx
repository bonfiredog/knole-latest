<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sMoleSmall</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

Size = choose("small","med","large")

if Size = "small" {
depth = random_range(0.3,0.4)
image_xscale = random_range(0.05,0.1)
image_yscale = 0
} else if Size = "med" {
depth = random_range(0.5,0.6)
image_xscale = random_range(0.15,0.2)
image_yscale = 0
} else if Size = "large" {
image_xscale = random_range(0.25,0.3)
image_yscale = 0
depth = random_range(0.7,0.8)
}

OriginalDepth = depth
OriginalXScale = image_xscale
OriginalYScale = image_xscale
GrownToSize = false
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
ZOutScale = OriginalXScale * 5
Drawing = true
SeedClusterer = false
ClusterTimer = 3500
ClusterParent = noone
ClusterStopped = false

//Growing

GrowMax = OriginalXScale + 0.35
GrowRate = random_range(0.000002,0.000003)
OriginalGrowRate = GrowRate
EatingGrowRate = GrowRate * 1.5

//Senses
SenseRadius = 90
ClusterRadius = 60 * OriginalXScale
MaxChildren = round(100 * OriginalXScale)
CurrentChildren = 0
BabyCreateLower = 2000 * OriginalXScale
BabyCreateHigher = 4000 * OriginalXScale
BabyTimer = 0
SensedMole = false
LastRememberedMole = noone
NearestMole = noone
SensedFur = false
LastRememberedFur = noone
NearestFur = noone
SensedWound = false
LastRememberedWound = noone
WoundOfInterest = noone
NearestWound = noone
GapAhead1 = false
GapAhead2 = false
GapAhead3 = false
WoundAhead1 = false
WoundAhead2 = false
WoundAhead3 = false 
CollidingWound = false
CollidingWall = false

if tController.Temperature = "cold" {
TempSpeedMod = -0.35
LonelyMod = 2
} else if tController.Temperature = "warm" {
TempSpeedMod = 0
LonelyMod = 1
} else if tController.Temperature = "hot" {
TempSpeedMod = 0.35
LonelyMod = 1
}


//Drives &amp; States

State = "grazing"

Hunger = 0
HungerChangeMod = 1
HungerLatch = 40
Loneliness = 0
LonelinessLatch = 40
Energy = 0
EnergyLatch = 20
FleeTimer = 0
TempSpeedMod = 0
TabooArea = false
FavouredArea = false
Activating = false
WakingUp = true
WakingTimer = 0

//Behaviours

GrazingSpeed = 5 / room_speed
GrazeX = x
GrazeY = y
GrazeRadius = 100
Pausing = false
GrazeTimer = 60
GrazePauseTimer = 300
GrazePTLower = 150 
GrazePTUpper = 400
GrazeTLower = 200
GrazeTUpper = 500 

WanderSpeed = 15 / room_speed
WanderRange = 200
WanderRadius = 700
BaseWanderRadius = 700
WanderStartX = x
WanderStartY = y
DitherMod = 2
AlignVar = 0
SepVar = 0
Neighbours = 0
CurrentlyHunting = "food"
MoleProx = 60
WoundProx = sprite_width * 2
WanderTimer = 300
WanderPauseTimer = 100
WanderPTLower = 60 
WanderPTUpper = 180
WanderTLower = 2000
WanderTUpper = 3000
CallOrNot = 0
Called = false

FleeSpeed = 35 / room_speed
SourceOfFear = noone
ContagTimer = 0
Contaged = false
FleeModRange = 50
GoneOffScreen = false

ShiverTimer = 0
ShiverDirection = "left"
ShiverOrNot = 0
XOffset = 0

ViewSpeedMod = 0
SpeedMod = 1
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.5
DesiredHeading = random(360)
DirectionChangeRate = 1
Slowdown = 0.5

FollowingShepherd = false

//Collision

CollisionLength = 50
GapLength = 25
CollisionWidth = 35
CollisionAhead1 = noone
CollisionAhead2 = noone
CollisionAhead3 = noone
Turning = false
ColPointXM = 0
ColPointYM = 0
ColPointXL = 0
ColPointYL = 0
ColPointXR = 0
ColPointYR = 0

//Picking
CutAmount = 0
Redness = 0
Cutting = false

//Initialise!
CurrentSpeed = DesiredSpeed
CurrentHeading = DesiredHeading
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Changing Sprites Depending On View

HungerMod = abs(100 - Hunger)
HungerMod = clamp(HungerMod,1,100)

if tController.CurrentView = "out" {
sprite_index = sMoleSmall
image_xscale = ZOutScale + (((OriginalXScale / 2) / 100) * HungerMod)
if GrownToSize = true {
image_yscale = ZOutScale + (((OriginalXScale / 2) / 100) * HungerMod)
}
} else if tController.CurrentView = "in" {
sprite_index = sMoleBig
image_xscale = BaseXScale + (((OriginalXScale / 2) / 100) * HungerMod)
if GrownToSize = true {
image_yscale = BaseYScale + (((OriginalXScale / 2) / 100) * HungerMod)
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Growing

switch tController.TimeOfDay {
case "morning":
LonelyDayMod = 1
SenseRadius = 60
break;
case "afternoon":
LonelyDayMod = 1
SenseRadius = 60
break;
case "evening":
LonelyDayMod = 2
SenseRadius = 40
break;
case "night":
LonelyDayMod = 3
SenseRadius = 30
break;
}

switch tController.Temperature {
case "cold":
GrowMod = 0.5
break;
case "warm":
GrowMod = 1
break;
case "hot":
GrowMod = 1.5
break;
}



if GrownToSize = false {
if Energy &gt; 0 {
if image_xscale &lt; GrowMax {
if State != "eating" {
BaseXScale += GrowRate * GrowMod
BaseYScale += GrowRate * GrowMod
} else {
BaseXScale += EatingGrowRate * GrowMod
BaseYScale += EatingGrowRate * GrowMod
}
}
}
}

ZOutScale = BaseXScale * 5













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Senses &amp; Memory

if Energy &gt; 0 {

//Collision Sensing

ColPointXM = x + lengthdir_x(CollisionLength,CurrentHeading)
ColPointYM = y + lengthdir_y(CollisionLength,CurrentHeading)
ColPointXL = x + lengthdir_x(CollisionLength,CurrentHeading - CollisionWidth)
ColPointYL = y + lengthdir_y(CollisionLength,CurrentHeading - CollisionWidth)
ColPointXR = x + lengthdir_x(CollisionLength,CurrentHeading + CollisionWidth)
ColPointYR = y + lengthdir_y(CollisionLength,CurrentHeading + CollisionWidth)

GapPointXM = x + lengthdir_x(GapLength,CurrentHeading)
GapPointYM = y + lengthdir_y(GapLength,CurrentHeading)
GapPointXL = x + lengthdir_x(GapLength,CurrentHeading - CollisionWidth)
GapPointYL = y + lengthdir_y(GapLength,CurrentHeading - CollisionWidth)
GapPointXR = x + lengthdir_x(GapLength,CurrentHeading + CollisionWidth)
GapPointYR = y + lengthdir_y(GapLength,CurrentHeading + CollisionWidth)

CollisionAhead1 = collision_line(x,y,ColPointXM,ColPointYM,tCollision,true,true)
CollisionAhead2 = collision_line(x,y,ColPointXL,ColPointYL,tCollision,true,true)
CollisionAhead3 = collision_line(x,y,ColPointXR,ColPointYR,tCollision,true,true)
WoundAhead1 = collision_line(x,y,ColPointXM,ColPointYM,tWound,true,true)
WoundAhead2 = collision_line(x,y,ColPointXL,ColPointYL,tWound,true,true)
WoundAhead3 = collision_line(x,y,ColPointXR,ColPointYR,tWound,true,true)


if collision_point(GapPointXL,GapPointYL,tHead,true,true) = noone {
GapAhead1 = true
} else {
GapAhead1 = false
}

if collision_point(GapPointXM,GapPointYM,tHead,true,true) = noone {
GapAhead2 = true
} else {
GapAhead2 = false
}

if collision_point(GapPointXR,GapPointYR,tHead,true,true) = noone {
GapAhead3 = true
} else {
GapAhead3 = false
}

CollidingWall = instance_place(x + hspeed,y + vspeed,tCollision)
CollidingWound = instance_place(x + hspeed,y + vspeed,tWound)
CollidingMole = instance_place(x + hspeed,y + vspeed, tMole)

//Temperature Sensing

if tController.Temperature = "cold" {
TempSpeedMod = -0.35
LonelyMod = 2
} else if tController.Temperature = "warm" {
TempSpeedMod = 0
LonelyMod = 1
} else if tController.Temperature = "hot" {
TempSpeedMod = 0.35
LonelyMod = 1
}

//Viewport Speed Mod

if tController.CurrentView = "out" {
ViewSpeedMod = 0.07
} else if tController.CurrentView = "in" {
ViewSpeedMod = 1
}

//Always note where the nearest POI is.

NearestMole = instance_nth_nearest(tMole,x,y,2)
NearestFur = instance_nearest(x,y,tFurRegion)
NearestWound = instance_nearest(x,y,tWound)


//As long as has energy, detect whether a certain POI is within 
//the sense radius, and update memory of where the last-seen POI is.

if distance_to_object(NearestMole) &lt;= SenseRadius {
SensedMole = true
LastRememberedMole = NearestMole
} else {
SensedMole = false
}

if distance_to_object(NearestFur) &lt;= SenseRadius {
SensedFur = true
LastRememberedFur = NearestFur
} else {
SensedFur = false
}

if instance_exists(tWound) {
if distance_to_object(NearestWound) &lt;= SenseRadius {
SensedWound = true 
LastRememberedWound = NearestWound
} else {
SensedWound = false
}
}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Activation By Shepherd

if Energy &lt;= 0 and point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt; 100
and oShepherdParent.CrookState = "shaking" {
Energy = 100
WakingUp = true
WakingTimer = irandom_range(60,120)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Picking
if GrownToSize = true {
if tController.CurrentView = "in" {
if position_meeting(mouse_x,mouse_y,self.id) 
and tController.Knife = true
and tController.KnifeSpeed &gt; 0 {
Cutting = true 
} else {
Cutting = false
}

if Cutting = true {
CutAmount += 7
if Energy &gt; 0 {
if State != "fleeing" {
if State = "clustering" and SeedClusterer = true {
tController.Clusters -= 1
}
State = "fleeing"
Contaged = false
GoneOffScreen = false
SourceOfFear = tMousePointer
DesiredHeading = random(360)
Pausing = false
}
FleeTimer += 300
}
}

if CutAmount &gt;= 100 {
ThisPicked = instance_create(mouse_x,mouse_y,tMolePicked)
ThisPicked.image_xscale = image_xscale + 0.03
ThisPicked.image_yscale = ThisPicked.image_xscale
ThisHole = instance_create(x,y,tMoleHole)
ThisHole.OutScale = ZOutScale
ThisHole.InScale = BaseXScale
instance_destroy()
}
}
}

CutAmount = clamp(CutAmount,0,100)
Redness = CutAmount / 100

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drives

if GrownToSize = true and WakingUp = false {

if State = "grazing" {
HungerChangeMod = 1
EnergySpeedMod = 1
} else if State = "wandering" {
HungerChangeMod = 1.1
EnergySpeedMod = 1.1
} else if State =  "fleeing" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
} else if State = "clustering" {
HungerChangeMod = 0.5
EnergySpeedMod = 0
} else if State = "following" {
HungerChangeMod = 1.5
EnergySpeedMod = 1.5
}

if Energy &gt; 0 {

//Hunger

//Hunger goes up at all times, apart from when eating, when it goes down.

if State != "eating" and State != "clustering" {
Hunger += tController.HungerChangeRate * HungerChangeMod
} else if State = "eating" {
Hunger -= tController.HungerChangeRate * 1.5
}

//Loneliness 

//Loneliness goes up when away from others, down when near to others.

if State != "clustering" {
if SensedMole = false or point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &gt;= SenseRadius {
Loneliness += (tController.LonelyChangeRate * LonelyDayMod) * LonelyMod
} else {
Loneliness -= (tController.LonelyChangeRate * 10) * LonelyDayMod
}
}

//Energy

//Energy down at all times at certain rate, apart from when eating or clustering.

EnergyMod = 1 + (Loneliness / 1000) + (Hunger / 1000) + EnergySpeedMod

if State = "eating"  {
Energy += tController.EnergyChangeRate * 4
} else if State = "clustering" {
} else {
Energy -= tController.EnergyChangeRate * EnergyMod
}


//Fear


//When Started Fleeing, Allow The Timer To Go Down If They Have Already Disappeared OffScreen ONCE,
//Or the user has zoomed out.

if State = "fleeing" {
if GoneOffScreen = false {
if tController.CurrentView = "out" or
(tController.CurrentView = "in" and 
(x &lt; view_xview[1] 
or x &gt; (view_xview[1] + view_wview[1])
or y &lt; view_yview[1] 
or y &gt; (view_yview[1] + view_hview[1])
)
)
{
GoneOffScreen = true
}
}
}



//When fleeing, count down the flee timer - if it reaches zero, reset and go back to grazing.

if State = "fleeing" {
if FleeTimer &gt; 0 {
if tController.CurrentView = "out"
or (tController.CurrentView = "in" and GoneOffScreen = true) {
FleeTimer -= 1
}
} else if FleeTimer &lt;= 0 {
GoneOffScreen = false
if Contaged = true {
ContagTimer = 300
}
CallOrNot = choose(-1,1,-1,-1)
FleeTimer = 0
DesiredSpeed = 0
SpeedChangeRate = 0.01
ShiverOrNot = choose(-1,1)
if ShiverOrNot = 1 {
State = "shivering"
ShiverTimer = random_range(100,400) * (GrowMax * 5)
} else {
SourceOfFear = noone
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
State = "grazing"
}
}
}

//The timeout to stop emotional contagion triggering constantly, leading to panic stasis in a crowd.
if ContagTimer &gt; 0 {
ContagTimer -= 1
}



//Clustering
//If in range of a clusterer, and not clustering, begin clustering, and set that clusterer as your parent.

if State != "clustering" {
if SensedMole = true {
with tMole {
if point_distance(x,y,other.x,other.y) &lt;= other.SenseRadius {
if SeedClusterer = true {
if other.OriginalXScale &lt;= OriginalXScale {
if CurrentChildren &lt; MaxChildren {
other.State = "clustering"
CurrentChildren += 1
other.ClusterStopped = false
other.ClusterParent = id
other.CVal = irandom_range(ClusterRadius - 2, ClusterRadius + 2)
other.ClusterPointX = x + lengthdir_x(other.CVal,random(360))
other.ClusterPointY = y + lengthdir_y(other.CVal,random(360))
}
}
}
}
}
}
}


//--------------------------------------

//Action Plan


//Running if a nearby mole is scared (Emotional Contagion)
if NearestMole != noone {
if SensedMole = true {
if ContagTimer &lt;= 0 {
if NearestMole.State = "fleeing" and NearestMole.FleeTimer &gt; 100 and State != "fleeing" {
SourceOfFear = NearestMole
State = "fleeing"
Pausing = false
Contaged = true
GoneOffScreen = false
FleeTimer = 199 * (GrowMax * 5)
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
DesiredHeading = point_direction(NearestMole.x,NearestMole.y,x,y) + (random_range(-30,30))
CurrentHeading = DesiredHeading
}
}
}
}

//If clustering, and the Shepherd is nearby and stamps, break apart, and maybe flee.
if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= SenseRadius 
and State = "clustering" 
and oShepherdParent.CrookState = "stamping"  or oShepherdParent.CrookState = "jabbing"
{
FleeOrNot = choose(-1,-1,1)
if SeedClusterer = true {
SeedClusterer = false
ClusterTimer = 8000
tController.Clusters -= 1
CurrentChildren = 0
} else {
ClusterParent = noone
CurrentChildren = 0
}
if FleeOrNot = -1 {
State = "grazing"
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
} else if FleeOrNot = 1 {
SourceOfFear = oShepherdBody
State = "fleeing"
GoneOffScreen = false
Pausing = false
Contaged = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 100 * (GrowMax * 5)
}
}

//Treat the Shepherd as a grazing/wander area
if State = "grazing" {
if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= GrazeRadius
{ 
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
}
} else if State = "wandering" {
if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= WanderRadius {
WanderX = oShepherdBody.x
WanderY = oShepherdBody.y
}
}



//If Shepherd jabs or stamps nearby, always flee (unless clustering), but less far if stamped.
if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= SenseRadius 
and State != "clustering" 
and oShepherdParent.CrookState = "stamping"  or oShepherdParent.CrookState = "jabbing"
{
SourceOfFear = oShepherdBody
State = "fleeing"
Pausing = false
GoneOffScreen = false
Contaged = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
if oShepherdParent.CrookState = "stamping" {
FleeTimer = 30 * (GrowMax * 5)
} else if oShepherdParent.CrookState = "jabbing" {
FleeTimer = 100 * (GrowMax * 5)
}
}

//If Loneliness is High enough, or it is night-time, and the Shepherd comes into view, start following. 
if tController.TimeOfDay = "night" 
and point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= SenseRadius
and State != "fleeing" and State != "clustering" and State != "following" {
State = "following"
}


// Stop following if loneliness is down enough, or it becomes daytime.
if State = "following" 
and tController.TimeOfDay = "day"
{
State = "grazing" 
GrazeX = x
GrazeY = y
}

//If the nearest wound is new (i.e. not of the latest interest), move
//towards it to investigate, then disregard it.

if instance_exists(tWound) {
if SensedWound = true {
if WoundOfInterest != NearestWound {
if State = "grazing" or (State = "wandering" and CurrentlyHunting != "food") {
if point_distance(x,y,NearestWound.x,NearestWound.y) &gt; (sprite_width / 2) + 30 {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)
if State = "grazing" {
CurrentHeading = DesiredHeading
}
} else {
WoundOfInterest = NearestWound
}
}
}
}
}

//Attracted Areas - if grazing or wandering, and the parent object is in range,
//set this as a new graze point or wander point.
if State = "grazing" or State = "wandering" {
if instance_exists(tFavouredParent) {
ClosestFavour = instance_nearest(x,y,tFavouredParent)
if point_distance(x,y,ClosestFavour.x,ClosestFavour.y) &lt;= (SenseRadius + (ClosestFavour.sprite_width / 2)) {
if State = "grazing" {
GrazeX = ClosestFavour.x
GrazeY = ClosestFavour.y
} else if State = "wandering" {
WanderStartX = ClosestFavour.x
WanderStartY = ClosestFavour.y
}
}
}
}

//Taboo Areas - if clustering and seed, if fleeing/grazing or wandering, and parent object is in range,
//move directly away from it until out of sight.

if State = "grazing" or State = "wandering" or (State = "clustering" and SeedClusterer = true) or State = "fleeing" {
if instance_exists(tTabooParent) {
ClosestTaboo = instance_nearest(x,y,tTabooParent)
if point_distance(x,y,ClosestTaboo.x,ClosestTaboo.y) &lt;= (SenseRadius + (ClosestTaboo.sprite_width / 2)) {
Pausing = false
DesiredHeading = point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y)
if State = "grazing" {
CurrentHeading = DesiredHeading
GrazeTimer = 20
GrazeX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
GrazeY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
} else if State = "wandering" {
WanderTimer = 20
WanderX = ClosestTaboo.x + lengthdir_x(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
WanderY = ClosestTaboo.y + lengthdir_y(ClosestTaboo.sprite_width / 2,point_direction(ClosestTaboo.x,ClosestTaboo.y,x,y))
}
if State = "clustering" {
DoNotClusterHere = true
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
} else {
if State = "clustering" {
DoNotClusterHere = false
}
}
}


//Run if come into contact with player scent.
ScentInContact = instance_place(x,y,tScentMarker)
if ScentInContact and State != "fleeing" and State != "clustering" {
SourceOfFear = ScentInContact
State = "fleeing"
Pausing = false
Contaged = false
GoneOffScreen = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 100 * (GrowMax * 5)
}

//Run if a Picked Mole is held overhead.

if instance_exists(tMolePicked) {
if point_distance(x,y,tMolePicked.x,tMolePicked.y) &lt;= SenseRadius {
Pausing = false
SourceOfFear = tMolePicked
State = "fleeing"
Contaged = false
GoneOffScreen = false
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
FleeTimer = 300 * (GrowMax * 5)
}
}


//Begin wandering if hungry or lonely (hunger wins).
if State != "fleeing" and State != "clustering" and State != "eating" and State != "shivering" and State != "following" {

if Hunger &gt;= HungerLatch {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering"
CurrentlyHunting = "food" 
if LastRememberedWound != noone and instance_exists(LastRememberedWound) {
DesiredHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}

if Loneliness &gt;= LonelinessLatch and SensedMole = false {
//Pausing = false
if State != "wandering" {
WanderStartX = x
WanderStartY = y
}
State = "wandering" 
CurrentlyHunting = "moles"
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
DesiredHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
if State != "wandering" {
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}
}
}



}
}




Hunger = clamp(Hunger,0,100)
Loneliness = clamp(Loneliness,0,100)
Energy = clamp(Energy,0,100)
FleeTimer = clamp(FleeTimer,0,700)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Behaviours

//Shivering when waking up
if WakingUp = true {
if WakingTimer &gt; 0 {
WakingTimer -= 1
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
} else {
WakingTimer = 0
WakingUp = false
}
} else if WakingUp = false {

///Top Speed Affected By Current Energy Level
SpeedMod = (1 - (0.7 - ((0.7 / 100) * Energy)) + TempSpeedMod) * ViewSpeedMod

if GrownToSize = true {

//Make sure that seed clustering is reset if, for any reason, the state changes.
if State != "clustering" {
if SeedClusterer = true {
SeedClusterer = false 
ClusterTimer = 8000
}
}

//As long as we are alive, do these behaviours.
if Energy &gt; 0 {

// FLEEING ---------------------------------------------------------------------
if State = "fleeing" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
if place_meeting(x,y,tFurRegion) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.01

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),tFurRegion) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}
} else {
if place_meeting(x,y,tFurRegion) = false {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.04

if SensedFur = false {
if LastRememberedFur != noone and instance_exists(LastRememberedFur) {
FurDirection = point_direction(x,y,LastRememberedFur.x,LastRememberedFur.y)
DesiredHeading = FurDirection
} else {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
FleeModLower = CurrentHeading - (FleeModRange / 2)
FleeModHigher = CurrentHeading + (FleeModRange / 2)
DesiredHeading = (random_range(FleeModLower,FleeModHigher))
}
}
} else if SensedFur = true {
DesiredHeading = point_direction(x,y,NearestFur.x,NearestFur.y)
}
} else if place_meeting(x + lengthdir_x(30,direction - 180),y + lengthdir_y(30,direction-180),tFurRegion) {
DesiredSpeed = 0 
SpeedChangeRate = 0.02
FleeTimer = 0
State = "shivering"
ShiverTimer = random_range(400,800)
}
}

// GRAZING ---------------------------------------------------------------------
} else if State = "grazing" {

DesiredSpeed = GrazingSpeed * SpeedMod
DirectionChangeRate = 1
SpeedChangeRate = 0.003

if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
}

//Wander in a direction, pause, then change direction.
if Pausing = false {
if GrazeTimer &gt; 0 {
GrazeTimer -= 1 
} else if GrazeTimer &lt;= 0 {
CallOrNot = choose(-1,1)
Called = false
CallWaitTimer = random_range(40,80)
Pausing = true
GrazePauseTimer = random_range(GrazePTLower,GrazePTUpper)
GrazeTimer = 0
}
} else if Pausing = true {
if GrazePauseTimer &gt; 0 {
GrazePauseTimer -= 1
} else if GrazePauseTimer &lt;= 0 {
Pausing = false
GrazeTimer = random_range(GrazeTLower,GrazeTUpper)
DesiredHeading = random(360)
CurrentHeading = DesiredHeading
}
}

//If reach the current graze boundary, turn back.
if SensedMole = false {
if point_distance(x,y,GrazeX,GrazeY) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
} else {
if point_distance(NearestMole.x,NearestMole.y,x,y) &gt; GrazeRadius {
DesiredHeading = point_direction(x,y,GrazeX,GrazeY)
CurrentHeading = DesiredHeading
}
}

// WANDERING --------------------------------------------------------------------
} else if State = "wandering" {

DirectionChangeRate = 1
SpeedChangeRate = 0.008

if SensedMole = false {
if Pausing = false {
if WanderTimer &gt; 0 {
WanderTimer -= 1
} else if WanderTimer &lt;= 0 {
if CurrentlyHunting = "moles" {
CallOrNot = choose(-1,1)
} else {
CallOrNot = -1
}
Called = false
CallWaitTimer = random_range(40,80)
WanderPauseTimer = random_range(WanderPTLower,WanderPTUpper)
Pausing = true 
}
} else if Pausing = true {
if WanderPauseTimer &gt; 0 {
WanderPauseTimer -= 1
} else if WanderPauseTimer &lt;= 0 {
WanderTimer = random_range(WanderTLower,WanderTUpper)
Pausing = false
}
}
} else {
Pausing = false
}

if CurrentlyHunting = "food" {
DesiredSpeed = WanderSpeed * SpeedMod
} else if CurrentlyHunting = "moles" {
DesiredSpeed = WanderSpeed * SpeedMod
} else {
DesiredSpeed = WanderSpeed * SpeedMod
}


if Loneliness &lt; 70 {
WanderRadius = BaseWanderRadius
} else {
WanderRadius = BaseWanderRadius / 2
}



//Reset Flocking Variables
AlignVar = 0
CohVar = 0
SepVar = 0
Neighbours = 0

if CollidingWall = noone and CollisionAhead1 = noone and CollisionAhead2 = noone and CollisionAhead3 = noone and TabooArea = false
and GapAhead1 = false and GapAhead2 = false and GapAhead3 = false
{
with tMole {
//Alignment Calculation
NDistance = point_distance(other.x,other.y,x,y)
if (id != other.id) and (NDistance &lt;= other.SenseRadius) { 
other.AlignVar += CurrentHeading
other.CohVar += point_direction(other.x,other.y,x,y)
other.SepVar += point_direction(x,y,other.x,other.y)
other.Neighbours += 1
}
}

if CurrentlyHunting = "food" {
if LastRememberedWound != noone and instance_exists(LastRememberedWound){
HuntingHeading = point_direction(x,y,LastRememberedWound.x,LastRememberedWound.y)
} else {
HuntingHeading = CurrentHeading
}
} else if CurrentlyHunting = "moles" {
if LastRememberedMole != noone and instance_exists(LastRememberedMole){
HuntingHeading = point_direction(x,y,LastRememberedMole.x,LastRememberedMole.y)
} else {
HuntingHeading = CurrentHeading
}
} else {
HuntingHeading = CurrentHeading
}

//Desired Heading With Flocking (Ignore Search)
if Neighbours &gt; 0 {
AverageHeading = ((AlignVar / Neighbours) + (CohVar / Neighbours) + (SepVar / Neighbours))  / 3
DesiredHeading = AverageHeading //+ irandom_range(((WanderRange / 2) * -1),(WanderRange / 2))
DirectionChangeRate = 5
//Desired Heading Without Flocking (Active Search)
} else if Neighbours &lt;= 0 {
ChangeDirection = irandom_range(1,15)
if ChangeDirection = 15 {
WanderModLower = HuntingHeading - (WanderRange / 2)
WanderModHigher = HuntingHeading + (WanderRange / 2)
DesiredHeading = irandom_range(WanderModLower,WanderModHigher)
}
}
}

//Seek Thing And Arrive If In Sense Radius
if CurrentlyHunting = "food" {
if SensedWound = true {
DirectionChangeRate = 5
if instance_exists(NearestWound) {
DesiredHeading = point_direction(x,y,NearestWound.x,NearestWound.y)

DesiredSpeed = ((WanderSpeed * 3) * ((distance_to_object(NearestWound) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if distance_to_object(NearestWound) &lt;= 0 {
DesiredSpeed = 0
CurrentSpeed = 0
State = "eating"
}
}
}


} else if CurrentlyHunting = "moles" {
if SensedMole = true {
DirectionChangeRate = 5
if instance_exists(NearestMole) {
DesiredHeading = point_direction(x,y,NearestMole.x,NearestMole.y)

DesiredSpeed = ((WanderSpeed * 3) * ((distance_to_object(NearestMole) + 12) / SenseRadius )) * SpeedMod
CurrentSpeed = DesiredSpeed

if instance_exists(NearestMole) 
and point_distance(x,y,NearestMole.x,NearestMole.y) &lt;= MoleProx {
GrazeX = x
GrazeY = y
DesiredSpeed = 0
CurrentSpeed = 0
Loneliness = 0
State = "grazing"
}
}
}
}


//Turn Back If Outside Wander Radius
if point_distance(x,y,WanderStartX,WanderStartY) &gt; WanderRadius {
CurrentHeading = point_direction(x,y,WanderStartX,WanderStartY)
}



// EATING -----------------------------------------------------------------------

} else if State = "eating" {

DesiredSpeed = 0
SpeedChangeRate = 0.01

//If sated, stop eating and 'detach'.
if Hunger &lt;= 0 or instance_exists(NearestWound) = false {
if place_meeting(x,y,NearestWound) {
DesiredSpeed = GrazingSpeed
SpeedChangeRate = 0.001
DesiredHeading = point_direction(NearestWound.x,NearestWound.y,x,y)
CurrentHeading = DesiredHeading
} else {
State = "grazing"
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
if instance_exists(NearestWound) {
CurrentDirection = point_direction(NearestWound.x,NearestWound.y,x,y)
} else {
CurrentDirection = random(360)
}
}
} else {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}

// CLUSTERING ----------------------------------------------------------------------

} else if State = "clustering" {


if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}

//If Seed Clusterer, Count Down ClusterTimer. If it runs out, reset and begin grazing.

if SeedClusterer = true {
if DoNotClusterHere = false {
DesiredSpeed = 0
SpeedChangeRate = 0.001
if ClusterTimer &gt; 0 {
ClusterTimer -= 1
} else if ClusterTimer &lt;= 0 {
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
State = "grazing"
SeedClusterer = false
ClusterTimer = 8000
tController.Clusters -= 1
CurrentChildren = 0
}


if BabyTimer &gt; 0 {
BabyTimer -= 1
} else if BabyTimer &lt;= 0 {
PointX = x + lengthdir_x(random_range(2, ClusterRadius),random(360))
PointY = y + lengthdir_y(random_range(2, ClusterRadius),random(360))
ThisBaby = instance_create(PointX,PointY,tMole)

with ThisBaby {
Energy = 100
OriginalXScale = other.image_xscale / 2
OriginalYScale = other.image_yscale / 2
image_xscale = OriginalXScale
image_yscale = 0
BaseXScale = OriginalXScale
BaseYScale = OriginalYScale
ZOutScale = OriginalXScale * 5
GrowMax = OriginalXScale + 0.2
State = "clustering"
ClusterPointX = x
ClusterPointY = y
ClusterParent = other.id
}
BabyTimer = random_range(BabyCreateLower,BabyCreateHigher)
}
}

} else if SeedClusterer = false {
//Stop clustering as soon as Parent stops.
if ClusterParent.State != "clustering" {
State = ClusterParent.State
ClusterParent = noone
CurrentChildren = 0
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
WanderX = x
WanderY = y
}

//Change Cluster Point If Not Legal

if position_meeting(ClusterPointX,ClusterPointY,tCollision) {
ClusterPointX = ClusterParent.x + lengthdir_x(random_range(5, ClusterParent.ClusterRadius),random(360))
ClusterPointY = ClusterParent.y + lengthdir_y(random_range(5, ClusterParent.ClusterRadius),random(360))
}

if x &gt; ClusterPointX - 1 and x &lt; ClusterPointX + 1
and y &gt; ClusterPointY - 1 and y &lt; ClusterPointY + 1 {
DesiredSpeed = 0
CurrentSpeed = 0
} else {
DesiredHeading = point_direction(x,y,ClusterPointX,ClusterPointY)
CurrentHeading = DesiredHeading
DesiredSpeed = GrazingSpeed * SpeedMod
}

}

// SHIVERING -----------------------------------------------------------------------------

} else if State = "shivering" {

if instance_exists(SourceOfFear) {
if point_distance(x,y,SourceOfFear.x,SourceOfFear.y) &lt;= SenseRadius {
DesiredSpeed = FleeSpeed * SpeedMod
DirectionChangeRate = 5
SpeedChangeRate = 0.02
DesiredHeading = point_direction(SourceOfFear.x,SourceOfFear.y,x,y)
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}
} else {
DesiredSpeed = 0 
CurrentSpeed = DesiredSpeed
}



if ShiverTimer &gt; 0 {
ShiverTimer -= 1


} else if ShiverTimer &lt;= 0 {
ShiverTimer = 0
ShiverOrNot = 0
XOffset = 0
State = "grazing"
if point_distance(oShepherdBody.x,oShepherdBody.y,x,y) &lt;= SenseRadius {
GrazeX = oShepherdBody.x
GrazeY = oShepherdBody.y
} else {
GrazeX = x
GrazeY = y
}
SourceOfFear = noone
}

if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}



// FOLLOWING SHEPHERD ------------------------------------------------------------------

} else if State = "following" {

DesiredSpeed = oShepherdParent.CurrentSpeed * SpeedMod
DirectionChangeRate = 1
SpeedChangeRate = 0.003
DesiredHeading = point_direction(x,y,oShepherdParent.x,oShepherdParent.y)

if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &gt; 300 {
State = "grazing"
GrazeX = x
GrazeY = y
}

}


//CALLING OUT ---------------------------------------------------------------------------


//Depending On State, Call Out
if Pausing = true and State != "grazing" {
if CallOrNot = 1 {
if CallWaitTimer &gt; 0 {
CallWaitTimer -= 1 
} else if CallWaitTimer &lt;= 0 {
//Shiver &amp; Make The Call, Depending On State (Just Once)
if Called = false {
if tController.CurrentView = "in" {
audio_play_sound_at(aTestCall,x,y,0,100,300,1,false,1)
}
//Play The Sound
Called = true
}

if audio_is_playing(aTestCall) {
if ShiverDirection = "left" {
x -= 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "right"
}
} else if ShiverDirection = "right" {
x += 0.5
XOffset += 1
if XOffset &gt; 1 {
XOffset = 0 
ShiverDirection = "left"
}
}
}
}
}
}

}

}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Staying On Body &amp; Collision

///Then, Collision Avoidance &amp; Separation

//Set Current Depth Depending On Nearby Moles
HighestColliderY = 0
HighestCollider = noone

with (tMole) {
if place_meeting(x,y,other) {
if y &gt; other.HighestColliderY {
other.HighestCollider = id
other.HighestColliderY = y
}
}
}

if HighestCollider != noone {
if HighestColliderY &gt; y {
depth = HighestCollider.depth + 0.0001
} else {
depth = OriginalDepth
}
} else {
depth = OriginalDepth
}




if Energy &gt; 0 {
if CollisionAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead1.x,CollisionAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead2.x,CollisionAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollisionAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,CollisionAhead3.x,CollisionAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}



if State = "fleeing" or State = "clustering" or State = "following" or
(State = "wandering" and CurrentlyHunting = "moles")
or (State = "grazing" and SensedWound = true and WoundOfInterest = NearestWound)
{

if WoundAhead1 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead1.x,WoundAhead1.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead2 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead2.x,WoundAhead2.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if WoundAhead3 != noone {
//Turning
HeadingToCol = point_direction(x,y,WoundAhead3.x,WoundAhead3.y)
if HeadingToCol &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToCol &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
}

if CollidingWound {
DistX = sign (x - CollidingWound.x)
DistY = sign(y - CollidingWound.y)
x += DistX
y += DistY
}

}

//Colliding 

if CollidingWall {
DistX = sign(x - CollidingWall.x)
DistY = sign(y - CollidingWall.y)
x += DistX
y += DistY
CurrentHeading = point_direction(CollidingWall.x,CollidingWall.y,x,y)
DirectionChangeRate = 5
}


//Avoiding Edge Of Room
if GapAhead1 = true or GapAhead3 = true or GapAhead2 = true {
if GapAhead3 = true {
DesiredHeading = (CurrentHeading - 30)
} else if GapAhead1 = true {
DesiredHeading = (CurrentHeading + 30)
} else if GapAhead2 = true {
DesiredHeading = (CurrentHeading - 30)
}
}

//Clamping To Body
x = clamp(x,tHead.x - (tHead.sprite_width / 2),tHead.x + (tHead.sprite_width / 2))
y = clamp(y,tHead.y - (tHead.sprite_height / 2),tHead.y + (tHead.sprite_height / 2))

//Avoiding Shepherd
if point_distance(x,y,oShepherdBody.x,oShepherdBody.y) &lt;= 30 {
if State = "grazing" {
DesiredHeading = point_direction(oShepherdBody.x,oShepherdBody.y,x,y)
CurrentHeading = DesiredHeading
} else if State = "wandering" {
HeadingToShep = point_direction(x,y,WoundAhead2.x,WoundAhead2.y)
if HeadingToShep &lt; CurrentHeading {
DesiredHeading = (CurrentHeading + 30)
} else if HeadingToShep &gt;= CurrentHeading {
DesiredHeading = (CurrentHeading - 30)
}
} else if State = "following" {
DesiredSpeed = 0
}
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Coming To Desired Speed And Direction

if GrownToSize = true {

//Speed

if Pausing = false and Energy &gt; 0 {
if CurrentSpeed != DesiredSpeed {
if CurrentSpeed &lt; DesiredSpeed {
CurrentSpeed += SpeedChangeRate
} else if CurrentSpeed &gt; DesiredSpeed {
CurrentSpeed -= SpeedChangeRate
}
}
hspeed = CurrentSpeed
vspeed = CurrentSpeed
} else {
hspeed = 0
vspeed = 0
}

//Direction

if CurrentHeading != DesiredHeading {
if DesiredHeading &gt; CurrentHeading + DitherMod {
CurrentHeading += DirectionChangeRate
} else if DesiredHeading &lt; CurrentHeading - DitherMod {
CurrentHeading -= DirectionChangeRate
}
} 

direction = CurrentHeading

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing With UI

if Drawing = true {
draw_sprite_ext(sprite_index,0,x,y,image_xscale,image_yscale,0,c_white,1 - Redness)
if tController.CurrentView = "in" {
draw_sprite_ext(sprite_index,0,x,y,image_xscale,image_yscale,0,c_red,Redness)
}

if tController.ChosenMole = self.id {
draw_set_colour(c_lime)
draw_set_alpha(0.7)
if SeedClusterer = false {
draw_circle(x,y,SenseRadius,true)
}

draw_set_halign(fa_center)
draw_set_valign(fa_center)
draw_set_color(c_red)
draw_set_alpha(1)
draw_set_font(fController)



if State = "wandering" {
draw_text(x, y + 20, "Neighbours: " + string(Neighbours))
}
draw_set_color(c_purple)
draw_line(x,y,ColPointXM,ColPointYM)
draw_line(x,y,ColPointXL,ColPointYL)
draw_line(x,y,ColPointXR,ColPointYR)
draw_set_colour(c_red)
PosY = y - 200


if SensedFur = true {
draw_text(x,PosY,"sensed fur")
} else {
draw_text(x,PosY,"no fur")
}

if State = "wandering" {
if Pausing = true {
PosY += 20
draw_text(x,PosY,"Pausing")
PosY += 20
draw_text(x,PosY,"Until: " + string(WanderPauseTimer))
} else {
PosY += 20
draw_text(x,PosY,"Moving Until: " + string(WanderTimer))
}
} else if State = "grazing" {
if Pausing = true {
PosY += 20
draw_text(x,PosY,"Pausing")
PosY += 20
draw_text(x,PosY,"Until: " + string(GrazePauseTimer))
} else {
PosY += 20
draw_text(x,PosY,"Moving Until: " + string(GrazeTimer))
}
}
PosY += 20
if SensedMole = true {
draw_text(x,PosY,"sensed mole")
} else {
draw_text(x,PosY,"no moles")
}
PosY += 20
if SensedWound = true {
draw_text(x,PosY,"sensed wound")
} else {
draw_text(x,PosY,"no wound")
}
if SeedClusterer = true {
PosY += 20
draw_text(x,PosY,"seeder")
PosY += 20
draw_text(x,PosY,"Max Children: " + string(MaxChildren))
PosY += 20
draw_text(x,PosY,"Current Children: " + string(CurrentChildren))
PosY += 20
draw_text(x,PosY,"Time Until Baby: " + string(BabyTimer))
PosY += 20
draw_text(x,PosY,"Cluster Timer: " + string(ClusterTimer))
draw_set_colour(c_orange)
draw_circle(x,y,ClusterRadius,true)
draw_set_colour(c_red)
}
PosY += 20
draw_text(x,PosY,"Hunger: " + string(Hunger))
PosY += 20
draw_text(x,PosY,"Lonely: " + string(Loneliness))
PosY += 20
draw_text(x,PosY,"Energy: " + string(Energy))
PosY += 20
draw_text(x,PosY,State)
if State = "fleeing" {
PosY += 20
draw_text(x,PosY,string(FleeTimer))
} else if State = "grazing" {
draw_circle(GrazeX,GrazeY,GrazeRadius,true)
} else if State = "wandering" {
draw_circle(WanderStartX,WanderStartY,WanderRadius,true)
}
if GapAhead1 = true or GapAhead2 = true or GapAhead3 = true {
PosY += 20
draw_text(x,PosY,"Gap Ahead")
}
if CollisionAhead1 != noone or CollisionAhead2 != noone or CollisionAhead3 != noone {
PosY += 20
draw_text(x,PosY,"Collision Ahead")
}
if State = "clustering" and SeedClusterer = false {
draw_line_colour(x,y,ClusterPointX,ClusterPointY,c_blue,c_blue)
}

}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
